//===== rAthena Documentation===========rAthena说明文档=====================
//= rAthena Script Commands             rAthena脚本命令
//===== By:==================================================
//= rAthena Dev Team                    rAthena开发团队
//===== Last Updated:====================最近更新====================
//= 20201115                    2024已追加20220308新增指令(译者注)
//===== Description:======================描述===================
//= A reference manual for the rAthena scripting language.      rAthena 脚本语言参考手册。
//= Commands are sorted depending on their functionality.       命令根据其功能排序。
//===========================================================

This document is a reference manual for all the scripting commands and functions
available in rAthena. It is not a simple tutorial. When people tell you to
"Read The F***ing Manual", they mean this.
本文档是所有运用于rAthena的脚本命令和函数的参考手册。

This is not a place to teach you basic programming. This document will not teach
you basic programming by itself. It's more of a reference for those who have at
least a vague idea of what they want to do and want to know what tools they have
available to do it. We've tried to keep it as simple as possible, but if you
don't understand it, getting a clear book on programming in general will help
better than yelling around the forum for help.
这里不是教你基本编程的地方。这份文档不会教你
如何编写基本的程序。对于那些至少对自己想实现什么有模糊认识，并且想知道自己有什么
工具可以藉此实现的人来说，这更像是一个参考。我们已经尽力让它尽可能简单，但是如果你如果
你不理解它，弄一本通俗易懂的编程书学习基础会有帮助，总比在论坛上寻求帮助要好。



A little learning never caused anyone's head to explode.
一点学问也不会让任何人的脑袋爆炸。

Structure
结构
---------

The script commands are listed in no particular order, but are grouped by
relative function.
脚本命令不按特定顺序列出，但按相关函数分组。

*Name of the command and parameters (if any).
*命令和参数的名称（如果有）。

Descriptive text
描述性文本

	Small example if possible. Will usually be incomplete, it's there just to
	give you an idea of how it works in practice.
	如果可能，会给出一点实例。通常是不完整的，它只是给你一个如何运用的参考。

To find a specific command, use Ctrl+F, (or whatever keys call up a search
function in whatever you're reading this with) put an asterisk (*) followed by the command
name, and it should find the command description for you.
要查找特定命令，请使用Ctrl+F（或在阅读本文档时使用关键字进行搜索），在命令名前面加上星号（*），它应该可以为您查找命令说明。

If you find anything missing, please let us know!
如果你发现什么东西缺失，请通知我们！

Syntax
语法
------

Throughout this document, wherever a command wants an argument, it is given in
<angle brackets>. This doesn't mean you should type the angle brackets. If an
argument of a command is optional, it is given in {curly brackets}. You've
doubtlessly seen this convention somewhere. If a command can optionally take
an unspecified number of arguments, you'll see a list like this:
在本文档中，如果命令需要参数，就在<尖括号>中给出。尖括号不需要输入。
如果命令的参数是可选的，则在{花括号}中给出。你肯定在什么地方见过这种表示的方法。
如果命令可以选择接受数量不确定的参数，您将看到如下列表：

command <argument>{,<argument>...<argument>}
命令 <参数>{,<参数>...<参数>}

This still means they will want to be separated by commas.
表示参数需要用逗号分隔。

Where a command wants a string, it will be given in "quotes", if it's a number,
it will be given without them. Normally, you can put an expression, like a bunch
of functions or operators returning a value, in (round brackets) instead of most
numbers. Round brackets will not always be required, but they're often a good
idea.
如果一个命令需要一个字符串，它将以“引号”给出，如果它是一个数字，它将不带引号给出。
通常，您可以将表达式（如一组有返回值的函数或运算符）放在（圆括号）中，而不是直接放在参数中。
圆括号并不总是必需的，但最好是加上。


Wherever you refer to a map name, it's always 'map name' (.gat suffix is deprecated).
无论您在何处调用地图名，就用'地图名称'表示（.gat后缀可不加）。


Script loading structure
脚本加载结构
------------------------

Scripts are loaded by the map server as referenced in the 'conf/map_athena.conf'
configuration file, but in the default configuration, it doesn't load any script
files itself. Instead, it loads the file 'npc/(pre-)re/scripts_main.conf' which itself
contains references to other files. The actual scripts are loaded from txt
files, which are linked up like this:
map服务器的相关设置位于路径'conf/map_athena.conf'中。但在默认配置中，
它并不加载任何脚本文件。npc目录总配置文件的路径是'npc/(pre-)re/scripts_main.conf'。
里面的内容是各个npc的分目录配置文件，npc分目录配置文件里面是各个要加载的npc文件的路径。
npc实例脚本是从txt文件加载的，这些文件链接的书写格式如下：

npc: <path to a filename>
npc: <文件路径>

Any line like this, invoked, ultimately, by 'map_athena.conf' will load up the
script contained in this file, which will make the script available. No file
will get loaded twice to prevent possible errors.
每行这样的语句，通过'map_athena.conf'将会加载此文件中包含的脚本，
并执行。为防止可能的错误，服务器不会重复加载文件。

Another configuration file option of relevance is:
另一个相关的配置文件选项是：

delnpc: <path to a filename>
delnpc: <文件路径>

This will unload a specified script filename from memory, which, while
seemingly useless, may sometimes be required.
这将从内存中卸载一个指定的脚本文件名，虽然看起来没有用，但是有时可能会需要。


Whenever '//' is encountered in a line upon reading, everything beyond this on
that line is considered to be a comment and is ignored. This works wherever you
place it.
脚本读取时如果在一行中遇到'//'这个符号，该行中这个符号之后的所有内容都将被视为注释，并被忽略。该符号可以放置在任何地方。

// This line will be ignored when processing the script.
//处理脚本时将忽略此行。

Block comments can also be used, where you can place /* and */ between any text you
wish rAthena to ignore.
也可以使用区域注释，您可以在希望rAthena忽略的任何文本之间放置/*和*/。

Example:
/* This text,
 * no matter which new line you start
 * is ignored, until the following
 * symbol is encountered: */
例子：
/*无论您从哪一行开始，
*此文本都将被忽略，
*直到遇到以下符号：*/

The asterisks (*) in front of each line is a personal preference and is not required.
每行前面加的星号（*）是个人偏好，不需要加。

Upon loading all the files, the server will execute all the top-level commands
in them. No variables exist yet at this point, no commands can be called other
than those given in this section. These commands set up the basic structure - create
NPC objects, spawn monster objects, set map flags, etc. No code is actually
executed at this point. The top-level commands are pretty confusing, since
they aren't structured like you would expect (command name first), but rather,
normally start with a map name.
加载所有文件后，服务器将执行其中的所有最高优先级的命令。此时还不存在变量，
除了本节中给出的命令外，不会执行其他命令。这些命令设置了基本结构-创建NPC对象、
生成怪物对象、设置地图标志等。此时实际上没有执行任何代码。最高优先级的命令比较难理解
，因为它们的结构和一般的不同（首先是命令名），而是通常以地图名开头。

What's more confusing about the top-level commands is that most of them use a
tab symbol to divide their arguments.
最高优先级命令的理解难点在于，它们中的大多数使用Tab按键跳格来划分参数。

To prevent problems and confusion, the tab symbols are written as '%TAB%'
throughout this document, even though this makes the text a bit less readable.
Using an invisible symbol to denote arguments is one of the bad things about
this language.
为了防止出现问题和混淆，在整个文档中，Tab按键跳格都写为'%tab%'，尽管这会使文本的可读性稍差。
但是使用不可见的符号来表示参数在编写脚本过程中是不好的。

Here is a list of valid top-level commands:
以下是有最高优先级命令列表：

** Set a map flag:
** 设置地图标志:

<map name>%TAB%mapflag%TAB%<flag>
<地图名>%TAB%地图标志%TAB%<标志>

This will, upon loading, set a specified map flag on a map you like. These are
normally in files inside 'npc/mapflag' and are loaded first, so by the time the
server's up, all the maps have the flags they should have. Map flags determine
the behavior of the map in various situations. For more details, see 'setmapflag'
and 'doc/mapflags.txt'.
这将在加载时在需要的地图上设置指定的地图标志。这些设置通常位于路径'npc/mapflag'内的文件中，
并优先加载，因此在服务器启动时，所有地图都被设置了相应的标志。

** Create a permanent monster spawn:
** 创建可重生的魔物：

<map name>{,<x>{,<y>{,<xs>{,<ys>}}}}%TAB%monster%TAB%<monster name>{,<monster level>}%TAB%<mob id>,<amount>{,<delay1>{,<delay2>{,<event>{,<mob size>{,<mob ai>}}}}}
<地图名>{,<x坐标>{,<y坐标>{,<半径xs>{,<半径ys>}}}}%TAB%monster%TAB%<魔物名称>{,<魔物等级>}%TAB%魔物 id>,<数量>{,<延迟1>{,<延迟2>{,<事件>{,<魔物尺寸>{,<魔物 ai>}}}}}

Map name is the name of the map the monsters will spawn on. x,y are the
coordinates where the mob should spawn. If xs and ys are non-zero, they
specify the 'radius' of a spawn-rectangle area centered at x,y.
Putting zeros instead of these coordinates will spawn the monsters randomly.
Note this is only the initial spawn zone, as mobs random-walk, they are free
to move away from their specified spawn region.
地图名称是该可重生魔物所处的地图的名称。x,y是魔物重生的位置坐标。如果xs和ys不为0，
则会以x，y为中心的矩形区域的'半径'范围内重生。这些坐标为0的话将随机产生魔物。
注意这只是重生的初始位置，当魔物随机移动时，他们可以自由移动并离开指定的重生区域。

Monster name is the name the monsters will have on screen, and has no relation
whatsoever to their names anywhere else. It's the mob id that counts, which
identifies monster record in 'mob_db.txt' database of monsters. If the mob name
is given as "--ja--", the 'japanese name' field from the monster database is
used, (which, in rAthena, actually contains an English name) if it's "--en--",
it's the 'english name' from the monster database (which contains an uppercase
name used to summon the monster with a GM command).
魔物名称是魔物在游戏画面显示的名称，和他们在数据库里的其他名称没有任何关系。魔物id会从魔物
数据库文件'mob_db.txt'里面对应的id读取该魔物的相关数据。如果魔物名称设置为"--ja--"，
则会显示数据库里'japanese name'位置的名称，(在rAthena，还有English name)如果设置了
"--en--",则显示怪物数据库中的“English name”（包含一个大写名称，该名称可用于GM命令召唤魔物）。


You can specify a custom level to use for the mob different from the one of
the database by adjoining the level after the name with a comma. eg:
"Poring,50" for a name will spawn a monster with name Poring and level 50.
您可以在名称后面逗号隔开的下一个位置指定该魔物的等级，级别可以与数据库的等级不同。
举例："波利,50"这样的写法将会产生一个50级的名为波利的魔物。

Amount is the amount of monsters that will be spawned when this command is
executed, it is affected by spawn rates in 'battle_athena.conf'.

数量 既是该命令执行的时候产生的魔物数量，'battle_athena.conf'里面的设置也会影响最终召唤的实际数量。

Delay1 and delay2 control monster respawn delays - the first one is the fixed
base respawn time, and the second is random variance on top of the base time.
Both values are given in milliseconds (1000 = 1 second).
Note that the server also enforces a minimum respawn delay of 5 seconds.

延迟1和延迟2控制魔物重生的时间 - 第一个是固定重生时间，第二个是重生随机时间的最大值。
这两个值都是以毫秒计算 （1000 = 1秒）。
注意，服务器会默认有5秒的最小重生延迟。


Event is a script event to be executed when the mob is killed. The event must
be in the form "NPCName::OnEventName" to execute, and the event name label
should start with "On". As with all events, if the NPC is an on-touch NPC, the
player who triggers the script must be within 'trigger' range for the event to
work.
事件 是在mob被杀死时执行的脚本事件。事件必须以“NPC名称::On事件名称”的形式执行，
事件标签名称应以“On”开头。与所有事件一样，如果NPC是范围触发式NPC，则触发脚本的玩家
必须在“触发”范围内，事件才会触发。

There are two optional fields for monster size and AI.
魔物的尺寸和AI是两个可选项。

<mob size> can be:
<魔物尺寸> 可以设置为:
	Size_Small	(0)   //小尺寸
	Size_Medium	(1)   //中尺寸
	Size_Large	(2)   //大尺寸

<mob ai> can be:
<魔物 ai> 可以设置为:
	AI_NONE		(0)		(default)   //默认
	AI_ATTACK	(1)		(attack/friendly)  //攻击/友善的
	AI_SPHERE	(2)		(Alchemist skill)  //炼金技能召唤出的魔物
	AI_FLORA	(3)		(Alchemist skill)  //炼金技能召唤出的魔物
	AI_ZANZOU	(4)		(Kagerou/Oboro skill)  //影狼/胧的技能
	AI_LEGION	(5)		(Sera skill)  //莎拉的技能
	AI_FAW		(6)		(Mechanic skill)  //机匠的技能

Alternately, a monster spawned using 'boss_monster' instead of 'monster' is able
to be detected on the map with the SC_BOSSMAPINFO status (used by Convex Mirror).
如果用'boss_monster'替换原来的'monster'指令，则可以创建能用BOSS雷达显示的魔物。
(BOSS雷达使用后会在角色的身上附加一个SC_BOSSMAPINFO的状态，该状态可以显示BOSS魔物在小地图上的坐标)

** NPC names
** NPC 名称

/!\ WARNING: this applies to warps, NPCs, duplicates and shops /!\
/!\ 注意: 这种写法是传送点，NPC，复制型和商店通用的 /!\

NPC names are kinda special and are formatted this way:
NPC名称的格式如下：

<Display name>{::<Unique name>}
<显示名>{::<独有名>}

All NPCs need to have a unique name that is used for identification purposes.
When you have to identify a NPC by its name, you should use <Unique name>.
If <Unique name> is not provided, use <Display name> instead.
所有NPC都需要有一个独有的名称，用于识别区分。
当您必须通过名称识别指定NPC时，应使用<独有名>。
如果未设置<独有名>，则用<显示名>。

The client has a special feature when displaying names:
if the display name contains a '#' character, it hides that part of the name.
ex: if your NPC is named 'Hunter#hunter1', it will be displayed as 'Hunter'
客户端在显示名称时有一个特殊功能：
如果显示名里包含'#'号时，那么‘#’号后面的字符将被隐藏，不显示。
例如：如果NPC名称是'猎人#猎人1',那么在游戏中他将会示‘猎人’。

<Display name> must be at most 24 characters in length.
<Unique name> must be at most 24 characters in length.
<显示名>的长度不得超过24个字符。
<唯一名名>的长度不得超过24个字符。

** Define a warp point
** 定义传送点

<from mapname>,<fromX>,<fromY>,<facing>%TAB%warp%TAB%<warp name>%TAB%<spanx>,<spany>,<to mapname>,<toX>,<toY>
<from mapname>,<fromX>,<fromY>,<facing>%TAB%warp2%TAB%<warp name>%TAB%<spanx>,<spany>,<to mapname>,<toX>,<toY>
<起始 地图名>,<起始X>,<起始Y>,<朝向>%TAB%warp%TAB%<传送点名称>%TAB%<作用范围x>,<作用范围y>,<目的地 地图名>,<目的地X>,<目的地Y>
<起始 地图名>,<起始X>,<起始Y>,<朝向>%TAB%warp2%TAB%<传送点名称>%TAB%<作用范围x>,<作用范围y>,<目的地 地图名>,<目的地X>,<目的地Y>

This will define a warp NPC that will warp a player between maps, and while most
arguments of that are obvious, some deserve special mention.
这是定义一个用来在两个地图之间传送的传送点，注意理解里面的参数。

SpanX and SpanY will make the warp sensitive to a character who didn't step
directly on it, but walked into a zone which is centered on the warp from
coordinates and is SpanX in each direction across the X axis and SpanY in each
direction across the Y axis.
SpanX和SpanY将使传送点对没有直接踩到它的角色起作用，这个区域是以传送点坐标为中心
SpanX和SpanY为区域半径的一个矩形范围。

Warp NPC objects also have a name, because you can use it to refer to them later
with 'enablenpc'/'disablenpc'
传送点NPC也有名称，该名称用于其他命令对其进行开启和关闭的操作。

Facing of a warp object is irrelevant, it is not used in the code and all
current scripts have a zero in there.
传送点的朝向没有作用，在代码里取的都是0值。

Unlike 'warp', 'warp2' will also be triggered by hidden player.
'warp', 'warp2'的区别在于是否对隐藏的角色起作用

** Define an NPC object.
** 定义一个NPC对象.

<map name>,<x>,<y>,<facing>%TAB%script%TAB%<NPC Name>%TAB%<sprite id>,{<code>}
<map name>,<x>,<y>,<facing>%TAB%script%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>,{<code>}
<地图名称>,<x坐标>,<y坐标>,<朝向>%TAB%script%TAB%<NPC名称>%TAB%<图像id>,{<代码>}
<地图名称>,<x坐标>,<y坐标>,<朝向>%TAB%script%TAB%<NPC名称>%TAB%<图像id>,<触发范围X>,<触发范围Y>,{<代码>}

This will place an NPC object on a specified map at the specified location, and
is a top-level command you will use the most in your custom scripting. The NPCs
are triggered by clicking on them, and/or by walking in their trigger area, if
defined, see that below.
这段代码会在指定的地图和坐标位置上设置一个NPC对象，这是脚本里最常用的语句。
NPC通过点击触发，或者通过进入设置好的触发范围而触发，请看下面对于设置触发范围的解释。

Facing is a direction the NPC sprite will face in. Not all NPC sprites have
different images depending on the direction you look from, so for some facing
will be meaningless. Facings are counted counterclockwise in increments of 45
degrees, where 0 means facing towards the top of the map. (So to turn the sprite
towards the bottom of the map, you use facing 4, and to make it look southeast
it's facing 5.)
朝向 是NPC图像的朝向。并不是所有的NPC图像都有不同的朝向图片，并且还取决你的视角，因此
有时候朝向无意义。朝向 的变量以45°为一个单位按逆时针方向递增，0表示朝向地图的正上方。
(因此你要让图像显示为朝下的方向，则朝向设置为4，如果要朝向东南，则朝向设置为5.)

Sprite ID is the sprite number or constant used to display this particular NPC.
You may also use a monster's ID instead to display a monster sprite for this NPC.
It is possible to use a job sprite as well, but you must first define it as a
monster sprite in 'mob_avail.txt', a full description on how to do this is not
in the scope of this manual.
A '-1' Sprite ID will make the NPC invisible (and unclickable).
A '111' Sprite ID will make an NPC which does not have a sprite, but is still
clickable, which is useful if you want to make a clickable object of the 3D
terrain.
图像ID是用于显示此NPC图像的编号或常量。你也可以使用魔物ID，对应的魔物图像将会作为该NPC的图像。
另外也可以使用职业图像，不过你必须先在'mob_avail.txt'里将该职业作为魔物的替换图定义。这里先不赘述。
ID为'-1'的图像ID表示该NPC不可见(或者不能在游戏里被点击)。
ID为'111'的图像ID并不显示图像，但是可以在游戏里被点击，作用是用来设置以地图3D模型作为
NPC对象的场合。


TriggerX and triggerY, if given, will define an area, centered on NPC and
spanning triggerX cells in every direction across X and triggerY in every
direction across Y. Walking into that area will trigger the NPC. If no
'OnTouch:' special label is present in the NPC code, the execution will start
from the beginning of the script, otherwise, it will start from the 'OnTouch:'
label. Monsters can also trigger the NPC, though the label 'OnTouchNPC:' is
used in this case.
触发范围X和触发范围Y，如果被赋值，则定义触发范围。以NPC为中心，触发范围X为X轴，触发范围Y为Y轴的十字方格双向范围内，
只要进入这个范围就会触发NPC。如果NPC脚本中没有'OnTouch:'这个特殊标签，则从脚本开头开始执行脚本，
如果有，则从'OnTouch:'处开始执行。魔物也一样会触发NPC，这种情况下就要通过'OnTouchNPC:'的标签触发。

The code part is the script code that will execute whenever the NPC is
triggered. It may contain commands and function calls, descriptions of which
compose most of this document. It has to be in curly brackets, unlike elsewhere
where we use curly brackets, these do NOT signify an optional parameter.
代码部分就是脚本的主体代码，触发NPC以后执行的部分。包含了各种命令和函数调用，描述说明
所组成的文本。这部分必须在花括号中，不像其他地方使用的花括号，在这里并不是表示可选参数。

** Define a 'floating' NPC object.
**定义'浮动'NPC对象。

-%TAB%script%TAB%<NPC Name>%TAB%-1,{<code>}
-%TAB%script%TAB%<NPC名称>%TAB%-1,{<代码>}

This will define an NPC object not triggerable by normal means. This would
normally mean it's pointless since it can't do anything, but there are
exceptions, mostly related to running scripts at specified time, which is what
these floating NPC objects are for. More on that below.
这会定义一个不是按普通触发方式触发的NPC对象。在通常情况下没有作用，
因为它不能做任何事情，这些浮动NPC对象的用途是，作为一个模块嵌入到其他脚本实例中，
用来实现一些重复的，需要多次创建的NPC，作为复制NPC用。

** Define a shop/cashshop/itemshop/pointshop NPC.
** 定义一个商店/商城点数商店/物品商店/点数商店 NPC.

-%TAB%shop%TAB%<NPC Name>%TAB%<sprite id>{,discount},<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%shop%TAB%<NPC Name>%TAB%<sprite id>{,discount},<itemid>:<price>{,<itemid>:<price>...}
-%TAB%shop%TAB%<NPC名称>%TAB%<图像id>{,折扣},<物品编号>:<价格>{,<物品编号>:<价格>...}
<地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%shop%TAB%<NPC名称>%TAB%<图像id>{,折扣},<物品编号>:<价格>{,<物品编号>:<价格>...}

-%TAB%cashshop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%cashshop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>{,<itemid>:<price>...}
-%TAB%cashshop%TAB%<NPC名称>%TAB%<图像id>,<物品编号>:<价格>{,<物品编号>:<价格>...}
<地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%cashshop%TAB%<NPC名称>%TAB%<图像id>,<物品编号>:<价格>{,<物品编号>:<价格>...}

-%TAB%itemshop%TAB%<NPC Name>%TAB%<sprite id>,<costitemid>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%itemshop%TAB%<NPC Name>%TAB%<sprite id>,<costitemid>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}
-%TAB%itemshop%TAB%<NPC名称>%TAB%<图像id>,<消耗物品编号>{:<折扣>},<物品编号>:<价格>{,<物品编号>:<价格>...}
<地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%itemshop%TAB%<NPC名称>%TAB%<图像id>,<消耗物品编号>{:<折扣>},<物品编号>:<价格>{,<物品编号>:<价格>...}

-%TAB%pointshop%TAB%<NPC Name>%TAB%<sprite id>,<costvariable>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}
<map name>,<x>,<y>,<facing>%TAB%pointshop%TAB%<NPC Name>%TAB%<sprite id>,<costvariable>{:<discount>},<itemid>:<price>{,<itemid>:<price>...}
-%TAB%pointshop%TAB%<NPC名称>%TAB%<图像id>,<消耗的点数变量>{:<折扣>},<物品编号>:<价格>{,<物品编号>:<价格>...}
<地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%pointshop%TAB%<NPC名称>%TAB%<图像id>,<消耗的点数变量>{:<折扣>},<物品编号>:<价格>{,<物品编号>:价格>...}

<map name>,<x>,<y>,<facing>%TAB%marketshop%TAB%<NPC Name>%TAB%<sprite id>,<itemid>:<price>:<quantity>{,<itemid>:<price>:<quantity>...}
<地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%marketshop%TAB%<NPC名称>%TAB%<图像id>,<物品编号>:<价格>:<数量>{,<物品编号>:<价格>:<数量>...}

This will define a shop NPC, which, when triggered (which can only be done by
clicking) will cause a shop window to come up. No code whatsoever runs in shop
NPCs and you can't change the prices otherwise than by editing the script
itself.
以上代码用于定义一个商店NPC，当点击(仅可通过点击触发)的时候，会弹出商店的交易界面。
没有任何代码可以在商店NPC中运行，您只能通过编辑脚本本身来更改价格。

The Item ID is the number of item in the 'db/item_db.yml' database. If Price is set
to -1, the 'buy price' given in the item database will be used. Otherwise, the
price you gave will be used for this item, which is how you create differing
prices for items in different shops.
物品编号的相关物品数据在'db/item_db.yml'数据库里。如果将价格设置为 -1 ，
则将使用物品数据库里的'买入价格buy price'。除此之外，将会使用设置好的价格，
即便你在不同商店里设置了不同的价格。

Optionally you can specify the discount option and set it to "yes" or "no", to enable or disable discounting.
您可以随意设置折扣选项(可选参数)并将其设置为“yes”或“no”，以启用或禁用折扣。

There are other types of shops available:
cashshop - use "cashshop" in place of "shop" to use the Cash Shop interface, allowing
you to buy items with special points that are stored as account variables
called  #CASHPOINTS and #KAFRAPOINTS. This type of shop will not allow you to sell
items at it, only make purchases. The layout used to define sale items still count, and
"<price>" refers to how many points will be spent purchasing the them.
允许设置其他的商店类型如：
商城点数商店 - 用"cashshop"替代"shop"命令将会使用商城点数的商店界面，允许
你使用特殊的点数来购买物品，特殊点数存储在账号关联的变量里，
为#CASHPOINTS(商城点数) 和 #KAFRAPOINTS(卡普拉点数)。这种类型的商店无法
出售物品返回相应的点数，只能购买。这样的写法也可以指定物品的售价，"<价格>"
里的数值就是设置了该物品购进时消耗的点数。

"itemshop" and "pointshop" use the Shop interface, allowing you to buy items with a specific
item or special points from a variable. 'pointshop' only supports permanent character variables,
temporary character variables, permanent local account variables or permanent global account
variables. These variables must be of integer type, not string. 'discount' flag is an
optional value which makes the price at that shop become affected by discount skill.
"物品商店"和"点数商店"沿用了商店的界面，允许你用特定物品和特定的变量代表的点数购买物品。
'点数商店'只支持使用角色关联的永久变量，临时变量，自身永久帐户变量或者永久全局变量。
这些变量必须是整数型，不可以用字符串。'折扣'标签是个可选参数，用来设置是否可以通过
减价类技能降低售价。


** Define an warp/shop/cashshop/itemshop/pointshop/NPC duplicate.
** 定义一个 传送点/商店/商城点数商店/物品商店/点数商店/NPC 的复制.

warp/warp2: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<spanx>,<spany>
shop/cashshop/itemshop/pointshop/npc: -%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>
shop/cashshop/itemshop/pointshop/npc: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>
npc: -%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>
npc: <map name>,<x>,<y>,<facing>%TAB%duplicate(<label>)%TAB%<NPC Name>%TAB%<sprite id>,<triggerX>,<triggerY>
warp/warp2: <地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%duplicate(<标签>)%TAB%<NPC名称>%TAB%<作用范围x>,<作用范围y>
shop/cashshop/itemshop/pointshop/npc: -%TAB%duplicate(<标签>)%TAB%<NPC名称>%TAB%<图像 id>
shop/cashshop/itemshop/pointshop/npc: <地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%duplicate(<标签>)%TAB%<NPC名称>%TAB%<图像 id>
npc: -%TAB%duplicate(<标签>)%TAB%<NPC名称>%TAB%<图像 id>,<触发范围X>,<触发范围Y>
npc: <地图名称>,<坐标x>,<坐标y>,<朝向>%TAB%duplicate(<标签>)%TAB%<NPC名称>%TAB%<图像 id>,<触发范围X>,<触发范围Y>

This will duplicate an warp/shop/cashshop/itemshop/pointshop/NPC referred to by 'label'.
Warp duplicates inherit the target location.
Shop/cashshop/itemshop/pointshop duplicates inherit the item list.
NPC duplicates inherit the script code.
The rest (name, location, facing, sprite ID, span/trigger area)
is obtained from the definition of the duplicate (not inherited).
这将复制一个 传送点/商店/商城点数商店/物品商店/点数商店/NPC，'标签'里的字符串是所援引的NPC的名称.

** Define a function object
** 定义一个函数对象

function%TAB%script%TAB%<function name>%TAB%{<code>}
function%TAB%script%TAB%<函数名称>%TAB%{<代码>}

This will define a function object, callable with the 'callfunc' command (see
below). This object will load on every map server separately, so you can get at
it from anywhere. It's not possible to call the code in this object by
anything other than the 'callfunc' script command.
这将定义一个函数，使用'callfunc'指令进行调用(如下所示)。这个函数在服务器的每个地图都会被加载，
藉此你可以在任何地方调用。但是只有使用'callfunc'这个脚本命令才能调用函数。

The code part is the script code that will execute whenever the function is
called with 'callfunc'. It has to be in curly brackets, unlike elsewhere where
we use curly brackets, these do NOT signify an optional parameter.
代码部分是每当使用“callfunc”调用函数时将执行的脚本代码。
它必须在花括号中，不像其他地方使用花括号，这些并不表示可选参数。


Once an object is defined which has a 'code' field to its definition, it
contains script commands which can actually be triggered and executed.
一旦定义了一个对象，该对象的定义中就包含有一个“code”字段，它就包含了可以实际触发和执行的脚本命令。

~ RID? GID? ~

What a RID is and why do you need to know
什么是RID和你为什么需要了解它
-----------------------------------------

Most scripting commands and functions will want to request data about a
character, store variables referenced to that character, send stuff to the
client connected to that specific character. Whenever a script is invoked by a
character, it is passed a so-called RID - this is the account ID number of a
character that caused the code to execute by clicking on it, walking into its
OnTouch zone, or otherwise.
大部分脚本命令和函数都需要获取角色的数据，保存角色的相关变量，向指定的角色客户端
发送信息。当一个脚本被一个角色调用时，它将输送一个被称为RID的值，这是通过点击、或者
进入脚本触发范围，或者其他任何触发方式触发了脚本运行的角色相关的账户ID数值。

If you are only writing common NPCs, you don't need to bother with it. However,
if you use functions, if you use timers, if you use clock-based script
activation, you need to be aware of all cases when a script execution can be
triggered without a RID attached. This will make a lot of commands and functions
unusable, since they want data from a specific character, want to send stuff to
a specific client, want to store variables specific to that character, and they
would not know what character to work on if there's no RID.
如果只是写普通的NPC，可以不理它。尽管如此，如果你使用函数，如果你使用计时器，如果你用定时器触发脚本，
您需要了解在没有附加RID的情况下可以触发脚本执行的所有情况。这将使许多命令和函数无法使用，
因为它们需要来自特定角色的数据，将内容发送到特定客户端，存储关联角色的特定变量，如果没有RID，
将因不能对应角色而无法运行。

Unless you use 'attachrid' to explicitly attach a character to the script first.
除非你先用“attachrid”将该脚本关联到某一个特定的角色。

Whenever we say 'invoking character', we mean 'the character who's RID is
attached to the running script. The script function "playerattached" can be
used to check which is the currently attached player to the script (it will
return 0 if the there is no player attached or the attached player no longer
is logged on to the map-server).
当我们说'援引角色'，意思是'关联正在运行中脚本的RID对应的角色'。脚本函数"playerattached"
可以用来确定目前是哪个角色关联该脚本（返回0表示没有角色关联或者关联的角色已经登出游戏）。

But what about GID?
但是什么是GID？
-------------------

GID stands for the Game ID of something, this can either be the GID obtained
through mobspawn (mob control commands) or the account ID of a character.
Another way would be to right click on a mob, NPC or char as GM sprited char
to view the GID.
GID代表某个游戏对象的游戏ID，可以是通过mobspawn(魔物控制命令)召唤的魔物的GID或者角色的账号ID。
另一种方法是用GM形象的角色通过右键单击魔物、NPC或角色来查看GID。(经测试不行？)

See also 'getpetinfo', 'getmercinfo', 'gethominfo', and 'geteleminfo'.
另见'getpetinfo', 'getmercinfo', 'gethominfo', and 'geteleminfo'。

This is mostly used for the new version of skill and the mob control commands
implemented.
这主要用于新版本的技能和实现对魔物的控制命令。

Item and pet scripts
物品和宠物脚本
--------------------

Each item in the item database has three special fields - Script , OnEquip_Script
and OnUnequip_Script. The first is script code run every time a character equips the item,
with the RID of the equipping character. Every time they unequip an item, all
temporary bonuses given by the script commands are cleared, and all the scripts
are executed once again to rebuild them. This also happens in several other
situations (like upon login) but the full list is currently unknown.
所有在物品在物品数据库中都有三个特殊的区段(译注：即3并列的个大括号)：脚本，装备时脚本和卸下装备时脚本。
第一个区段脚本的代码将作用于装备或者使用了该物品对应RID的角色。每当卸下物品时，所有临时
附加的属性奖励将会被清空，并且所有的作用脚本将会重新执行一次并重建(刷新)。
这种情况也会在其他情况下发生(譬如上线)，但是完整的条目目前还未知。

OnEquip_Script is a piece of script code run whenever the item is used by a character
by double-clicking on it. OnUnequip_Script runs whenever the
equipment is unequip by a character
装备时脚本将在物品被角色装备，双击物品的时候执行。卸下装备时脚本将在物品被角色解除的时候执行。

Not all script commands work properly in the item scripts. Where commands and
functions are known to be meant specifically for use in item scripts, they are
described as such.
并不是所有的脚本命令都可以在物品脚本里执行。
如果要把专门用于物品的已知命令和函数写进物品脚本中，书写格式就是以上这样。

Every pet in the pet database has a PetScript field, which determines pet
behavior. It is invoked wherever a pet of the specified type is spawned.
(hatched from an egg, or loaded from the char server when a character who had
that pet following them connects) This may occur in some other situations as
well. Don't expect anything other than commands definitely marked as usable in
pet scripts to work in there reliably.
所有宠物在宠物数据库中有一个宠物脚本的区段，用于决定宠物的属性。
在宠物被召唤出来的时候会被调用。(从蛋里孵化，或者携带宠物的角色上线)
这也会在其他情况下出现。除了在宠物脚本中明确规定可用的命令之外，
其他命令都无法在其中使用。

Numbers
数字
-------

Beside the common decimal numbers, which are nothing special whatsoever (though
do not expect to use fractions, since ALL numbers are integer in this language),
the script engine also handles hexadecimal numbers, which are otherwise
identical. Writing a number like '0x<hex digits>' will make it recognized as a
hexadecimal value. Notice that 0x10 is equal to 16. Also notice that if you try
to 'mes 0x10' it will print '16'.
除了普通的十进制数（本脚本语言都使用整数，分数不能用）之外，脚本引擎还处理十六进制数，
而十六进制数在其他方面是相同的。编写数字时使用'0x<16进制数字>'将被辨识为16进制数值。
注意0x10表示10进制的16.另外要注意，如果你用'mes 0x10'命令显示文本将会显示16

Number values can't exceed the limits of an integer variable: Any number
greater than INT_MAX (2147483647) or smaller than INT_MIN (-2147483648) will
be capped to those values and will cause a warning to be reported.
数值不能超过整数变量的限制：任何数值如果大于整数的最大值(2147483647)或者小于
整数的最小值(-2147483648)将会被封顶并且报告警告的信息。

Variables
变量
---------

The meat of every programming language is variables - places where you store
data.
每种编程语言的核心都是变量——存储数据的地方。

In the rAthena scripting language, variable names are not case sensitive.
在rAthena脚本语言中，变量名不区分大小写。

Variables are divided into and uniquely identified by the combination of:
prefix  - determines the scope and extent (or lifetime) of the variable
name    - an identifier consisting of '_' and alphanumeric characters
postfix - determines the type of the variable: integer or string
变量被划分为多个类型，并通过以下组合进行唯一性标识：
前缀    - 确定变量的范围和时限（或存在期限）
名称    - 由‘_’和字母数字字符组成的标识符
后缀    - 决定变量的类型：数值或者字符串

Scope can be:
global    - global to all servers
local     - local to the server
account   - attached to the account of the character identified by RID
character - attached to the character identified by RID
npc       - attached to the NPC
scope     - attached to the scope of the instance
范围可以是：
全局      - 所有服务器全体
局部      - 服务器局部
账号      - 关联通过RID识别的角色的帐号上
角色      - 关联通过RID识别的角色
npc       - 关联 NPC
范围      - 关联副本的范围内

Extent can be:
permanent - They still exist when the server resets.
temporary - They cease to exist when the server resets.
时限可以是：
永久      - 即使服务器重启也会一直存在
临时      - 服务器重启将消除

Prefix: scope and extent
前缀：范围和时限
nothing  - A permanent variable attached to the character, the default variable
           type. They are stored by char-server in the `char_reg_num` and
           `char_reg_str`.
无前缀   - 一个关联角色的永久变量，默认的变量类型。这些变量将被角色服务器存取和使用，存储在数据库的`char_reg_num`和`char_reg_str`里。
"@"      - A temporary variable attached to the character.
           SVN versions before 2094 revision and RC5 version will also treat
           'l' as a temporary variable prefix, so beware of having variable
           names starting with 'l' if you want full backward compatibility.
"@"      - 一个关联角色的临时变量。2094修订版和RC5版本之前的SVN版本也会将“l”视为临时变量前缀，
           因此，如果希望完全向后兼容，请注意不要让变量名以“l”开头。
"$"      - A global permanent variable.
           They are stored by map-server in database table `mapreg`.
"$"      - 一个全局永久变量。
           这些变量将由地图服务器存取和使用，储存在数据库的的`mapreg`里。
"$@"     - A global temporary variable.
           This is important for scripts which are called with no RID
           attached, that is, not triggered by a specific character object.
"$@"     - 一个全局临时变量
           这是一个用来启动无关联RID触发脚本的变量，即是说，不需要一个具体的
		   角色对象来触发。
"."      - A NPC variable.
           They exist in the NPC and disappear when the server restarts or the
           NPC is reloaded. Can be accessed from inside the NPC or by calling
           'getvariableofnpc'. Function objects can also have .variables which
           are accessible from inside the function, however 'getvariableofnpc'
           does NOT work on function objects.
"."      - 一个NPC变量。
           这些变量将会存在于NPC里并于服务器重启或者NPC重载的时候消失。
		   可以在NPC内部引用或者通过'getvariableofnpc'命令调用。函数也可以用
		   .变量名 在函数内部引用，但是'getvariableofnpc'命令无法在函数中使用。
".@"     - A scope variable.
           They are unique to the instance and scope. Each instance has its
           own scope that ends when the script ends. Calling a function with
           callsub/callfunc starts a new scope, returning from the function
           ends it. When a scope ends, its variables are converted to values
           ('return .@var;' returns a value, not a reference).
".@"     - 一个范围变量。
           这些变量在实例和范围里是唯一的。所有实例都有自身的范围并在脚本结束时终止。
		   使用callsub/callfunc命令调用一个函数将会建立一个新的范围，并在函数结束时
		   返回。当一个范围结束，它的所有变量将会转换成数值('return .@var;'都会返回一个值，而非参考)
"'"      - An instance variable.
           These are used with the instancing system and are unique to each
           instance type. Can be accessed from inside the instance or by calling
           'getvariableofinstance'.
"'"      - 一个副本变量
		   这些变量用于副本系统并一一对应每个不同的副本。可以在副本内部引用或者用
		   'getvariableofinstance'命令调用。
"#"      - A permanent local account variable.
           They are stored by char-server in the `acc_reg_num` table and
           `acc_reg_str`.
"#"      - 一个永久本地帐户变量
           这些变量由角色服务器存取和使用，存储在数据库的`acc_reg_num`和`acc_reg_str`里。
"##"     - A permanent global account variable stored by the login server.
           They are stored in the `global_acc_reg_num` table and
		   `global_acc_reg_str`.
           The only difference you will note from normal # variables is when
           you have multiple char-servers connected to the same login server.
           The # variables are unique to each char-server, while the ## variables
           are shared by all these char-servers.
"##"     - 一个永久全局账户变量，由登陆服务器存取使用，储存在数据库的`global_acc_reg_num`和`global_acc_reg_str`里。
           和普通的#变量不同的是，当你使用了多个角色服务器对应相同的登陆服务器时，#变量一一对应每个角色服务器，
           而##变量则是所有角色服务器共享的。   
   
Postfix: integer or string
后缀：数值或者字符串
nothing - integer variable, can store positive and negative numbers, but only
          whole numbers (so don't expect to do any fractional math)
无后缀  - 整数变量，可以表示正数和负数，
          但是只有整数（所以不要期望做任何分数计算）
'$'     - string variable, can store text
'$'     - 字符串变量, 可以表示文本

Examples:
举例：
  name  - permanent character integer variable  //永久角色整数变量
  name$ - permanent character string variable   //永久角色字符串变量
 @name  - temporary character integer variable  //临时角色整数变量
 @name$ - temporary character string variable   //临时角色字符串变量
 $name  - permanent global integer variable     //永久全局整数变量
 $name$ - permanent global string variable      //永久全局字符串变量
$@name  - temporary global integer variable     //临时全局整数变量
$@name$ - temporary global string variable      //临时全局字符串变量
 .name  - NPC integer variable                  //NPC整数变量
 .name$ - NPC string variable                   //NPC字符串变量
.@name  - scope integer variable                //范围整数变量
.@name$ - scope string variable                 //范围字符串变量
 'name  - instance integer variable             //副本整数变量
 'name$ - instance string variable              //副本字符串变量
 #name  - permanent local account integer variable     //永久本地账号数值变量
 #name$ - permanent local account string variable      //永久本地账号字符串变量
##name  - permanent global account integer variable    //永久全局账号数值变量
##name$ - permanent global account string variable     //永久全局账号字符串变量

If a variable was never set, it is considered to equal zero for integer
variables or an empty string ("", nothing between the quotes) for string
variables. Once you set it to that, the variable is as good as forgotten
forever, and no trace remains of it even if it was stored with character or
account data.
如果一个变量没有设置，将默认该变量等于整数0或者空字符串("", 引号中间是空的)。
一旦你设定了新值，该变量的值将被替换成新设定的值，而旧值无论是否与角色或帐户数据一起存取，
都会永远消失。

Some variables are special, that is, they are already defined for you by the
scripting engine. You can see the full list in 'src/map/script_constants.hpp', which
is a file you should read, since it also allows you to replace lots of numbered
arguments for many commands with easier to read text. The special variables most
commonly used are all permanent character-based variables:
一些变量比较特殊，就是，这些变量已经由脚本引擎事先为你定义好了。你可以在源码'src/map/script_constants.hpp'
里看到完整的列表，熟悉这个文件有利于你更好地理解并自己用命令更改这些参数。
这些最常用的特殊变量都是基于角色的永久变量：

Zeny        - Amount of Zeny. //Zeny的数量(就是ROZ，游戏里的基础货币)
Hp          - Current amount of hit points.  //当前Hp
MaxHp       - Maximum amount of hit points.  //最大Hp
Sp          - Current spell points.          //当前Sp
MaxSp       - Maximum amount of spell points.//最大Sp
StatusPoint - Amount of status points remaining.  //剩余素质点数
SkillPoint  - Amount of skill points remaining.   //剩余技能点数
BaseLevel   - Character's base level.     //角色的基础等级
JobLevel    - Character's job level.      //角色的技能等级
BaseExp     - Amount of base experience points.    //基础经验值
JobExp      - Amount of job experience points.     //职业经验值
NextBaseExp - Amount of base experience points needed to reach the next level.   //下次基础等级升级时需要的基础经验值
NextJobExp  - Amount of job experience points needed to reach the next level.    //下次职业等级升级时需要的职业经验值
Weight      - Amount of weight the character currently carries.      //角色当前负重
MaxWeight   - Maximum weight the character can carry.   //角色的最大负重
Sex         - 0 if female, 1 if male.   //性别，0为女，1为男
Class       - Character's job.     //角色的职业
Upper       - 0 if the character is a normal class, 1 if advanced, 2 if baby.    //扩展:0是普通职业，1是转生职业，2是宝宝职业
BaseClass   - The character's 1-1 'normal' job, regardless of Upper value.
              For example, this will return Job_Acolyte for Acolyte, Priest/Monk,
              High Priest/Champion, and Arch Bishop/Sura. If the character has not
              reached a 1-1 class, it will return Job_Novice.
BaseClass   - 角色的1-1'基础'类别，无视职业扩展。
              举例：服侍，牧师/武道家，神官/武术宗师，大主教/修罗 都会返回Job_Acolyte(即服侍，基础类别)。
			  如果角色没有一转，将会返回Job_Novice(即基础类别为初心者)
BaseJob     - The character's 'normal' job, regardless of Upper value.
              For example, this will return Job_Acolyte for Acolyte,
              Baby Acolyte, and High Acolyte.
BaseJob		- 角色的'基础'职业，无视职业扩展。
              举例：服侍，服侍宝宝，转生服侍都会返回Job_Acolyte (即基础职业为服侍) 
Karma       - The character's karma. Karma system is not fully functional, but
              this doesn't mean this doesn't work at all. Not tested.
Karma       - 角色的Karma。Karma系统还未完全支持，但是并不是完全不能用。未测试。
Manner      - The character's manner rating. Becomes negative if the player
              utters words forbidden through the use of 'manner.txt' client-side
              file.
Manner      - 角色禁言标志. 多次使用客户端里 'manner.txt' 文件里禁言的词汇而被禁言。


While these behave as variables, do not always expect to just set them - it is
not certain whether this will work for all of them. Whenever there is a command
or a function to set something, it's usually preferable to use that instead. The
notable exception is Zeny, which you can and often will address directly -
setting it will make the character own this number of Zeny.
If you try to set Zeny to a negative number, the script will be terminated with an error.
虽然这些都是变量，但是不要经常去改动 - 因为不清楚这些是否都能完美支持。
除非需要对角色的相关属性进行设置才用到这些变量。但是Zeny是例外，这项会经常需要改动。
如果你将Zeny设置为负数，脚本将会出错并停止运行。

Some source-end constants can also be accessed in scripts. This list is located in
'src/map/script_constants.hpp', which contains constants such as server defines and status options:
还可以在脚本中访问某些源端常量。此列表位于“src/map/script_constants.hpp”中，包含服务器的一些定义和状态项等常量

	PACKETVER, MAX_LEVEL, MAX_STORAGE, MAX_INVENTORY, MAX_CART, MAX_ZENY, MAX_PARTY,
	MAX_GUILD, MAX_GUILDLEVEL, MAX_GUILD_STORAGE, MAX_BG_MEMBERS, MAX_CHAT_USERS,
	VIP_SCRIPT, MIN_STORAGE
	封包版本，最高等级，最大库存量，最大携带量，手推车最大携带量，最大持有Zeny，队伍最大人数，
	工会最大数，工会最高等级，工会仓库最大存量，战场最大人数，最大聊天用户数，
	会员脚本，最小存量

	Option_Nothing, Option_Sight, Option_Hide, Option_Cloak, Option_Falcon, Option_Riding,
	Option_Invisible, Option_Orcish, Option_Wedding, Option_Chasewalk, Option_Flying,
	Option_Xmas, Option_Transform, Option_Summer, Option_Dragon1, Option_Wug,
	Option_Wugrider, Option_Madogear, Option_Dragon2, Option_Dragon3, Option_Dragon4,
	Option_Dragon5, Option_Hanbok, Option_Oktoberfest, Option_Dragon, Option_Costume
	无状态，Option_Sight,隐匿状态，伪装状态，携带猎鹰状态，骑乘状态，
	隐藏状态，兽人脸状态，结婚状态，Option_Chasewalk,飞行状态，
	圣诞服饰状态, 变身状态, 夏装状态, Option_Dragon1, Option_Wug,
	Option_Wugrider, Option_Madogear, Option_Dragon2, Option_Dragon3, Option_Dragon4,   （此处未翻译完整）
	Option_Dragon5, Option_Hanbok, Option_Oktoberfest, Option_Dragon, 时装状态
	

Assigning variables
变量赋值
--------- ---------

Variables can be accessed and modified much like in other programming languages.
变量可以像在其他编程语言中一样进行访问和修改。

	.@x = 100;            .@x赋值100
	.@x = .@y = 100;      .@x和.@y赋值100

Support for modifying variable values using 'set' is still supported (and required
to exist for this new method to work) so previous scripts will continue to work.
仍然支持使用'set'来修改变量的值，以兼容早期的脚本。

When assigning values, all operator methods are supported which exist in the below
'Operators' section. For instance:
赋值时，支持下面这些进行变量自运算的运算符。例如：

	.@x += 100;         自加
	.@x -= 100;         自减
	.@x *= 2;           自乘
	.@x /= 2;           自除取整
	.@x %= 5;			自除取余
	.@x >>= 2;          自向右移位
	.@x <<= 2;          自向左移位

Will all work. For more information on available operators, see the Operators section
described below. All operators listed there may be placed in-front of the '=' sign
when modifying variables to perform the action as required.
以上都能使用。有关可用操作符的更多信息，请参阅下面描述的操作符部分。
此处列出的所有运算符都可以放在“=”符号前面，根据实际需要修改变量。


Note:
注意：

 !! Currently the scripting engine does not support directly copying array variables.
 !! 目前，脚本引擎不支持直接复制数组变量。
 !! In order to copy arrays between variables the use of 'copyarray' function is still
 !! 为了在变量之间复制数组，仍然需要使用“copyarray”函数。
 !! required.

Strings
字符串
-------

To include symbol '"' in a string you should use prefix '\"'
要在字符串中包含符号'"'，应使用前缀'\"'


Arrays
数组
------

Arrays (in rAthena at least) are essentially a set of variables going under the
same name. You can tell between the specific variables of an array with an
'array index', a number of a variable in that array:
数组(至少在rAthena里)的命名方式基本上和变量一样。在这里用一个称为'数组索引'
的，在该数组里代表变量的数字，来区分一个数组里的具体变量。

<variable name>[<array index>]
<数组名称>[<数组索引>]

All variable types can be used as arrays.
所有变量类型都同样可以应用于数组

Variables stored in this way, inside an array, are also called 'array elements'.
Arrays are specifically useful for storing a set of similar data (like several
item IDs for example) and then looping through it. You can address any array
variable as if it was a normal variable:
在一个数组里，每一个单独的变量被称为'数组元素'。数组的主要用途是用来存储一组相似的数据
(譬如像一些物品的ID)并可以一直调用。你可以定位任何数组的变量并将其当成一般的变量使用：


	set .@arrayofnumbers[0],1;

You can also do things like using a variable (or an expression, or even a
value from another array) to get at an array value:
你还可以通过变量(传递过来的，甚至来自另一个数组)来获取数组里的值：

	set .@x,100;
	set .@arrayofnumbers[.@x],10;

This will make .@arrayofnumbers[100] equal to 10.
以上的语句将会将.@arrayofnumbers[100]赋值10。

Index numbering always starts with 0 and arrays can hold over 2 billion
variables. As such, the (guaranteed) allowed values for indices are in the
range 0 ~ 2147483647.
索引数字从0开始，数组可以存放超过21亿多的变量。如此，允许的取值范围在0 ~ 2147483647。

And array indexes probably can't be negative. Nobody tested what happens when
you try to get a negatively numbered variable from an array, but it's not going
to be pretty.
另外数组的索引应该不能为负数。没人测试过用负数标记一个数组里的变量会发生什么，因为看起来很别扭。

Arrays can naturally store strings:
数组也可以用来存放字符串

.@menulines$[0] is the 0th element of the .@menulines$ array of strings. Notice
the '$', normally denoting a string variable, before the square brackets that
denotes an array index.
.@menulines$[0] 代表一个从0号元素开始的.@menulines$字符串数组。注意要加上'$'号
以表示这是一个字符串变量，在方括号里面的数字表示数组索引。

Variable References
变量引用
-------------------

//##TODO
//##待定



Operators
操作符
---------

Operators are things you can do to variables and numbers. They are either the
common mathematical operations or conditional operators
操作符用来对变量和数字进行运算操作。它们要么是常见的数学运算，要么是条件运算符。

+ - will add two numbers. If you try to add two strings, the result will be a
    string glued together at the +. You can add a number to a string, and the
    result will be a string. No other math operators work with strings.
+ - 将两个数字相加. 如果是两个字符串相加, 结果将是把+号两边的字符串连接起来。
    也可以将数字和字符串相加，结果是一个字符串。除此之外没有其他数学运算符
	可以用来处理字符串。
- - will subtract two numbers.
- - 将两个数字相减.
* - will multiply two numbers.
* - 将两个数字相乘
/ - will divide two numbers. Note that this is an integer division, i.e.
    7/2 is not equal 3.5, it's equal 3.
/ - 将两个数字相除.注意这是一个结果为整数的除法, 例如：
    7/2并不等于3.5，而是等于3
% - will give you the remainder of the division. 7%2 is equal to 1.
% - 将取相除的两个数的余数. 7%2 结果是1。

There are also conditional operators. This has to do with the conditional
command 'if' and they are meant to return either 1 if the condition is satisfied
and 0 if it isn't. (That's what they call 'boolean' variables. 0 means 'False'.
Anything except the zero is 'True' Odd as it is, -1 and -5 and anything below
zero will also be True.)
另外还有条件运算符。它与条件分歧命令“if”相关，如果条件满足，则返回1；如果条件不满足，则返回0。
(这是为什么它们被称为'布尔逻辑值'。0表示'伪'，除了0以外的都表示'真'。虽然很奇怪，但是-1和-5等
其他任何小于0的数字也表示真)

You can compare numbers to each other and you compare strings to each other, but
you can not compare numbers to strings.
你可以对比两个数值或者两个字符串，但是不能对比数值和字符串。

 == - Is true if both sides are equal. For strings, it means they are the same.
 == - 如果符号两边相等则返回真. 如果两边是字符串，则表示两边相同.
 >=  - True if the first value is equal to, or greater than, the second value.
 >=  - 如果第一个数值大于或等于第二个数值，则返回真。
 <=  - True if the first value is equal to, or less than, the second value
 <=  - 如果第一个数值小于或等于第二个数值，则返回真。
 >   - True if the first value greater than the second value
 >   - 如果第一个数值大于第二个数值，则返回真。
 <   - True if the first value is less than the second value
 <   - 如果第一个数值小于第二个数值，则返回真。
 !=  - True if the first value IS NOT equal to the second one
 !=  - 如果第一个数值不等于第二个数值，则返回真。

Examples:
例子：

 1 == 1 is True.
 1 == 1 结果为真.
 1<2 is True while 1>2 is False.
 1<2 结果为真而 1>2 结果为假.
 .@x>2 is True if .@x is equal to 3. But it isn't true if .@x is 2.
 当 .@x 等于3的时候.@x>2 结果为真，但如果.@x 为 2 时则结果不为真.

Only ' == ' and '!=' have been tested for comparing strings. Since there's no way
to code a seriously complex data structure in this language, trying to sort
strings by alphabet would be pointless anyway.
只有' == '和'!='符号可以用来比较字符串。因为无法用这种语言编写一个非常复杂的数据结构，
所以尝试按字母表对字符串进行排序将毫无意义。

Comparisons can be stacked in the same condition:
可以在相同条件下叠加比较：

 && - Is True if and only if BOTH sides are true.
      ('1 == 1 && 2 == 2' is true. '2 == 1 && 1 == 1' is false.)
 && - 只有在符号两边的表达式都为真，才返回真.
      ('1 == 1 && 2 == 2' 为真. '2 == 1 && 1 == 1' 为假.)
 || - Is True if either side of this expression is True.
 || - 只要符号两边的表达式有任意一个为真，就返回真。

 1 == 1 && 2 == 2 is True.
  1 == 1 && 2 == 2 为真.
 1 == 1 && 2 == 1 is False.
  1 == 1 && 2 == 1 为假.
 1 == 1 || 2 == 1 is True.
  1 == 1 || 2 == 1 为真.

Logical bitwise operators work only on numbers, and they are the following:
逻辑位运算符仅对数字起作用，它们如下所示：

 << - Left shift.
 << - 向左移位.
 >> - Right shift.
 >> - 向右移位.
	Left shift moves the binary 1(s) of a number n positions to the left,
	which is the same as multiplying by 2, n times.
	左移位将第n个位置中的二进制1向左移动，这与乘以2的n次相同。
	In the other hand, Right shift moves the binary 1(s) of a number n positions
	to the right, which is the same as dividing by 2, n times.
	另一方面，右移位将第n个位置的二进制1向右移动，这与除以2的n次相同。
		Example:
		例子：                                                       译注：即是将数值转换为二进制，然后将二进制中各个位的1向左位或者向右位移动
		set b,2;
		set a, b << 3;
		mes a;
		set a, a >> 2;
		mes a;
	The first mes command would display 16, which is the same as 2 x (2 x 2 x 2) = 16.
	The second mes command would display 4, which is the same as 16 / 2 = 8. 8 / 2 = 4.
	第一个mes命令将显示16，等同于2 x (2 x 2 x 2) = 16
	第二个mes命令将显示4，等同于16 / 2 = 8， 8 / 2 = 4
 &  - And.   //按位与
 |  - Or.    //按位或  
	The bitwise operator AND (&) is used to test two values against each other,
	and results in setting bits which are active in both arguments. This can
	be used for a few things, but in rAthena this operator is usually used to
	create bit-masks in scripts.
	位运算符按位与(&)是用来按位比较两个值，比较的两个参数和结果都是按二进制，如果两个相同位置都为1，则结果为1，其余情况都为0。
	该运算的用处不多，在rAthena里一般是用于在脚本里创建掩码。

	The bitwise operator OR (|)sets to 1 a binary position if the binary position
	of one of the numbers is 1. This way a variable can hold several values we can check,
	known as bit-mask. A variable currently can hold up to 32 bit-masks (from position 0
	to position 1). This is a cheap(skate) and easy way to avoid using arrays to store several checks
	that a player can have.
	位运算按位或(|)，如果两边数值的相同二进制位里有一个为1，则该位就会设置为1.
	这样的话，一个变量可以保存多个我们可以检测的值，称为掩码。
	一个变量当前最多可容纳32位掩码（从位置0到位置1）。这是一个简约的方法，
	可以避免用许多组数来存储一些角色的属性。

	A bit-mask basically is (ab)using the variables bits to set various options in
	one variable. With the current limit if variables it is possible to store 32
	different options in one variable (by using the bits on position 0 to 31).
    掩码实质上是用单个变量的二进制各个位数上的不同来表示多种不同的属性。
	按照目前变量的限制，可以在单个变量里存储32个不同的属性(基于0至31个不同的数位)。
	
	Example(s):
	例子：
	- Basic example of the & operator, bit example:
	- &运算符的基本,二进制示例:
		10 & 2 = 2
	Why? :
	为啥? :
		10 = 2^1 + 2^3 (2 + 8), so in bits, it would be 1010        //10在二进制里等于2^1 + 2^3 (2 + 8)即1010
		2 = 2^1 (2), so in bits (same size) it would be 0010        //2在二进制里等于2^1 (2)即0010
		The & (AND) operator sets bits which are active (1) in both arguments, so in the
		example 1010 & 0010, only the 2^1 bit is active (1) in both. Resulting in the bit
		0010, which is 2. 
		按位与&运算将每个相同数位上的值进行比较，只有两个位的值都为1时，该位的值才为1.
		因此1010和0010运算的结果是0010，即等于十进制的2。
	- Basic example of creating and using a bit-mask:
	- 创建并运用掩码的基本例子:
		set .@options,2|4|16; //(note: this is the same as 2+4+16, or 22)      //(注意：这和2+4+16相同，或者22)
		if (.@options & 1)	mes "Option 1 is activated";                       //属性1处于开启状态
		if (.@options & 2)	mes "Option 2 is activated";					   //属性2处于开启状态
		if (.@options & 4)	mes "Option 3 is activated";					   //属性3处于开启状态
		if (.@options & 8)	mes "Option 4 is activated";					   //属性4处于开启状态
		if (.@options & 16)	mes "Options 5 is activated";					   //属性5处于开启状态
	This would return the messages about option 2, 3 and 5 being shown (since we've set
	the 2,4 and 16 bit to 1).
	这将返回对应二进制位置顺序2，3，5的属性信息(当前已将第2，4，16位的值设为1)
 ^  - Xor.     //按位异或
	The bitwise operator XOR (eXclusive OR) sets a binary position to 0 if both
	numbers have the same value in the said position. On the other hand, it
	sets to 1 if they have different values in the said binary position.
	This is another way of setting and unsetting bits in bit-masks.
	位运算符按位异或，对等长二进制模式按位或二进制数的每一位执行逻辑按位异或操作. 
	操作的结果是如果某位不同则该位为1, 否则该位为0.
	这是另一种对位掩码进行操作的方法。
	

	Example:
	例子：
	- First let's set the quests that are currently in progress:
	- 首先，让我们设置当前正在进行的任务：
		set inProgress,1|8|16; // quest 1,8 and 16 are in progress   //任务1，8和16正在进行
	- After playing for a bit, the player starts another quest:
	- 玩了一会儿后，玩家开始另一个任务：
		if (inProgress&2 == 0) {
			// this will set the bit for quest 2 (inProgress has that bit set to 0)
			// 这将设置任务2的位 (将inProgress对应的位设置0)
			set inProgress,inProgress^2;
			mes "Quest 2: find a newbie and be helpful to him for an hour.";         //mes "任务2：找到一个初心者并帮助他一个小时.";
			close;
		}
	- After spending some time reading info on Xor's, the player finally completes quest 1:
	- 在花了一些时间阅读关于按位异或的信息后，玩家完成了任务1:
		if (inProgress&1 && isComplete) {
			// this will unset the bit for quest 1 (inProgress has that bit set to 1)
			// 这将逆设置任务1的位(将inProgress对应的位设置1)
			set inProgress,inProgress^1;
			mes "Quest 1 complete!! You unlocked the secrets of the Xor dynasty, use them wisely.";      //mes "任务1：你理会了按位异或的精髓，灵活运用它吧.";
			close;
		}

Unary operators with only with a single number, which follows the operator, and
are following:
只有一个数字的一元运算符，该运算符跟在运算符后面，如下所示：

 -  - Negation.
 -  -一元减。
	The sign of the number will be reversed. If the number was positive, it will
	become negative and vice versa.
	数字的符号将颠倒。如果该数字为正，它将变为负，反之亦然。
	Example:
	例子：
		set .@myvar,10;
		mes "Negative 10 is " + (-.@myvar);

 !  - Logical Not.
 !  - 逻辑取反.
	Reverses the boolean result of an expression. True will become false and
	false will become true.
	将逻辑表达式的布尔结果取反。真将变为假而假将变为真。

	Example:
	例子：
		if (!callfunc("F_dosomething"))         //if (!callfunc("诺有所思"))
		{
			mes "Doing something failed.";      //mes "思考失败."
			close;
		}

 ~  - Bitwise Not.
 ~  - 按位取反.
	Reverses each bit in a number, also known as one's complement. Cleared bits
	are set, and set bits are cleared.
	将数字每个二进制位的值取反，也称为补码。如果该位有设置，则清除，如果没设置，则设置。

	Example:
	例子：
	- Ensure, that quest 2 is disabled, while keeping all other active, if they are.
	- 确保任务2被禁用，同时保持所有其他激活（如果有）。
		set inProgress,inProgress&(~2);  // same as set inProgress,inProgress&0xfffffffd    //等同于set inProgress,inProgress&0xfffffffd

Ternary operators take three expressions (numbers, strings or boolean), and are
following:
三元运算符采用三个表达式（数字、字符串或布尔值），如下所示：

 ?: - Conditional operator
 ?: - 条件运算符
	Very useful e.g. to replace
	非常实用，例子：

		if (Sex) mes "..."; else mes "...";

	clauses with simple
	以上可以用下面的表达式取代：

		mes "Welcome, " + (Sex?"Mr.":"Mrs.") + " " + strcharinfo(0);

	or to replace any other simple if-else clauses. It might be worth
	mentioning that ?: has low priority and has to be enclosed with
	parenthesis in most (if not all) cases.
	可以用来替代if-else的条件表达式。
	值得一提的是?:表达式的优先级较低，在大多数（如果不是单独使用的话）情况下必须用括号括起来。

Labels
标签
------

Within executable script code, some lines can be labels:
在可执行的脚本代码中，某些行可以是标签：

<label name>:
<标签名称>:

Labels are points of reference in your script, which can be used to route
execution with 'goto', 'menu' and 'jump_zero' commands, invoked with 'doevent'
and 'donpcevent' commands and are otherwise essential. A label's name may not be
longer than 22 characters. (23rd is the ':'.) There is some confusion in the
source about whether it's 22, 23 or 24 all over the place, so keeping labels
under 22 characters could be wise. It may only contain alphanumeric characters
and underscore. In addition to labels you name yourself, there are also some
special labels which the script engine will start execution from if a special
event happens:
标签是一个脚本中的位置参考点，可以通过'goto', 'menu' 和 'jump_zero'跳转，或者
通过'doevent'和'donpcevent'指令进行调用，在某些情况下是必须要用到的。每个标签的名称
不能长于22个字节。(第23个是':')为了避免产生混淆，建议小于22个字节。名称只能包含字母
数字字符和下划线。除了你自己命名的标签，还有一些脚本引擎内置的，用于在特殊情况
下触发的事件标签：

OnClock<hour><minute>:               //OnClock<小时><分钟>:
OnMinute<minute>:                    //OnMinute<分钟>:
OnHour<hour>:                        //OnHour<小时>:
On<weekday><hour><minute>:           //On<每周几><小时><分钟>:
OnDay<month><day>:                   //OnDay<月份><日期>:

This will execute when the server clock hits the specified date or time. Hours
and minutes are given in military time. ('0105' will mean 01:05 AM). Weekdays
are Sun,Mon,Tue,Wed,Thu,Fri,Sat. Months are 01 to 12, days are 01 to 31.
Remember the zero.
这将在服务器时钟到达指定日期或时间时执行。小时和分钟以军事时间表示。('0105' 表示 01:05 早晨)
每周几用Sun,Mon,Tue,Wed,Thu,Fri,Sat表示.月份是 01 to 12, 日期是 01 to 31，记得加0.

OnInit:
OnInterIfInit:
OnInterIfInitOnce:

OnInit will execute every time the scripts loading is complete, including when
they are reloaded with @reloadscript command. OnInterIfInit will execute when
the map server connects to a char server, OnInterIfInitOnce will only execute
once and will not execute if the map server reconnects to the char server later.
OnInit将在服务器启动后脚本加载完毕的时候执行，包括使用@reloadscript命令重载脚本的时候。
OnInterIfInit将在地图服务器和角色服务器连接的时候执行，OnInterIfInitOnce只会执行一次，
如果地图服务器断开并重新连接到角色服务器的时候，则也不会执行。

OnAgitStart:
OnAgitEnd:
OnAgitInit:
OnAgitStart2:
OnAgitEnd2:
OnAgitInit2:
OnAgitStart3:
OnAgitEnd3:
OnAgitInit3:

OnAgitStart will run whenever the server shifts into WoE mode, whether it is
done with @agitstart GM command or with 'AgitStart' script command. OnAgitEnd
will do likewise for the end of WoE.
OnAgitStart将会在开启WoE模式(即工会战)的时候运行，无论是用GM命令的@agitstart或者
用'AgitStart'的脚本命令开启。OnAgitEnd同理，会在WoE结束(即工会战结束)的时候运行。

OnAgitInit will run when data for all castles and all guilds that hold a castle
is received by map-server from the char-server after initial connect.
OnAgitInit将会在map服务器连接角色服务器后加载所有工会和城堡数据后运行。

No RID will be attached while any of the above mentioned labels are triggered, so
no character or account-based variables will be accessible, until you attach a
RID with 'attachrid' (see below).
上述标签触发的时候都不会关联任何RID，因此也不会传输与玩家或者账号关联的变量数据，
除非你用'attachrid'指令关联了某一个RID(见下文)。

The above also applies to, the last three labels, the only difference is that
these labels are used exclusively for WoE SE, and are called independently.
上述内容也适用于最后三个标签，唯一的区别是这些标签专门用于WoE SE，并且单独调用。

OnInstanceInit:

This label will be executed when an instance is created and initialized through
the 'instance_create' command. It will run again if @reloadscript is used while
an instance is in progress.
这个标签将在一个副本由'instance_create'命令创建并初始化的时候执行。
如果当一个副本正在运行的时候使用了@reloadscript命令，那改标签也将会再执行一次。

OnInstanceDestroy:

This label will be executed when an instance is destroyed by a timeout, exceeding
the keepalive time or through the 'instance_destroy' command. It will be called
exactly before the instance will be destroyed and all other NPCs of the instance
will still be available at this point of time.
这个标签将在副本因超时，超时限，或者使用'instance_destroy'命令被销毁的时候执行。
它将在副本被销毁之前被调用，并且该副本的所有其他NPC此时仍然可用。

OnTouch:

This label will be executed if a trigger area is defined for the NPC object it's
in. If it isn't present, the execution will start from the beginning of the NPC
code. The RID of the triggering character object will be attached.
如果定义了一个NPC对象有触发范围，那么进入该范围的时候会执行该标签。如果没有设置
这个标签，那么NPC脚本代码将从开始处执行。并将关联进入触发范围的角色对象的RID。

OnTouch_:

Similar to OnTouch, but will only run one instance. Another character is
chosen once the triggering character leaves the area.
类似OnTouch，但是只会执行一次。一旦触发的角色离开触发区域，才关联另一个角色。

OnTouchNPC:

Similar to OnTouch, but will only trigger for monsters. For this case, by using
'getattachedrid' will returns GID (ID that returned when use 'monster').
类似OnTouch，但是只由进入区域的魔物触发。在这种情况下，使用'getattachedrid'命令
将会返回GID(即使用'monster'命令返回的ID)。

OnPCLoginEvent:               //角色上线时调用
OnPCLogoutEvent:              //角色下线时调用
OnPCBaseLvUpEvent:            //角色基础等级上升时调用
OnPCJobLvUpEvent:             //角色职业等级上升时调用

It's pretty obvious when these four special labels will be invoked.
这四个特殊标签的调用方式如其名。

OnPCDieEvent:

This special label triggers when a player dies. The variable 'killerrid' is
set to the ID of the killer.
这个特殊标签将会在角色死亡时调用。变量'killerrid'将被赋值为杀死角色的实行者的ID。

OnPCKillEvent:

This special label triggers when a player kills another player. The variable
'killedrid' is set to the ID of the player killed.
这个特殊标签将会在一个玩家杀死另一个玩家的时候触发。变量'killedrid'将被设置为
被杀的玩家。

OnNPCKillEvent:

This special label triggers when a player kills a monster without label.
The variable 'killedrid' is set to the Class (mob ID) of the monster killed.
The variable 'killedgid' is set to the ID (unique mob game ID) of the monster killed.
这个特殊标签将在一个玩家杀死一个没有附加标签的魔物的时候触发。
变量'killedrid'将会设置为被杀魔物的类别(魔物ID)。
变量'killedgid'将会设置为魔物的ID(魔物游戏里的独有ID)。

OnPCLoadMapEvent:

This special label triggers when a player steps in a map marked with the
'loadevent' mapflag and attaches its RID. The fact that this label requires a
mapflag for it to work is because, otherwise, it'd be server-wide and trigger
every time a player would change maps. Imagine the server load with 1,000 players
(oh the pain...)
这个特殊标签将在一个玩家进入一个用'loadevent'地图标志标记的地图的时候触发并关联RID。
实际上这个标签需要一个地图标记触发是因为，如果不这样的话，整个服务器的玩家如果有人
更换地图就都会触发。想象一下如果地图上有1000个玩家（太痛苦了...）

OnWhisperGlobal:

This special label triggers when a player whispers the NPC, and will run with the
player's RID attached. It can accept up to ten parameters, which will be stored
into separate temporary character string variables @whispervar0$ to @whispervar9$.
See 'doc/whisper_sys.txt' for further documentation.
这个特殊标签将在一个玩家对NPC发出密语的时候触发，并且关联该玩家的RID。
它最多可以接受十个参数，这些参数将存储在单独的临时字符串变量@whispervar0$到@whispervar9$中。
参考'doc/whisper_sys.txt'以获取进一步的信息。

Only the special labels which are not associated with any script command are
listed here. There are other kinds of labels which may be triggered in a similar
manner, but they are described with their associated commands.
这里只列出与任何脚本命令没有关联的特殊标签。还有其他种类的标签可能以类似的方式触发，但它们是用相关的命令描述的。

On<label name>:
On<标签名称>

These special labels are used with Mob scripts mostly, and script commands
that requires you to point/link a command to a mob or another NPC, giving a label
name to start from. The label name can be any of your liking, but must be
started with "On".
这些特殊标签最常用于魔物脚本，在脚本命令中你需要指向/链接到其他NPC或者魔物，因此
需要给出一个标签标明开始位置。标签名称可以任意取。但是必须以"On"开头.

Example:
例子：

monster "prontera",123,42,"Poringz0rd",2341,23,"Master::OnThisMobDeath";    译注："Master::OnThisMobDeath"就是该被
                                                                            召唤的魔物死亡后触发的"NPC名称::事件标签"
amatsu,13,152,4	script	Master	767,{
	mes "Hi there";
	close;

OnThisMobDeath:                                                             译注：魔物被杀后从该NPC的标签"OnThisMobDeath"处开始执行
	announce "Hey, " + strcharinfo(0) + " just killed a Poringz0rd!",bc_blue|bc_all;
	end;
}

Each time you kill one, that announce will appear in blue to everyone.
每次你消灭一个魔物，这个全服广播(announce)命令就会用蓝色字体(bc_blue)向全服玩家(bc_all)广播。

"Global" labels
"全局" 标签

There's a catch with labels and doevent. If you call a label (using doevent)
and called label is in NPC that has trigger area, that label must end with
"Global" to work globally (i.e. if RID is outside of the trigger area, which
usually happens since otherwise there would be no point calling the label with
doevent, because OnTouch would do the job). For further reference look for
npc_event in npc.cpp.
使用标签和触发事件有个问题。如果你调用一个标签（使用doevent命令），该标签所在的
NPC有一个触发的范围，那么这个标签需要以"Global"结尾才能全局执行(例如，如果关联的RID在
触发的范围外，这种情况通常会发生，否则用doevent调用标签就没有意义了，因为OnTouch也能
实现这种功能)。如需进一步参考，请查看npc.cpp中的npc event.

Scripting commands and functions
脚本命令和函数
--------------------------------

The commands and functions are listed here in no particular order. There's a
difference between commands and functions - commands leave no 'return value'
which might be used in a conditional statement, as a command argument, or stored
in a variable. Calling commands as if they were functions will sometimes work,
but is not advised, as this can lead to some hard to track errors. Calling
functions as if they were commands will mess up the stack, so 'return' command
will not return correctly after this happens in a particular script.
此处列出的命令和函数没有特定顺序。命令和函数之间的区别是 - 命令不会留有“返回值”，
这些值可能在条件判定语句中用作命令的参数或存储在变量中。像调用函数一样调用命令有时会有相同效果，
但不建议这样做，因为这会导致一些难以追溯的错误。像调用命令一样调用函数会弄乱堆栈，
因此在特定脚本中发生这种情况后，“return”命令将无法正确返回。

All commands must end with a ';'.
所有命令必须以';'结束。

-------------------------


From here on, we will have the commands sorted as follow:
从这里开始，我们将对命令进行如下排序：

1.- Basic commands.        //基本命令
2.- Information-retrieving commands.      //信息检索命令。
3.- Checking commands.            //检查类命令。
4.- Player-related commands.      //与玩家相关的命令。
5.- Mob / NPC -related commands.  //魔物/NPC相关的命令。
6.- Other commands.               //其他命令。
7.- Instance commands.            //副本命令。
8.- Quest Log commands.           //任务日志命令。
9.- Battleground commands.        //战场命令。
10.- Pet commands.                //宠物命令。
10.1.- The Pet AI commands.       //宠物AI命令。
11.- Homunculus commands.         //生命体命令。
12.- Mercenary commands.          //佣兵命令。
13.- Party commands.              //组队命令
14.- Channel commands.            //频道命令。
15.- Achievement commands.        //成就命令。

=====================
|1.- Basic commands.|              //基本命令
=====================
---------------------------------------

*mes "<string>"{,"<string>"{,...}};
*mes "<字符串>"{,"<字符串>"{,...}};

This command will display a box on the screen for the invoking character, if no
such box is displayed already, and will print the string specified into that
box. There is normally no 'close' or 'next' button on this box, unless you
create one with 'close' or 'next', and while it's open the player can't do much
else, so it's important to create a button later. If the string is empty, it
will show up as an empty line.
这个命令将会在关联的玩家屏幕上显示一个框(如果之前没有创建这样的框的话)，并将指定的字符串打印到该框中。
正常情况下框体上不会出现'关闭'或者'下面'这样的按钮，除非你用'close' 或者
 'next'指令创建出来。如果字符串是空的，将会显示一个空的线。

举例：
	mes "Text that will appear in the box";

Colors
颜色
------
Inside the string you may put color codes, which will alter the color of the
text printed after them. The color codes are all '^<R><G><B>' and contain three
hexadecimal numbers representing colors as if they were HTML colors - ^FF0000 is
bright red, ^00FF00 is bright green, ^0000FF is bright blue, ^000000 is black.
^FF00FF is a pure magenta, but it's also a color that is considered transparent
whenever the client is drawing windows on screen, so printing text in that color
will have kind of a weird effect. Once you've set a text's color to something,
you have to set it back to black unless you want all the rest of the text be in
that color:
显示字符串的时候你可以设置颜色代码，用来改变代码之后显示的文字的颜色。颜色代码
的写法是'^<红><绿><蓝>'，包含3个排列在一起的16进制数字用来表示颜色，类似于HTML
的颜色方法 - ^FF0000是亮红色，^00FF00是亮绿色，^0000FF是亮蓝色，^000000是黑色。
^FF00FF是品红色，但是，当客户端在屏幕上绘制窗口时，它也是一种被认为是透明的颜色，
所以用这种颜色打印文本会有一种奇怪的效果。一旦你设置了文字为某种颜色后，你必须
在后面将它改回黑色，除非你想要整段文字都是显示成这种颜色。

	mes "This is ^FF0000 red ^000000 and this is ^00FF00 green, ^000000 so.";
	mes "这是 ^FF0000 红 ^000000 然后这是 ^00FF00 绿, ^000000 就这样.";

Notice that the text coloring is handled purely by the client. If you use non-
English characters, the color codes might get screwed if they stick to letters
with no intervening space. Separating them with spaces from the letters on
either side solves the problem.
注意文本着色完全由客户端处理。如果使用非英文字符，颜色代码粘贴在没有中间空格的字母上，
可能会出错。用空格将它们与两边的字母分开可以解决这个问题。

Multiple Lines
多行显示
--------------
To display multiple lines of message while only using a single 'mes' command,
use the script command in the following format:
要在仅使用单个“mes”命令的情况下显示多行消息，请使用以下格式的脚本命令：

	mes "Line 1", "Line 2", "Line 3";

This will display 3 different lines while only consuming a single line in
the relevant script file.
这将显示3个不同的行，同时仅使用相关脚本文件中的一行。


Navigation
导航
----------
For clients dated 2011-10-10aRagexe onwards, you can generate navigation links
using HTML-like labels:
2011-10-10aRagexe及以后的客户端，您可以使用类似HTML的标签生成导航链接：

	<NAVI>Display Name<INFO>mapname,x,y,0,000,flag</INFO></NAVI>

The "flag" parameter can be:
“flag”的参数可以是：
 0: Do not open Navigation Window (default).
 0: 不打开导航窗口（默认）。
 1: Open Navigation Window.
 1: 打开导航窗口。

The example below will make the [Tool Shop] text clickable and begin navigation
to alberta (98,154) when clicked.
下面的示例将使[Tool Shop]文本可点击并开始导航，点击的位置在艾尔贝塔(98,154)。

	mes "Have you checked out the <NAVI>[Tool Shop]<INFO>alberta,98,154,0,000,0</INFO></NAVI>?";

See also 'navigateto', which can be used for certain NPC events.

Items
物品
-----
You can refer to items by using HTML-like links to certain items:
您可以通过使用指向特定物品的类似HTML的链接来引用物品：

	<ITEMLINK>Display Name<INFO>Item ID</INFO></ITEMLINK>

Where <Display Name> is the name that will be displayed for your link and
<Item ID> being the ID of the item you want to link to when clicked.
其中，<Display Name>是将为链接显示的名称，<Item ID>是单击时要链接到的物品的ID。

In 2015 the tag name was changed to <ITEM> resulting in the following syntax:
2015年，标记名更改为<ITEM>，产生以下语法：

	<ITEM>Display Name<INFO>Item ID</INFO></ITEM>

The following sample will open a preview window for Red Potion:
以下示例将打开红色药剂的预览窗口：

	mes "Did you ever consume a <ITEMLINK>Red Potion<INFO>501</INFO></ITEMLINK>?";
	// Or in 2015:
	mes "Did you ever consume a <ITEM>Red Potion<INFO>501</INFO></ITEM>?";

NOTE: Be aware that item links are rendered incorrectly in 2015+ clients at the moment.
注意：请注意，目前在2015+客户端中，物品链接显示不正确。

URLs
链接
----
Similarly, you can create links to websites that launch in a new window:
类似地，您可以创建指向在新窗口中启动的网站的链接：

	<URL>Display Name<INFO>http://www.example.com/</INFO></URL>";

Quests
任务
------
You can link to a quest:
您可以链接到任务：

	<QUEST>Quest<INFO>1</INFO></QUEST>

Message
消息
-------
You can show a message from the msgstringtable:
您可以显示来自msgstringtable的消息：

	<MSG>1</MSG>

Tips
提示
----
You can show a tip box:
您可以显示提示框：

	<TIPBOX>Show Tip<INFO>1</INFO></TIPBOX>

---------------------------------------

*next;

This command will display a 'next' button in the message window for the
invoking character. Clicking on it will cause the window to clear and display
a new one. Used to segment NPC-talking, next is often used in combination with
'mes' and 'close'.
这个命令可以在角色开启的信息窗口中显示一个'下面'的按钮。点击将会更新到下一个新的信息窗口。
用来将NPC的对话分段，next命令经常和'mes'和'close'命令一起组合使用。

If no window is currently on screen, one will be created, but once the invoking
character clicks on it, a warning is thrown on the server console and the script
will terminate.
如果当前屏幕上没有窗口，则将创建一个窗口，但一旦开启窗口的角色单击该窗口，
服务器控制台上将出现警告，脚本将终止。

	mes "[Woman]";
	mes "This would appear on the page";
	next;
	// This is needed since it is a new page and the top will now be blank   //next将清空上面显示的信息并显示下面的信息
	mes "[Woman]";
	mes "This would appear on the 2nd page";

---------------------------------------

*clear;

This command will clear the dialog text and continue the script without player interaction.
此命令将清除对话框文本，并在没有玩家操作的情况下继续脚本。

Example:
	mes "This is how the 'clear' script command works.";
	sleep2 3000;
	clear; // This will clear the dialog and continue to the next one.   //这将会清除当前对话并继续开启下一段对话
	mes "I will show you again.";
	sleep2 3000;
	clear;
	mes "Bye!";
	close;

---------------------------------------

*close;

This command will create a 'close' button in the message window for the invoking
character. If no window is currently on screen, the script execution will end. This is one
of the ways to end a speech from an NPC. Once the button is clicked, the NPC
script execution will end, and the message box will disappear.
这个命令将会在角色开启的信息窗口上显示一个'关闭'的按钮。如果当前屏幕上已没有窗口，脚本将会终止。
这是一种结束和NPC对话的方式。当这个按钮被按下，NPC的脚本将终止，并且信息窗口将关闭。

	mes "[Woman]";
	mes "I am finished talking to you. Click the close button.";
	close;
	mes "This command will not run at all, since the script has ended.";

---------------------------------------

*close2;

This command will create a 'close' button in the message window for the invoking
character. WARNING: If no window is currently on screen, the script execution will halt
indefinitely! See 'close'. There is one important difference, though - even though
the message box will have closed, the script execution will not stop, and commands after
'close2' will still run, meaning an 'end' has to be used to stop the script, unless you
make it stop in some other manner.
这个命令将会在角色开启的信息窗口上显示一个'关闭'的按钮。警告：如果屏幕上当前没有窗口，脚本执行将无法停止！
参考'close'。只有1个非常重要的区别，就是当窗口关闭后，脚本并不会立刻终止，'close2'指令后面
的命令还会继续执行，就是说还需要一个'end'命令来结束脚本，除非你还有其他方式结束。

	mes "[Woman]";
	mes "I will warp you now.";
	close2;
	warp "place",50,50;
	end;

Don't expect things to run smoothly if you don't make your scripts 'end'.
记得在'close2'后面的脚本里添加停止脚本的语句，否则脚本不会终止。
--------------------------------------------
*close3;

The command is similar to 'close' but the cutin (if any) is cleared after closing.
该命令类似于 'close'，但在关闭后会清除显示的图像（如果有）。
---------------------------------------
---------------------------------------

*end;

This command will stop the execution for this particular script. The two
versions are perfectly equivalent. It is the normal way to end a script which
does not use 'mes'.
此命令将停止当前脚本的执行。一般用来停止未使用'mes'命令的脚本。

	if (BaseLevel <= 10)
		npctalk "Look at that you are still a n00b";
	else if (BaseLevel <= 20)
		npctalk "Look at that you are getting better, but still a n00b";
	else if (BaseLevel <= 30)
		npctalk "Look at that you are getting there, you are almost 2nd profession now right???";
	else if (BaseLevel <= 40)
		npctalk "Look at that you are almost 2nd profession";
	end;

Without the use of 'end' it would travel through the labels until the end of the
script. If you were lvl 10 or less, you would see all the speech lines, the use
of 'end' stops this, and ends the script.
以上例子中，如果不使用“end”，脚本执行将遍历标签，直到脚本结束。如果你的等级为10级或以下，
你会看到所有的对话语句出现，直到执行至'end'命令处，才停止脚本。

---------------------------------------

*set <variable>,<expression>{,<char_id>};
*set(<variable>,<expression>{,<char id>})
*set <变量>,<表达式>{,<角色编号>};
*set(<变量>,<表达式>{,<角色编号>})

This command will set a variable to the value that the expression results in.
Variables may either be set through this command or directly, much like any
other programming language (refer to the "Assigning variables" section).
此命令将变量设置为表达式产生的值(即变量赋值)。变量可以通过该命令设置，也可以直接设置，
就像任何其他编程语言一样（请参阅“分配变量”一节）。

This is the most basic script command and is used a lot whenever you try to do
anything more advanced than just printing text into a message box.
这是最基本的脚本命令，每当您尝试执行比仅将文本打印到消息框更高级的操作时，都会大量使用它。

	set .@x,100;

will make .@x equal 100.  //将.@x的值设置为100

	set .@x,1+5/8+9;

will compute 1+5/8+9 (which is, surprisingly, 10 - remember, all numbers are
integer in this language) and make .@x equal it.
将计算1+5/8+9（结果是 10,要记住，在这种语言中，所有数字都是整数）因此5/8结果是0。
于是.@x等于1 + 0 + 9 = 10。

Returns the variable reference (since trunk r12870).
计算结果的返回值将被赋值给变量。

---------------------------------------

*setd "<variable name>",<value>{,<char_id>};
*setd "<变量名称>",<数值>{,<角色编号>};

Works almost identically as set, except the variable name is identified as a string
and can thus be constructed dynamically.
其工作原理与“set”几乎相同，只是变量名被标识为字符串，因此可以动态改变。

This command is equivalent to:
此命令相当于：
	set getd("variable name"),<value>;
	set getd("变量名称"),<数值>;

Examples:
例子：

	setd ".@var$", "Poporing";
	mes .@var$; // Displays "Poporing".

	setd ".@" + .@var$ + "123$", "Poporing is cool";
	mes .@Poporing123$; // Displays "Poporing is cool".

NOTE:
注意：
	'char_id' only works for non-server variables.
	'角色编号'仅适用于非服务器变量。
	Player with Character ID 'char_id' must be online.
	角色编号为'角色编号'的玩家必须在线。

---------------------------------------

*getd("<variable name>")
*getd("<变量名称>")

Returns a reference to a variable, the name can be constructed dynamically.
Refer to 'setd' for usage.
返回一个变量的引用，可以动态改变变量的名称。
有关用法，请参阅'setd'。

This can also be used to set an array dynamically:
这也可用于动态设置数组：
	setarray getd(".array[0]"), 1, 2, 3, 4, 5;

Examples:
例子：

	set getd("$varRefence"), 1;
	set .@i, getd("$" + "pikachu");

---------------------------------------

*getvariableofnpc(<variable>,"<npc name>")
*getvariableofnpc(<变量>,"<npc名称>")

Returns a reference to a NPC variable (. prefix) from the target NPC.
This can only be used to get . variables.
从指定NPC获取该NPC中变量的值。且只能用于获取. 变量。

Examples:
例子：

//This will return the value of .var, note that this can't be used, since the value isn't caught.
//这将会获取.var的值，注意，如果该值未被赋值，则无法使用。
	getvariableofnpc(.var,"TargetNPC");

//This will set the .v variable to the value of the TargetNPC's .var variable.
//这将会给.v变量赋予TargetNPC的.var变量中的值。
	set .v, getvariableofnpc(.var,"TargetNPC");

//This will set the .var variable of TargetNPC to 1.
//这将会给TargetNPC中的.var变量赋值1。
	set getvariableofnpc(.var,"TargetNPC"), 1;

Note: even though function objects can have .variables,
getvariableofnpc will not work on them.
注意：尽管函数对象也可以有.变量，但是getvariableofnpc无法在函数对象中使用。

---------------------------------------

*getvar <variable>,<char_id>;
*getvar <变量>,<角色编号>;

Get variable value from the specified player. Only player/account variables
are allowed to be used (temporary character variable "@", permanent
character "", permanent local account "#", and permanent global account "##").
获取指定角色的变量值。只有角色/账号的比那里可以被获取和使用。(临时角色变量"@"，
永久角色变量""，永久本地账号变量"#"，和永久全局账号变量"##")。

---------------------------------------

*goto <label>;
*goto <标签>;

This command will make the script jump to a label, usually used in conjunction
with other command, such as "if", but often used on its own.
这个命令将会让脚本跳转到指定标签处执行，经常结合其他命令使用，如"if"，
但是也经常会单独使用。

	...
	goto Label;

	mes "This will not be seen";
	end;
Label:
	mes "This will be seen";
	end;

This command should be avoided and only used if there is no other option.
建议这个命令仅在无其他方式可以替代的时候才使用。
---------------------------------------

*menu "<option_text>",<target_label>{,"<option_text>",<target_label>,...};
*menu "<文字选项>",<目标标签>{,"<文字选项>",<目标标签>,...};

This command will create a selectable menu for the invoking character. Only one
menu can be on screen at the same time.
这个命令将会为对应角色创建一个选项菜单。同一时间屏幕里只会显示一个菜单。

Depending on what the player picks from the menu, the script execution will
continue from the corresponding label. (it's string-label pairs, not label-
string)
根据玩家对菜单里不同选项的选择，脚本将按预设的选项跳转到不同的目标标签执行。
(注意是字符串对应后面的标签而不是标签对应前面的字符串。)

Options can be grouped together, separated by the character ':'.
选项可以多个组合，用':'分开。
例子：


	menu "A:B",L_Wrong,"C",L_Right;

It also sets a special temporary character variable @menu, which contains the
number of option the player picked. (Numbering of options starts at 1.)
This number is consistent with empty options and grouped options.
使用该指令也会建立一个特殊的临时角色变量@menu，用来保存角色所选项的序号。
(选项的序号从1开始。)此序号与空选项和组合选项各选项出现的先后顺序一致。

	menu "A::B",L_Wrong,"",L_Impossible,"C",L_Right;

	L_Wrong:
		// If they click "A" or "B" they will end up here            //如果选择了A或B，将会从这里开始执行
		// @menu == 1 if "A"            //如果选择了A，@menu值等于1
		// @menu == 2 will never happen because the option is empty  //因为选项是空的，因此@menu不会被赋值2
		// @menu == 3 if "B"                                         //如果选择了B，@menu值等于3
	L_Impossible:
		// Empty options are not displayed and therefore can't be selected   //因为该选项是空的，因此选项不会被选择，@menu也不会被赋值
		// this label will never be reached from the menu command            //该标签不会被跳转到
	L_Right:
		// If they click "C" they will end up here                           //如果选择了C，则跳转到这里执行，@menu值等于5
		// @menu == 5

If a label is '-', the script execution will continue right after the menu
command if that option is selected, this can be used to save you time, and
optimize big scripts.
如果标签是'-'，那么脚本将在选择了该项后往menu语句下面继续执行，可以节省时间并优化脚本。
	menu "A::B:",-,"C",L_Right;
		// If they click "A" or "B" they will end up here  //如果选择了"A"或"B"，将会从这里开始执行
		// @menu == 1 if "A"                               //如果选择"A"则@menu值等于1
		// @menu == 3 if "B"                               //如果选择"B"则@menu值等于3
	L_Right:                    
		// If they click "C" they will end up here         //如果选择了"C"，将会从这里开始执行
		// @menu == 5                                      //@menu值等于5

Both these examples will perform the exact same task.
这两个例子将执行完全相同的步骤。

If you give an empty string as a menu item, the item will not display. This
can effectively be used to script dynamic menus by using empty string for
entries that should be unavailable at that time.
如果你在菜单选项里放置了一个空的字符串，那么该字符串将不会显示。
通过为当时不可用的选择项使用空字符串，可以有效地为动态菜单编写脚本。
(译注:通常用于针对不同玩家给出不同选项，不符合条件的玩家不显示的选项可设置为空，
方便统一设置选项分歧。常见于副本创建的时候区分队长和队员。)

You can do it by using arrays, but watch carefully - this trick isn't high
wizardry, but minor magic at least. You can't expect to easily duplicate it
until you understand how it works.
你也可以通过数组来设置，但是要看仔细 - 这并不高端，但是至少是小技巧。
不要想能轻易模仿这种方法，在你能充分理解它的工作原理之前。

Create a temporary array of strings to contain your menu items, and populate it
with the strings that should go into the menu at this execution, making sure not
to leave any gaps. Normally, you do it with a loop and an extra counter, like
this:
创建一个临时字符串数组用来存放你的菜单选项，并用执行时需要放入菜单的字符串填充它，
确保不留下任何间隙。通常，应使用一个循环和一个额外的计数器来执行此操作，如下所示：
(译注：下面这个例子的具体应用可以参考旧的非UI精炼房脚本。)

	setarray .@possiblemenuitems$[0],<list of potential menu items>;   //<预设的菜单项列表>
	.@j = 0; // That's the menu lines counter.    //这是菜单行数

	// We loop through the list of possible menu items.   //循环取出需要的菜单项目
	// .@i is our loop counter.    //.@i是循环的次数
	for( .@i = 0; .@i < getarraysize(.@possiblemenuitems$); .@i++ )
	{
		// That 'condition' is whatever condition that determines whether   //下面的'condition'(条件)是用来判断菜单序号.@i的项目
		// a menu item number .@i actually goes into the menu or not.       //是否确实被写入了菜单里。

		if (<condition>)
		{
			// We record the option into the list of options actually available.
			// 下面语句是将菜单项放进实际应用的菜单列表里面

			.@menulist$[@j] = .@possiblemenuitems$[@i];

			// We just copied the string, we do need its number for later  //上面只是复制了字符串，后面还需要
			// though, so we record it as well.                            //相应的序号，所以下面的语句用来记录它。

			.@menureference[@j] = .@i;

			// Since we've just added a menu item into the list, we increment   //这样就往列表中加入了菜单项目，
			// the menu lines counter.                                          //然后让菜单行计数器加1

			.@j++;
		}

		// We go on to the next possible menu item.      //然后继续增加下一个需要的菜单项
	}

This will create you an array .@menulist$ which contains the text of all items
that should actually go into the menu based on your condition, and an array
.@menureference, which contains their numbers in the list of possible menu items.
(Remember, arrays start with 0.) There's less of them than the possible menu
items you've defined, but the menu command can handle the empty lines - only if
they are last in the list, and if it's made this way, they are. Now comes a
dirty trick:
这将创建一个数组@menulist$，其中包含根据您的条件实际进入菜单的所有项目的文本，
另外还有一个数组.@menureference，包含了这些项目在菜单项目组中的序号。
(记住, 数组的序号从0开始.)它们的数量少于您定义的可能菜单项，但是menu命令
可以处理空行-只有当它们是列表中的最后一个才处理。

	// X is whatever the most menu items you expect to handle.   //X是您希望处理的最多菜单项。
	menu .@menulist$[0],-,.@menulist$[1],-,...,.@menulist$[<X>],-;

This calls up a menu of all your items. Since you didn't copy some of the
possible menu items into the list, its end is empty and so no menu items will
show up past the end. But this menu call doesn't jump anywhere, it just
continues execution right after the menu command. (And it's a good thing it
doesn't, cause you can only explicitly define labels to jump to, and how do you
know which ones to define if you don't know beforehand which options will end up
where in your menu?)
But how do you figure out which option the user picked? Enter the @menu.
这将调出所有项目的菜单。由于您没有将一些可能的菜单项复制到列表中，因此列表的结尾是空的，
因此没有菜单项显示在列表的结尾。但是这个菜单调用不会跳到任何地方，它只是在菜单命令之后继续执行。
(这是一件好事，因为您只能显式地定义要跳转到的标签，如果您事先不知道哪些选项会出现在菜单中，您如何知道要定义哪些标签？)
但是你如何知道用户选择了哪一个选项呢？通过输入@menu。

@menu contains the number of option that the user selected from the list,
starting with 1 for the first option. You know now which option the user picked
and which number in your real list of possible menu items it translated to:
@menu包含了用户从列表中选择的选项的序号，从1开始，1对应首个选项。
现在，您知道用户选择了哪个选项，以及由它转换成的可能菜单项的真实列表中的哪个序号：

    mes "You selected " + .@possiblemenuitems$[.@menureference[@menu-1]] + "!";
	mes "你选择了 " + .@possiblemenuitems$[.@menureference[@menu-1]] + "!";

@menu is the number of option the user picked.
@menu-1 is the array index for the list of actually used menu items that we
made.
@menu是用户选择项对应的序号。
@menu-1是我们制作的实际使用菜单项列表的数组索引。

.@menureference[@menu-1] is the number of the item in the array of possible menu
items that we've saved just for this purpose.
@menureReference[@menu-1]是我们为此目的而保存的可能菜单项数组中的项目编号。

And .@possiblemenuitems$[.@menureference[@menu-1]] is the string that we used to
display the menu line the user picked. (Yes, it's a handful, but it works.)
@possiblemenuitems$[.@menureReference[@menu-1]]是用于显示用户选择的菜单行的字符串。
（是的，这比较难控制，但它可以运行。)

You can set up a bunch of 'if (.@menureference[@menu-1] == X) goto Y' statements to
route your execution based on the line selected and still generate a different
menu every time, which is handy when you want to, for example, make users select
items in any specific order before proceeding, or make a randomly shuffled menu.
您可以设置一组“if（.@menurereference[@menu-1]==X）goto Y”语句，根据所选行跳转到不同标签执行，
并且每次仍生成不同的菜单，这在您需要时非常方便，例如，让用户在继续操作之前按任何特定顺序选择项目，
或创建随机无序菜单。

Kafra code bundled with the standard distribution uses a similar array-based
menu technique for teleport lists, but it's much simpler and doesn't use @menu,
probably since that wasn't documented anywhere.
标准版附带的“卡普拉代码”中的"传送服务"列表采用了类似的，基于数组的生成菜单的方式，
但它简单得多，并且不使用@menu，大概由于这在任何地方都没有记录。

See also 'select', which is probably better in this particular case. Instead of
menu, you could use 'select' like this:
也请参考'select'命令，在这种情况下可能更好用。
用来替代"menu"命令，你可以这样使用'select'：

    .@dummy = select(.@menulist$[0],.@menulist$[1],...,.@menulist$[<X>]);

For the purposes of the technique described above these two statements are
perfectly equivalent.
基于上述目的给出的两种使用技巧都是相同的。

---------------------------------------

*select("<option>"{,"<option>",...})
*prompt("<option>"{,"<option>",...})
*select("<选项>"{,"<选项>",...})
*prompt("<选项>"{,"<选项>",...})

This function is a handy replacement for 'menu' for some specific cases where
you don't want a complex label structure - like, for example, asking simple yes-
no questions. It will return the number of menu option picked, starting with 1.
Like 'menu', it will also set the variable @menu to contain the option the user
picked.
这个函数是一个在一些特殊情况下可以方便替代'menu'指令的命令，在你不想使用复杂的
标签结构的地方 - 比如，询问 "是" 或 "否"这类简单的问题。该命令会返回菜单项被选
项的序号，从1开始。和'menu'命令一样，该命令也会对@menu变量赋值为玩家选择的项目
序号。

    if (select("Yes:No" ) == 1)
		mes "You said yes, I know.";

And like 'menu', the selected option is consistent with grouped options
and empty options.
并且和'menu'一样，选择项也可以成组或者为空。

'prompt' works almost the same as select, except that when a character clicks
the Cancel button, this function will return 255 instead.
'prompt'和select一样用法，不同之处在于当玩家点了取消后，该函数会返回255。


---------------------------------------

*input(<variable>{,<min>{,<max>}})
*input(<变量>{,<最小值>{,<最大值>}})

This command will make an input box pop up on the client connected to the
invoking character, to allow entering of a number or a string. This has many
uses, one example would be a guessing game, also making use of the 'rand'
function:
这个命令会在关联玩家的客户端显示一个输入框，让玩家输入一组数字或者字符串。
这有很多用途，一个例子就是猜谜游戏，以下例子使用了'rand'函数来获取随机数:

	mes "[Woman]";                                                //  mes "[女子]";
	mes "Try and guess the number I am thinking of.";             //  mes "试试猜出我心中所想的那个数字.";
	mes "The number will be between 1 and 10.";                   //  mes "这个数字在1到10之间.";
	next;                                                         //  next;
	.@number = rand(1,10);                                        //  .@number = rand(1,10);
	input .@guess;                                                //  input .@guess;
	if (.@guess == .@number) {                                    //  if (.@guess == .@number) {
		mes "[Woman]";                                            // 	mes "[女子]";
		mes "Well done, that was the number I was thinking of!";  // 	mes "不错, 这正是我心中想的那个数字!";
		close;                                                    // 	close;
	} else {                                                      // } else {
		mes "[Woman]";                                            // 	mes "[Woman]";
		mes "Sorry, that wasn't the number I was thinking of.";   // 	mes "不好意思, 这不是我心中所想的那个数字.";
		close;                                                    //	close;
	}                                                             //}

If you give the input command a string variable to put the input in, it will
allow the player to enter text. Otherwise, only numbers will be allowed.
如果你用一个字符串变量用来接收input命令传送过来的数据，那么将允许玩家输入文本。
除此之外，只允许输入数字。

	mes "[Woman]";                                // mes "[女子]";
	mes "Please say HELLO";                       // mes "请输入 你好";
	next;                                         // next;
	input .@var$;                                 // input .@var$;
	if (.@var$ == "HELLO") {                      // if (.@var$ == "你好") {
		mes "[Woman]";                            // mes "[女子]";
		mes "Well done, you typed it correctly."; // mes "很好, 你输入正确.";
		close;                                    // close;
	} else {                                      // } else {
		mes "[Woman]";                            // mes "[女子]";
		mes "Sorry, you got it wrong.";           // mes "不好意思, 你输入错误.";
		close;                                    // close;
	}                                             // }

Normally you may not input a negative number with this command.
This is done to prevent exploits in badly written scripts, which would
let people, for example, put negative amounts of Zeny into a bank script and
receive free Zeny as a result.
一般情况下，你不能用这个命令输入负数。这样做是为了防止在写得不好的脚本中出现漏洞而被利用。
举例来说，有人在银行脚本中输入一个负数，使原本要存入的Zeny结果变成得到Zeny。


Since trunk r12192 the command has two optional arguments and a return value.
The default value of 'min' and 'max' can be set with 'input_min_value' and
'input_max_value' in script_athena.conf.
For numeric inputs the value is capped to the range [min,max]. Returns 1 if
the value was higher than 'max', -1 if lower than 'min' and 0 otherwise.
For string inputs it returns 1 if the string was longer than 'max', -1 is
shorter than 'min' and 0 otherwise.
自从trunk r12192开始，该命令有两个可选参数和一个返回值。
默认的'min'(最小值)和 'max'(最大值)可以在script_athena.conf文件里的
'input_min_value'和'input_max_value'这两个地方设置。
输入数值的情况下可以设置输入区间为[最小值,最大值]。如果输入值大于最大值则返回1，
如果小于最小值则返回-1，其他情况返回0。输入字符串的情况下如果字符串长度大于'最大值'
则返回1，如果小于'最小值'则返回-1，其他情况返回0。

---------------------------------------

*callfunc "<function>"{,<argument>,...<argument>};
*callfunc("<function>"{,<argument>,...<argument>})
*callfunc "<函数>"{,<参数>,...<参数>};
*callfunc("<函数>"{,<参数>,...<参数>})

This command lets you call up a function NPC. A function NPC can be called from
any script on any map server. Using the 'return' command it will come back to
the place that called it.
这个命令可以调用一个函数NPC。一个函数NPC可以在任何地图编辑器的任何脚本中调用。
使用'return'命令可以返回到调用该函数的位置继续执行脚本。

	place,50,50,6%TAB%script%TAB%Woman%TAB%115,{      //  place,50,50,6%TAB%script%TAB%女子%TAB%115,{
		mes "[Woman]"                                 //  	mes "[女子]"
		mes "Let's see if you win...";                //  	mes "让我们看看你是不是赢了...";
		callfunc "funcNPC";                           //  	callfunc "funcNPC";
		mes "Well done, you have won!";               //  	mes "干得好, 你赢了!";
		close;                                        //  	close;
	}                                                 //  }
	function%TAB%script%TAB%funcNPC%TAB%{             //  function%TAB%script%TAB%funcNPC%TAB%{
		.@win = rand(2);                              //  	.@win = rand(2);
		if (.@win == 0)                               //  	if (.@win == 0)
			return;                                   //  		return;
		mes "Sorry, you lost.";                       //  	mes "抱歉, 你输了.";
		close;                                        //  	close;
	}                                                 //  }

You can pass arguments to your function - values telling it what exactly to do -
which will be available there with getarg() (see 'getarg')
Notice that returning is not mandatory, you can end execution right there.
你可以传递参数到你的函数里 - 用值来告诉函数具体要做什么 - 使用getarg()来获取参数值。
(参考'getarg') 注意，返回不是必须的，您可以在函数处结束脚本的执行。

If you want to return a real value from inside your function NPC, it is better
to write it in the function form, which will also work and will make the script
generally cleaner:
如果你想从你的函数NPC里返回一个实际值，你最好把它写成函数形式，一般这样做可以令脚本
显得简洁。

	place,50,50,6%TAB%script%TAB%Man%TAB%115,{               //  place,50,50,6%TAB%script%TAB%Man%TAB%115,{
		mes "[Man]"                                          //  	mes "[男子]"
		mes "Gimme a number!";                               //  	mes "给我一个数字!";
		next;                                                //  	next;
		input .@number;                                      //  	input .@number;
		if (callfunc("OddFunc",.@number)) mes "It's Odd!";   //  	if (callfunc("OddFunc",.@number)) mes "这是单数!";
		close;                                               //  	close;
	}                                                        //  }
	function%TAB%script%TAB%OddFunc%TAB%{                    //  function%TAB%script%TAB%OddFunc%TAB%{
		if (getarg(0)%2 == 0)                                //  	if (getarg(0)%2 == 0)
			return 0;// it's even                            //  		return 0;// 这是双数
		return 1;// it's odd                                 //  	return 1;// 这是单数
	}                                                        //  }

Alternately, as of rAthena revision 15979 and 15981, user-defined functions
may be called directly without the use of the 'callfunc' script command.
注意，从 rAthena 版本 15979 和 15981 开始，以后的用户自定义函数可以直接
使用函数名调用而不需要再用'callfunc'命令调用。

	function<tab>script<tab>SayHello<tab>{
		mes "Hello " + getarg(0);
		return 0;
	}

	place,50,50,6<tab>script<tab>Man<tab>115,{
		mes "[Man]";
		SayHello strcharinfo(0);
		close;
	}

Note:
注意：

 !! A user-defined function must be declared /before/ a script attempts to
 !! call it. That is to say, any functions should be placed above scripts or NPCs
 !! (or loaded in a separate file first) before attempting to call them directly.
 !! 一个用户自定义的函数必须在它被调用的脚本执行之前被声明(创建)。即是说，任何函数
 !! 都要放置在NPC脚本(或者首先从一个独立的文件里面加载)的读取顺序之前。

---------------------------------------

*callsub <label>{,<argument>,...<argument>};
*callsub(<label>{,<argument>,...<argument>})
*callsub <标签>{,<参数>,...<参数>};
*callsub(<标签>{,<参数>,...<参数>})

This command will go to a specified label within the current script (do NOT use
quotes around it) coming in as if it were a 'callfunc' call, and pass it
arguments given, if any, which can be recovered there with 'getarg'. When done
there, you should use the 'return' command to go back to the point from where
this label was called. This is used when there is a specific thing the script
will do over and over, this lets you use the same bit of code as many times as
you like, to save space and time, without creating extra NPC objects which are
needed with 'callfunc'. A label is not callable in this manner from another
script.
这个命令将会跳转到当前脚本中的一个特殊的标签处(绝对不要在标签两边使用引号)执行，
类似使用'callfunc'的效果，并传递所给的参数，如果有的话，就会被'getarg'获取。
当跳转的段落执行完毕后，你应用'return'命令来返回你原先跳转到这个标签的地点。
当脚本将反复执行某个特定的操作时，可以使用此选项。这样，您可以根据需要多次使用
相同的代码段，以节省空间和时间，而无需创建'callfunc'所需的额外NPC对象。
注意：标签不能以这种方式从另一个脚本调用(译注：只能在本脚本中使用。)。

Example 1: callsub for checking (if checks pass, return to script)//例子1：callsub调用子程序用于判断(如果判断成立，返回到脚本)
	callsub S_CheckFull, "guild_vs2",50;
	switch( rand(4) ) {
		case 0:	warp "guild_vs2",9,50;	end;
		case 1:	warp "guild_vs2",49,90;	end;
		case 2:	warp "guild_vs2",90,50;	end;
		case 3:	warp "guild_vs2",49,9;	end;
	}

...

S_CheckFull:
	if (getmapusers(getarg(0)) >= getarg(1)) {
		mes "I'm sorry, this arena is full.  Please try again later.";    //mes " 抱歉，这个区域已经满了。请稍后再试。"
		close;
	}
	return;

Example 2: callsub used repeatedly, with different arguments     //例子2：callsub调用子程序多次，使用不同参数
// notice how the Zeny check/delete is reused, instead of copy-pasting for every warp
//注意Zeny每次都需要确认并扣除，这样调用一个子程序可以免去每次传送前都需要重复写语句判定。
	switch(select("Abyss Lake:Amatsu Dungeon:Anthell:Ayothaya Dungeon:Beacon Island, Pharos")) {
		case 1:	callsub S_DunWarp,"hu_fild05",192,207;
		case 2:	callsub S_DunWarp,"ama_in02",119,181;
		case 3:	callsub S_DunWarp,"moc_fild20",164,145;
		case 4:	callsub S_DunWarp,"ayo_fild02",279,150;
		case 5:	callsub S_DunWarp,"cmd_fild07",132,125;
		// etc
	}

...

S_DunWarp:
// getarg(0) = "map name"    参数0是"地图名"
// getarg(1) = x             参数1是x坐标
// getarg(2) = y             参数2是y坐标
	if (Zeny >= 100) {
		Zeny -= 100;
		warp getarg(0),getarg(1),getarg(2);
	} else {
		mes "Dungeon warp costs 100 Zeny.";    //mes "洞穴传送需要100 Zeny.";(译注：Zeny不够显示的信息)
	}
	close;

---------------------------------------

*getarg(<index>{,<default_value>})
*getarg(<索引>{,<默认值>})

This function is used when you use the 'callsub' or 'callfunc' commands. In the
call you can specify variables that will make that call different from another
one. This function will return an argument the function or subroutine was
called with, and is the normal way to get them.
This is another thing that can let you use the same code more than once.
这个函数是在使用了'callsub'或者'callfunc'命令后用来传递参数。(译注：相当于形式参数，索引即是参数的序号)
在函数/子程序的调用时通过设置实际参数来获得不同的结果。这个函数将会在本函数或者子程序被调用时
返回调用时所设置的参数，并且这是一般用来获取参数的方式。
这是让你可以多次使用相同的代码的另一种途径。

Argument numbering starts with 0, i.e. the first argument you gave is number 0.
If no such argument was given, a zero is returned.
参数的序号从0开始，例如，第一个你给出的参数序号是0。如果没有其他参数，则默认返回0。

	place,50,50,6%TAB%script%TAB%Woman1%TAB%115,{     //  place,50,50,6%TAB%script%TAB%女子1%TAB%115,{
		mes "[Woman]";                                //  	mes "[女子]";
		mes "Let's see if you win...";                //  	mes "让我们看看你是不是赢了...";
		callfunc "funcNPC",2;                         //  	callfunc "funcNPC",2;
		mes "Well done, you have won!";               //  	mes "干得不错, 你已经赢了!";
		close;                                        //  	close;
	}                                                 //  }
                                                        
	place,52,50,6%TAB%script%TAB%Woman2%TAB%115,{     //  place,52,50,6%TAB%script%TAB%女子2%TAB%115,{
		mes "[Woman]";                                //  	mes "[女子]";
		mes "Let's see if you win...";                //  	mes "让我们看看你是不是赢了...";
		callfunc "funcNPC",5;                         //  	callfunc "funcNPC",5;
		mes "Well done, you have won!";               //  	mes "干得不错, 你已经赢了!";
		close;                                        //  	close;
	}                                                 //  }
                                                        
	function%TAB%script%TAB%funcNPC%TAB%{             //  function%TAB%script%TAB%funcNPC%TAB%{
		.@win = rand(getarg(0));                      //  	.@win = rand(getarg(0));
		if (.@win == 0) return;                       //  	if (.@win == 0) return;
		mes "Sorry, you lost.";                       //  	mes "抱歉, 你输了.";
		close;                                        //  	close;
	}                                                 //  }

"woman1" NPC object calls the funcNPC. The argument it gives in this call is
stated as 2, so when the random number is generated by the 'rand' function, it
can only be 0 or 1. Whereas "woman2" gives 5 as the argument number 0 when
calling the function, so the random number could be 0, 1, 2, 3 or 4, this makes
"woman2" less likely to say the player won.
"女子1"NPC对象调用了funcNPC。在调用时设置了参数2，这样随机数'rand'函数的参数就为2，
结果就会为0或者1。由于"女子2"参数0在函数调用时设置为5，因此随机数取值为0，1，2，3
或者4，这样就令"女子2"说玩家赢了的几率变低了。

You can pass multiple arguments in a function call:
你也可以在一次函数调用里传递多个参数：

	callfunc "funcNPC",5,4,3;

getarg(0) would be 5, getarg(1) would be 4 and getarg(2) would be 3.
getarg(0) 值为 5, getarg(1) 值为 4 ， getarg(2) 值为 3.

'getarg' has an optional argument since trunk r10773 and stable r10958.
If the target argument exists, it is returned.
Otherwise, if <default_value> is present it is returned instead,
if not the script terminates immediately.
从trunk r10773和stable r10958开始，'getarg'可以设置一个可选参数。
如果调用时有设置参数，那么参数将会被返回。否则，如果没有设置参数，而有设置了
<默认值>的话，则会返回<默认值>。如果没有设置<默认值>，脚本将立即终止。

In the previous example getarg(2,-1) would be 3 and getarg(3,-1) would be -1.
前面的例子如果getarg(2,-1)则会返回3，getarg(3,-1)会返回-1

---------------------------------------

*getargcount()

This function is used when you use the 'callsub' or 'callfunc' commands. In the
call you can specify arguments. This function will return the number of arguments
provided.
这个函数在你用了'callsub' 或 'callfunc'命令后使用。在调用中，你可以设置参数。
此函数将返回所设置的参数的数量。

Example:
例子：
	callfunc "funcNPC",5,4,3;
	...
	function%TAB%script%TAB%funcNPC%TAB%{
		.@count = getargcount(); // 3
		...
	}

---------------------------------------

*return {<value>};
*return {<值>};


This command causes the script execution to leave previously called function
with callfunc or script with callsub and return to the location, where the call
originated from. Optionally a return value can be supplied, when the call was
done using the function form.
这个命令将令函数调用或者子程序调用的脚本进程终止并返回到调用处。
当函数完成调用时，可以选择是否有返回值。


Using this command outside of functions or scripts referenced by callsub will
result in error and termination of the script.
在函数和子程序调用以外的地方使用该命令会导致错误并让脚本停止执行。

	callfunc "<your function>";// when nothing is returned
	set <variable>,callfunc("<your function>");// when a value is being returned
	callfunc "<你写的函数>";// 没有返回值
	set <变量>,callfunc("<你写的函数>");// 有返回值

---------------------------------------

*function <function name>;
*<function name>{(<argument>,...<argument>)};
*function <function name> {
<code>
}
*function <函数名称>;
*<函数名称>{(<参数>,...<参数>)};
*function <函数名称> {
<代码>
}

This works like callfunc, and is used for cleaner and faster scripting. The function
must be defined and used within a script, and works like a label with arguments.
Note that the name may only contain alphanumeric characters and underscore.
与callfunc类似，可以使脚本更简洁、更快速。此函数必须在脚本内部定义和使用，和带有参数
的标签一样。注意名称只能包含数码，字符和下划线。

Usage:
用法：

    1. Declare the function.      //声明函数
	function <function name>;     //  function <函数名称>;
    2. Call the function anywhere within the script.    //在脚本里随时调用函数。
       It can also return a value when used with parentheses.       //也可以用括号返回值
	<function name>;              //<函数名称>;
    3. Define the function within the script.     //在脚本中定义这个函数
	<function name> {<code>}     //<函数名称> {<代码>}

Example:
例子：

prontera,154,189,4	script	Item Seller	767,{                 //    prontera,154,189,4	script	物品贩卖员	767,{
	/* Function declaration */                                //    	/* 函数声明 */
	function SF_Selling;                                      //    	function SF_Selling;
                                                              //    
	if (Zeny > 50) {                                          //    	if (Zeny > 50) {
		mes "Welcome!";                                       //    		mes "欢迎!";
		/* Function call */                                   //    		/* 函数调用 */
		SF_Selling;                                           //    		SF_Selling;
	}                                                         //    	}
	else mes "You need 50z, sorry!";                          //    	else mes "你需要 50z, 抱歉!";
	close;                                                    //    	close;
                                                              //    
	/* Function definition */                                 //    	/* 函数定义 */
	function SF_Selling {                                     //    	function SF_Selling {
		mes "Would you like to buy a phracon for 50z?";       //   		mes "你要买强化武器金属-级数一吗，50z?";
		next;                                                 //    		next;
		if (select("Yes","No, thanks") == 1) {                //    		if (select("是的","不, 谢谢") == 1) {
			Zeny -= Zeny;                                     //    			Zeny -= Zeny;
			getitem 1010,1;                                   //    			getitem 1010,1;
			mes "Thank you!";                                 //    			mes "多谢惠顾!";
		}                                                     //    		}
		return;                                               //    		return;
	}                                                         //    	}
}                                                             //    }

Example with parameters and return value:
带参数和返回值的例子：

prontera,150,150,0	script	TestNPC	123,{                     //     prontera,150,150,0	script	测试NPC	123,{
	/* Function declaration */                                //     	/* 函数声明 */
	function MyAdd;                                           //     	function MyAdd;
                                                              //     
	mes "Enter two numbers.";                                 //     	mes "输入两个数字.";
	next;                                                     //     	next;
	input .@a;                                                //     	input .@a;
	input .@b;                                                //     	input .@b;
	/* Function call */                                       //     	/* 函数调用 */
	mes .@a + " + " + .@b + " = " + MyAdd(.@a,.@b);           //     	mes .@a + " + " + .@b + " = " + MyAdd(.@a,.@b);
	close;                                                    //     	close;
                                                              //     
	/* Function definition */                                 //     	/* 函数定义 */
	function MyAdd {                                          //     	function MyAdd {
		return getarg(0)+getarg(1);                           //     		return getarg(0)+getarg(1);
	}                                                         //     	}
}                                                             //    }


---------------------------------------

*is_function("<function name>")
*is_function("<函数名称>")

This command checks whether a function exists.
It returns 1 if function is found, or 0 if it isn't.
这个命令用来检查函数是否存在。如果存在返回1，不存在返回0。

Example:
例子：

	function	script	try	{
		dothat;
	}

	-	script	test	-1,{
		.@try = is_function("try"); // 1
		.@not = is_function("not"); // 0
	}

---------------------------------------

*if (<condition>) <statement>;
*if (<条件>) <语句>;

This is the basic conditional statement command, and just about the only one
available in this scripting language.
这是基本的条件语句命令。也是该脚本语言中唯一的一个。

The condition can be any expression. All expressions resulting in a non-zero
value will be considered True, including negative values. All expressions
resulting in a zero are false.
条件可以是任意表达式。所有表达式的结果只要是非0就表示真，包括负数。所有表达式
的结果是0就表示伪。

If the expression results in True, the statement will be executed. If it isn't
true, nothing happens and we move on to the next line of the script.
如果表达式的结果是真，后面的语句就会被执行。如果结果不是真，将跳过语句往下执行脚本。

    if (1)  mes "This will always print.";
    if (0)  mes "And this will never print.";
    if (5)  mes "This will also always print.";
    if (-1) mes "Funny as it is, this will also print just fine.";
	
	if (1)  mes "这会一直显示.";
    if (0)  mes "这不会显示.";
    if (5)  mes "这也会一直显示.";
    if (-1) mes "有趣的是, 这也会一直显示.";

For more information on conditional operators see the operators section above.
Anything that is returned by a function can be used in a condition check without
bothering to store it in a specific variable:
有关条件运算符的更多信息，请参阅上面的运算符部分。
函数返回的任何内容都可以在条件判断中使用，而无需费心将其存储在特定变量中：

    if (strcharinfo(0) == "Daniel Jackson") mes "It is true, you are Daniel!";
	if (strcharinfo(0) == "丹尼尔 杰克逊") mes "确实, 你是丹尼尔!";

More examples of using the 'if' command in the real world:
在实际应用中使用'if'命令的更多示例：

Example 1:
例子 1：

	.@answer = 1;                                 //  .@answer = 1;
	input .@input;                                //  input .@input;
	if (.@input == .@answer)                      //  if (.@input == .@answer)
		close;                                    //  	 close;
	mes "Sorry, your answer is incorrect.";       //  mes "抱歉, 你的回答是错误的.";
	close;                                        //  close;

Example 2:
例子 2：

	.@answer = 1;                                  //    .@answer = 1;
	input .@input;                                 //    input .@input;
	if (.@input != .@answer)                       //    if (.@input != .@answer)
		mes "Sorry, your answer is incorrect.";    //    	mes "抱歉, 你的回答是错误的.";
	close;                                         //    close;

Notice that examples 1 and 2 have the same effect.
注意，例子1和例子2的效果是相同的。

Example 3:
例子 3：

	.@count++;                                                                //    .@count++;
	mes "[Forgetful Man]";                                                    //    mes "[健忘的人]";
	if (.@count == 1) mes "This is the first time you have talked to me.";    //    if (.@count == 1) mes "这是你第一次和我说话.";
	if (.@count == 2) mes "This is the second time you have talked to me.";   //    if (.@count == 2) mes "这是你第二次和我说话.";
	if (.@count == 3) mes "This is the third time you have talked to me.";    //    if (.@count == 3) mes "这是你第三次和我说话.";
	if (.@count == 4) {                                                       //    if (.@count == 4) {
		mes "This is the fourth time you have talked to me.";                 //    	mes "这是你第四次和我说话.";
		mes "I think I am getting amnesia, I have forgotten about you...";    //    	mes "我想我得了健忘症，我已经忘记你了...";
		.@count = 0;                                                          //    	.@count = 0;
	}                                                                         //    }
	close;                                                                    //    close;

Example 4:
例子 4：

	mes "[Quest Person]";                                                                  //     mes "[任务人]";
	if (countitem(512) < 1) {  // 512 is the item ID for Apple, found in db/item_db.yml    //     if (countitem(512) < 1) { //512 是苹果的ID,可以在 db/item_db.yml中找到
		mes "Can you please bring me an apple?";                                           //     	mes "你可以给我一个苹果吗?";
		close;                                                                             //     	close;
	}                                                                                      //     }
	mes "Oh, you brought an Apple!";                                                       //     mes "噢，你带来了一个苹果!";
	mes "I didn't want it, I just wanted to see one.";                                     //     mes "我并不需要,我只是想看看.";
	close;                                                                                 //     close;

Example 5:
例子 5：

	mes "[Person Checker]";                                                    //     mes "[确认人]";
	if ($@name$ == "") {  // global variable not yet set                       //     if ($@name$ == "") {  // 未赋值的全局变量
		mes "Please tell me someones name";                                    //     	mes "请告诉我某个人的名字";
		next;                                                                  //     	next;
		input $@name$;                                                         //     	input $@name$;
		$@name2$ = strcharinfo(0);                                             //     	$@name2$ = strcharinfo(0);
		mes "[Person Checker]";                                                //     	mes "[确认人]";
		mes "Thank you.";                                                      //     	mes "谢谢.";
		close;                                                                 //     	close;
	}                                                                          //     }
	if ($@name$ == strcharinfo(0)) {  // player name matches $@name$           //     if ($@name$ == strcharinfo(0)) {  // 玩家的名字和 $@name$ 相同
		mes "You are the person that " + $@name2$ + " just mentioned.";        //     	mes "你就是刚才提到的 " + $@name2$ + " 那个人.";
		mes "Nice to meet you!";                                               //     	mes "很高兴遇见你!";
                                                                                    
		// reset the global variables                                               	// 重置全局变量
		$@name$ = "";                                                          //     	$@name$ = "";
		$@name2$ = "";                                                         //     	$@name2$ = "";
                                                                                    
		close;                                                                 //     	close;
	}                                                                          //     }
	mes "You are not the person that " + $name2$ + " mentioned.";              //     mes "你不是提到的 " + $name2$ + " 这个人.";
	close;                                                                     //     close;

See 'strcharinfo' for an explanation of what this function does.
请参阅'strcharinfo'关于该函数功能的说明。

Example 6: Using complex conditions.
例子 6：使用复杂的条件。

	mes "[Multiple Checks]";                                                   //    mes "[多重判断]";
	if (@queststarted == 1 && countitem(512) >= 5) {                           //    if (@queststarted == 1 && countitem(512) >= 5) {
		mes "Well done, you have started the quest and brought me 5 Apples.";  //    	mes "干得好,你的任务已开启完了，并已经给了我5个苹果.";
		@queststarted = 0;                                                     //    	@queststarted = 0;
		delitem 512,5;                                                         //    	delitem 512,5;
		close;                                                                 //    	close;
	}                                                                          //    }
	mes "Please bring me 5 apples.";                                           //    mes "请带给我 5 个苹果.";
	@queststarted = 1;                                                         //   @queststarted = 1;
	close;                                                                     //    close;

The script engine also supports nested 'if' statements:
脚本引擎还支持嵌套的'if'语句：

	if (<condition>)      // if (<条件>)
		dothis;           // 	执行这个;
	else                  // else
		dothat;           // 	执行那个;

If the condition isn't met, it'll do the action following the 'else'.
We can also group several actions depending on a condition:
如果条件不满足，它将执行'else'后面的操作。
我们还可以根据条件将多个操作分组：

	if (<condition>) {    //    if (<条件>) {
		dothis1;          //    	执行这个1;
		dothis2;          //    	执行这个2;
	} else {              //    } else {
		dothat1;          //    	执行那个1;
		dothat2;          //    	执行那个2;
		dothat3;          //    	执行那个3;
	}                     //    }

Remember that if you plan to do several actions upon the condition being false, and
you forget to use the curly braces (the { } ), the second action will be executed regardless
the output of the condition, unless of course, you stop the execution of the script if the
condition is true (that is, in the first grouping using a return; , and end; or a close; )
请记住，如果您计划在条件为false时执行多个操作，并且忘记使用大括号({})，
则无论条件的输出如何，都将执行第二个操作，当然，除非，如果条件为true后停止了脚本执行。
（即在第一个分组中使用return：、end；或close；)

Also, you can have multiple conditions nested or chained.
此外，可以嵌套或串联多个条件。

	if (<condition 1>)           //    if (<条件 1>)
		dothis;                  //    	执行这个;
	else if (<condition 2>) {    //    else if (<条件 2>) {
		dothat;                  //    	执行那个;
		end;                     //    	end;
	} else                       //    } else
		dothis;                  //    	执行这个;

---------------------------------------

*jump_zero (<condition>),<label>;
*jump_zero (<条件>),<标签>;

This command works kinda like an 'if'+'goto' combination in one go. (See 'if').
If the condition is false (equal to zero) this command will immediately jump to
the specified label like in 'goto'. While 'if' is more generally useful, for
some cases this could be an optimization.
这个命令如同将'if'+'goto'结合在一起使用。(参考'if')。
如果条件判定是伪(等于0)，那么这个命令将会立即跳转到指定的标签处执行(如同用了'goto')。
虽然'if'通常用途更广泛，但在某些情况下，这可以用作脚本的优化。

The main reason for this command is that other control statements, like
'switch', 'for' or 'while', are disassembled into simple expressions together
with this command when a script is parsed.
使用此命令的主要原因是，在解析脚本时，其他控制语句（如'switch'、'for'或'while'）
将与此命令一起分解为简单表达式。

---------------------------------------

*switch (expression);
*switch (表达式);

The switch statement is similar to a series of if statements on the same expression.
In many occasions, you may want to compare the same variable (or expression)
with many different values, and execute a different piece of code depending
on which value it equals to. This is exactly what the switch statement is for.
switch语句类似于同一表达式上的一系列if语句。在许多情况下，您可能希望将同一变量（或表达式）
与许多不同的值进行比较，并根据它等于哪个值执行不同的代码段。这正是switch语句的作用。

It is important to understand how the switch statement is executed in order
to avoid mistakes. The switch statement executes line by line (actually, statement by statement).
In the beginning, no code is executed. Only when a case statement is found
with a value that matches the value of the switch expression the case statement(s)
will to executed. The parser continues to execute the statements until the end
of the switch block, or the first time it sees a break statement. If you don't
write a break statement at the end of a case's statement list, the parser will
go on executing the statements of the following case (fall-through).
理解switch语句是如何执行以避免错误是很重要的。switch语句逐行执行（实际上是逐语句执行）。
开始时，不执行任何代码。只有当发现case语句的值与switch表达式的值匹配时，才会执行case语句。
解析器将继续执行这些语句，直到switch区块结束，或者第一次看到break语句为止。
如果没有在'case'语句列表的末尾编写'break'，解析器将继续执行以下case语句（往下遍历）。

Example 1:
例子 1:

	switch(select("Yes:No")) {     //    switch(select("是:不")) {
		case 1:                    //    	case 1:
			mes "You said yes!";   //    		mes "你说了是!";
			break;                 //    		break;
		case 2:                    //    	case 2:
			mes "Aww, why?";       //    		mes "啊，为什么？";
			break;                 //    		break;
	}                              //    }
	close;                         //    close;

The example above would work like a menu and would go to the first case if
the user selects option, otherwise, would go to the second one.
上面的例子就像一个菜单，如果用户选择了第一个选项，就会转到case 1，否则就会转到case 2。
(译注：select("是:不")根据选择项返回值1或者2，精确对应后续分支中的case '1'或者'2'，
case后面跟的那个值就是对应switch后面判断表达式返回的值。)

Example 2:
例子 2：

	switch(getgroupid()) {               //    switch(getgroupid()) {
		case 1:                          //    	case 1:
			mes "Wow, you're super!";    //    		mes "哇，你太棒了！";
			break;                       //    		break;
		case 2:                          //    	case 2:
			mes "A helping hand!";       //    		mes "一个得力助手!";
			break;                       //    		break;
		case 3:                          //    	case 3:
			mes "10001010010011";        //    		mes "10001010010011";
			break;                       //    		break;
		case 4:                          //    	case 4:
			mes "Yes, milord?";          //    		mes "是,大人?";
			break;                       //    		break;
		default:                         //    	default:                    
			mes "Hello there!";          //    		mes "你好！";
			break;                       //    		break;
	}                                    //    }

The example above would print a message depending on the player's groupid.
If there is no statement declared for the corresponding groupid, the script
would use the 'default' statement that applies to rest of possible values,
similar to 'else' in the if-else statement.
上述例子将根据玩家的组编号显示不同的信息。如果没有和groupid对应的case值，
脚本将跳转到'default'语句处，类似于If-else语句中的'else'。

---------------------------------------

*while (<condition>) <statement>;
*while (<条件>) <循环体语句>;

This is probably the simplest and most frequently used loop structure. The 'while'
statement can be interpreted as "while <condition> is true, perform <statement>".
It is a pretest loop, meaning the conditional expression is tested before any of the
statements in the body of the loop are performed. If the condition evaluates to
false, the statement(s) in the body of the loop is/are never executed. If the
condition evaluates to true, the statement(s) are executed, then control transfers
back to the conditional expression, which is reevaluated and the cycle continues.
这可能是最简单和最常用的循环结构。'while'语句可以解释为"while<条件>为true，执行<循环体语句>"。
这是一个前测循环结构，意思是在执行循环体中的任何语句之前先检测条件表达式。如果条件表达式的
计算结果为false，则不会执行循环体中的语句。如果条件的计算结果为true，则执行语句，语句执行完毕后
将跳转回条件表达式，条件表达式将重新计算，继续循环。


Multiple statements can be grouped with { }, curly braces, just like with the 'if' statement.
可以使用{}大括号将多个语句分组，就像使用'if'语句一样。

Example 1:                                     //      Example 1:
	while (switch(select("Yes:No") == 2 ))     //      	while (switch(select("是:否") == 2 ))
		mes "You picked no.";                  //      		mes "你选择了 否.";
	close;                                     //      	close;
                                                     
Example 2: multiple statements                 //      Example 2: 多语句
	while (switch(select("Yes:No") == 2 )) {   //      	while (switch(select("是:否") == 2 )) {
		mes "Why did you pick no?";            //      		mes "为什么你选择了 否?";
		mes "You should pick yes instead!";    //      		mes "你应该选择 是!";
	}                                          //      	}
	close;                                     //      	close;
                                                     
Example 3: counter-controlled loop             //      Example 3: 计数控制循环
	.@i = 1;                                   //      	.@i = 1;
	while (.@i <= 5) {                         //      	while (.@i <= 5) {
		mes "This line will print 5 times.";   //      		mes "这一行将会显示5次.";
		.@i += 1;                              //      		.@i += 1;
	}                                          //      	}
	close;                                     //      	close;
                                                     
Example 4: sentinel-controlled loop            //      Example 4:  标记控制循环
	mes "Input 0 to stop";                     //      	mes "输入0才会停止";
	input .@num;                               //      	input .@num;
	while (.@num != 0) {                       //      	while (.@num != 0) {
		mes "You entered " + .@num;            //      		mes "你输入了 " + .@num;
		input .@num;                           //      		input .@num;
	}                                          //      	}
	close;                                     //      	close;

---------------------------------------

*for (<variable initialization>; <condition>; <variable update>) <statement>;
*for (<初始化变量>; <条件表达式>; <变量更新>) <循环体语句>;

Another pretest looping structure is the 'for' statement. It is considered a
specialized form of the 'while' statement, and is usually associated with counter-
controlled loops. Here are the steps of the 'for' statement: the initialize
statement is executed first and only once. The condition test is performed.
When the condition evaluates to false, the rest of the for statement is skipped.
When the condition evaluates to true, the body of the loop is executed, then the
update statement is executed (this usually involves incrementing a variable).
Then the condition is reevaluated and the cycle continues.
另一个前测循环结构是'for'语句。它被认为是'while'语句的一种特殊形式，通常与计数器控制的循环相关联。
下面是'for'语句的执行步骤：<初始化变量>语句首先执行，并且只执行一次。随后判断条件表达式。
当条件表达式的计算结果为否 false时，将跳过for语句的其余部分。当条件表达式的计算结果为true时，
将执行循环体语句，然后执行变量更新语句（通常是递增变量）。然后重新计算条件表达式，循环继续
(译注：循环直到条件表达式计算结果为否 false)。

Example 1:                                      //   Example 1:
	for( .@i = 1; .@i <= 5; .@i++ )             //   	for( .@i = 1; .@i <= 5; .@i++ )
		mes "This line will print 5 times.";    //   		mes "这行将会显示5次.";
                                                //   
Example 2:                                      //   Example 2:
	mes "This will print the numbers 1 - 5.";   //   	mes "这将会显示数字 1 - 5.";
	for( .@i = 1; .@i <= 5; .@i++ )             //   	for( .@i = 1; .@i <= 5; .@i++ )
		mes "Number: " + .@i;                   //   		mes "数字: " + .@i;

---------------------------------------

*do { <statement>; } while (<condition>);
*do { <循环体语句>; } while (<条件表达式>);

The 'do...while' is the only post-test loop structure available in this script
language. With a post-test, the statements are executed once before the condition
is tested. When the condition is true, the statement(s) are repeated. When the
condition is false, control is transferred to the statement following the
'do...while' loop expression.
'do...while'是此脚本语言中唯一的后测循环结构。使用后测循环结构，会在条件表达式进行
判断之前执行一次语句。当条件为true时，将重复该语句。当条件为false时，将停止循环
并跳转到'do...while'后面的语句执行。

Example 1: sentinel-controlled loop                             //     例子 1: 标记控制循环
	mes "This menu will keep appearing until you pick Cancel";  //     	mes "此菜单将一直显示，直到您选择 取消";
	do {                                                        //     	do {
		.@menu = select("One:Two:Three:Cancel");                //     		.@menu = select("一:二:三:取消");
	} while (.@menu != 4);                                      //     	} while (.@menu != 4);
                                                                //     
Example 2: counter-controlled loop                              //     例子 2: 计数控制循环
	mes "This will countdown from 10 to 1.";                    //     	mes "这将从10倒数到1.";
	.@i = 10;                                                   //     	.@i = 10;
	do {                                                        //     	do {
		mes .@i;                                                //     		mes .@i;
		.@i -= 1;                                               //     		.@i -= 1;
	} while (.@i > 0);                                          //     	} while (.@i > 0);

---------------------------------------

*freeloop({<toggle>})
*freeloop({<切换>})

Toggling this to enabled (1) allows the script instance to bypass the infinite loop
protection, allowing your script to loop as much as it may need. Disabling (0) will
warn you if an infinite loop is detected.
切换为值（1）将允许脚本实例绕过无限循环保护，从而允许脚本按需要尽可能多地循环。
（译注：脚本引擎默认循环次数大于200会提示无限循环并停止循环，称为无限循环保护）
如果检测到无限循环，禁用（0）将向您发出警告。

The command will return the state of freeloop for the attached script, even if no
argument is provided.
该命令将返回关联脚本的freeloop状态，即使未提供任何参数。

Example:                                                                       //      例子:
	freeloop(1); // enable script to loop freely                               //      	freeloop(1); // 允许脚本不受限制循环
                                                                               //      
	// be careful with what you do here                                        //      	// 留意你要做的事情
	for ( .@i = 0; .@i < .@bigloop; .@i++ ) {                                  //      	for ( .@i = 0; .@i < .@bigloop; .@i++ ) {
		dothis;                                                                //      		dothis;
		// will sleep the script for 1ms when detect an infinity loop to       //      		// 当检测到无限循环时，将使脚本休眠1ms，以让rAthena
		// let rAthena do what it needs to do (socket, timer, process, etc.)   //      		// 执行它需要执行的操作（端口、计时器、进程等）。
	}                                                                          //      	}
                                                                                   
	freeloop(0); // disable freeloop                                           //      	freeloop(0); // 停止允许脚本不受限制循环
                                                                               //      
	for ( .@i = 0; .@i < .@bigloop; .@i++ ) {                                  //      	for ( .@i = 0; .@i < .@bigloop; .@i++ ) {
		dothis;                                                                //      		dothis;
		// throw an infinity loop error                                        //      		// 提示无限循环错误
	}                                                                          //      	}

---------------------------------------

*setarray <array name>[<first value>],<value>{,<value>...<value>};
*setarray <数组名称>[<首值>],<值>{,<值>...<值>};

This command will allow you to quickly fill up an array in one go. Check the
Kafra scripts in the distribution to see this used a lot.
此命令将允许您一次性快速填充数组。参考公布的卡普拉脚本可解它的使用方法。

    setarray .@array[0], 100, 200, 300, 400, 500, 600;

First value is the index of the first element of the array to alter. For
example:
首值是要更改的数组的第一个元素的索引。
例如：

    setarray .@array[0],200,200,200;
    setarray .@array[1],300,150;

will produce:
将做如下赋值：

 .@array[0]=200
 .@array[1]=300
 .@array[2]=150

---------------------------------------

*cleararray <array name>[<first value to alter>],<value>,<number of values to set>;
*cleararray <数组名称>[<要更改的首值>],<值>,<要设置的值的数目>;

This command will change many array values at the same time to the same value.
此命令将同时将多个数组值更改为相同的值。

    setarray .@array[0], 100, 200, 300, 400, 500, 600;
    // This will make all 6 values 0    //下面这行将把所有6个值变为0
    cleararray .@array[0],0,6;
    // This will make array element 0 change to 245    //下面这行将把数组的0号元素变为245
    cleararray .@array[0],245,1;
    // This will make elements 1 and 2 change to 345   //下面这行将把数组的1，2号元素变为345
    cleararray .@array[1],345,2;

See 'setarray'.
参考 'setarray'.

---------------------------------------

*copyarray <destination array>[<first value>],<source array>[<first value>],<amount of data to copy>;
*copyarray <目标数组>[<首值>],<源数组>[<首值>],<要复制的数据量>;

This command lets you quickly shuffle a lot of data between arrays, which is in
some cases invaluable.
此命令可以在数组之间快速移动大量数据，这在某些情况下是非常有用的。

    setarray .@array[0], 100, 200, 300, 400, 500, 600;
    // So we have made .@array[]   //建立一个.@array[]数组
    copyarray .@array2[0],@array[2],2;

    // Now, .@array2[0] will be equal to .@array[2] (300) and    //现在，数组元素.@array2[0]等于.@array[2] (300)，
    // .@array2[1] will be equal to .@array[3].                  //.@array2[1]等于.@array[3] (400)。

So using the examples above:
因此上述例子的结果是：
 .@array[0] = 100
 .@array[1] = 200
 .@array[2] = 300
 .@array[3] = 400
 .@array[4] = 500
 .@array[5] = 600

New Array:
新数组：
 .@array2[0] = 300
 .@array2[1] = 400
 .@array2[2] = 0
 .@array2[3] = 0

Notice that .@array[4] and .@array[5] won't be copied to the second array, and it will return a
0.
注意.@array[4]和.@array[5]的值未被复制到第二个数组里，因此对应的值是0。

---------------------------------------

*deletearray <array name>[<first value>]{,<how much to delete>};
*deletearray <数组名称>[<首值>]{,<要删除的数量>};

This command will delete a specified number of array elements totally from an
array, shifting all the elements beyond this towards the beginning.
此命令将从一个数组中完全删除指定数量的数组元素，并将超出此范围的所有元素移到开头。

    // This will delete array element 0, and move all the other array elements
    // up one place.
	// 这将会删除数组的0号元素，并将其他数组元素往前移动一位。
    deletearray .@array[0],1

// This would delete array elements numbered 1, 2 and 3, leave element 0 in its
// place, and move the other elements ups, so there are no gaps.
// 这将会删除数组的1，2，3号元素，留下0号元素在原本的位置，并将其他元素前移。
// 因此不会出现空位。

    deletearray .@array[1],3

---------------------------------------

*inarray <array name>,<value>;
*inarray <数组名称>,<值>;

This command returns the index of the first matching value found in the array.
It will return -1 if the value is not found.
此命令返回数组中找到的第一个匹配值的索引。如果找不到该值，它将返回-1。

	setarray .@array[0], 100, 200, 300, 400, 500, 600, 100;
	
	inarray(.@array[0], 200);
	//return 1 because 200 is in index 1   //由于200的索引是1，因此返回值是1
	//another way to say it that .@array[1] == 200   //即是说.@array[1] == 200
	
	.@index = inarray(.@array[0], 600);
	//.@index is now 5 because .@array[5] == 600   //.@index值为5，因为.@array[5] == 600
	
	inarray(.@array[0], 100);
	//while index 6 is also 100, the command will return the first instance it finds
	//虽然索引6的值也是100，但是该命令只会返回它搜索到的第一个值。
	//return 0 because .@array[0] == 100   //因此将会返回0因为.@array[0] == 100

	inarray(.@array[0], 800);
	//return -1 because 800 is not an element of the array .@array
	//返回-1，因为在.@array数组中没有800这个值

For more details, see the sample in 'doc/sample/inarray.txt'.
有关更多详细信息，请参见'doc/sample/inarray.txt'中的示例。

---------------------------------------

*countinarray <array name>{[<start index>]},<array name>{[<start index>]};
*countinarray <数组名称>{[<起始索引>]},<数组名称>{[<起始索引>]};

This command will check for matches between the array values and return the number of matches.
While being optional, if [<start index>] is supplied, the search will begin from the given index value.
此命令将检查数组值之间是否匹配，并返回匹配数。虽然是可选的，但如果提供了[<起始索引>]，则搜索将从给定的索引值开始。

	setarray .@array[0], 100, 200, 300, 400, 500, 600;
	
	.@variable = 100;
	if(countinarray(.@array[0], .@variable))
		mes "The number 100 was found in the array .@array";    //mes "数字 100 在数组 .@array里被发现";
	
	countinarray(.@array[0], .@variable);
	//return 1 because the number 100 is an element of the array .@array
	//返回1，因为数字100是数组.@array中的一个元素
	
	setarray .@array2[0],100,500;
	countinarray(.@array[0], .@array2[0]);
	//return 2 because the numbers 100 and 500 are elements of the array .@array
	//返回2，因为数字100和600都是数组.@array中的元素
	
	setarray .@array3[0],100,700;
	countinarray(.@array[0], .@array3[0]);
	//return 1 because the number 100 is an element of the array .@array
	//but the number 700 is not an element of the array .@array
	//返回1，因为数字100是数组.@array中的一个元素
	//但是数字700不是数组.@array中的一个元素

	//also you can change the position between the arrays in the command
	//在该命令里你还可以更换两个数组的位置
	if(countinarray(.@array[0], .@array3[0]) == countinarray(.@array3[0], .@array[0]))
		//This is true
		//返回值是真

For more details, see the sample in 'doc/sample/inarray.txt'.
有关更多详细信息，请参见'doc/sample/inarray.txt'中的示例。

---------------------------------------

======================================
|2.- Information-retrieving commands.|       //信息检索类命令
======================================
---------------------------------------

*strcharinfo(<type>{,<char_id>})
*strcharinfo(<类型>{,<角色编号>})

This function will return either the name, party name or guild name for the
invoking character. Whatever it returns is determined by type.
这个函数将会返回关联角色的名字，队伍名字或者工会名字等信息。它返回的内容由类型决定。

 0 - Character's name.                           0 - 角色的名字.
 1 - The name of the party they're in if any.    1 - 他们所在的组队的名字，如果有的话.
 2 - The name of the guild they're in if any.    2 - 他们所在的工会的名字，如果有的话.
 3 - The name of the map the character is in.    3 - 他们所在的地图的名字.

If a character is not a member of any party or guild, an empty string will be
returned when requesting that information.
如果角色没有队伍或者没有加入工会，那么将会返回一个空字符串。

---------------------------------------

*convertpcinfo(<char_id>,<type>)
*convertpcinfo(<account_id>,<type>)
*convertpcinfo(<player_name>,<type>)
*convertpcinfo(<角色编号>,<类型>)
*convertpcinfo(<账号id>,<类型>)
*convertpcinfo(<角色名字>,<类型>)

This function will return the information <type> for the
specified character. Whatever it returns is determined by type.
这个函数将会返回指定角色的信息<类型>。它返回的内容由类型决定。

 CPC_NAME    - Character's name.
 CPC_CHAR    - Character ID.
 CPC_ACCOUNT - Account ID.
 CPC_NAME    - 角色的名字.
 CPC_CHAR    - 角色的ID.
 CPC_ACCOUNT - 账号ID.

If a character is not found (or not online) when requesting that information,
an empty string will be returned for CPC_NAME, 0 for other <type>.
如果需要获取信息的角色没有找到(或者离线)，那么CPC_NAME类型将返回一个空字符串，
其他类型将返回0。

---------------------------------------

*strnpcinfo(<type>)
*strnpcinfo(<类型>)

This function will return the various parts of the name of the calling NPC.
Whatever it returns is determined by type.
这个函数将返回所调用NPC的名称中的各部分信息。它返回的内容由类型决定。


 0 - The NPC's display name (visible#hidden)           0 - NPC的显示名称 (可视部分#隐藏部分)
 1 - The visible part of the NPC's display name        1 - NPC显示名称中的可见部分
 2 - The hidden part of the NPC's display name         2 - NPC显示名称中的隐藏部分
 3 - The NPC's unique name (::name)                    3 - NPC的独有名称 (::名称)
 4 - The name of the map the NPC is in.                4 - NPC所在的地图名称.

---------------------------------------

*getarraysize(<array name>)
*getarraysize(<数组名称>)

This function returns highest index of the array that is filled.
Notice that zeros and empty strings at the end of this array are not
counted towards this number.
这个函数将会返回指定数组里包含的元素数量(译注：原文是最大索引)。
注意在数组的末尾处0和空字符串不被计入该数量。

For example:
举例：

    setarray .@array[0], 100, 200, 300, 400, 500, 600;
    set .@arraysize,getarraysize(.@array);

This will make .@arraysize == 6. But if you try this:
这将会令.@arraysize == 6。但是如果你试着这样：

    setarray .@array[0], 100, 200, 300, 400, 500, 600, 0;
    set .@arraysize,getarraysize(.@array);

.@arraysize will still equal 6, even though you've set 7 values.
.@arraysize 照样会等于6，尽管你设置了第7个的值。

---------------------------------------

*getelementofarray(<array name>,<index>)
*getelementofarray(<数组名称>,<索引>)

This command retrieves the value of the element of given array at given index.
This is equivalent to using:
这个命令会从给定数组中获取给定索引所对应元素的值。
相当于使用了：

    <array name>[<index>]     //<数组名称>[<索引>]

The reason for this is, that this short form is internally converted into a call
to getelementofarray, when the script is loaded.
这样做的原因是，在加载脚本时，以这种形式对内部数组元素的获取和转换比较简短。

Also useful when passing arrays to functions or accessing another npc's arrays:
另一个用处是传递数组到函数或者访问其他npc的数组：
    getelementofarray(getarg(0),<index>)                          //   getelementofarray(getarg(0),<索引>)
    getelementofarray(getvariableofnpc(.var, "testNPC"),<index>)  //   getelementofarray(getvariableofnpc(.var, "测试NPC"),<索引>)

---------------------------------------

*readparam(<parameter number>{,"<character name>"})
*readparam(<parameter number>{,<char_id>})
*readparam(<参数编号>{,"<角色名称>"})
*readparam(<参数编号>{,<角色编号>})

This function will return the specified stat of the invoking character, or, if a
character name or character id is specified, of that player. The stat can either
be a number or parameter name, defined in 'src/map/script_constants.hpp'.
这个函数将会返回关联角色，或者指定了名字或id的角色的相关参数。该参数可以
是数字或者参数名，在'src/map/script_constants.hpp'中定义。

Some example parameters:
一些参数的举例：

StatusPoint, BaseLevel, SkillPoint, Class, Upper, Zeny, Sex, Weight, MaxWeight,
JobLevel, BaseExp, JobExp, NextBaseExp, NextJobExp, Hp, MaxHp, Sp, MaxSp,
BaseJob, Karma, Manner, bVit, bDex, bAgi, bStr, bInt, bLuk
剩余素质点数，基础等级，剩余技能点数，职业，扩展级别，Zeny，性别，当前负重，最大负重，
职业等级，基础经验值，职业经验值，下次升级需要的基础经验，下次升级需要的职业经验，当前HP，最大HP，当前SP，最大SP，
基础职业，Karma，禁言，基础体质，基础灵巧，基础敏捷，基础力量，基础智力，基础幸运

All of these also behave as variables, but don't expect to be able to just 'set'
them - some will not work for various internal reasons.
所有这些也都可以作为变量，但不要期望能够'设置'它们——有些由于各种内部原因无法工作。

Example 1:
例子 1：

    // Returns how many status points you haven't spent yet.
	// 返回你还有多少素质点数还没加.
    mes "Unused status points: " + readparam(9);     // mes "未使用素质点数: " + readparam(9);

Using this particular information as a function call is not required. Typing this
will return the same result:
并不需要将此特定信息用作函数调用。输入这些参数名称将返回相同的结果：

    mes "Unused status points: " + StatusPoint;     // mes "未使用素质点数: " + StatusPoint;

Example 2:
例子 2：

You can also use this command to get stat values.
您还可以使用此命令获取素质值。

    if (readparam(bVit) > 77)
        mes "Only people with over 77 Vit are reading this!";   //mes "只有体质到达 77 的人可以读到此信息!";

---------------------------------------

*getcharid(<type>{,"<character name>"})
*getcharid(<类型>{,"<角色的名字>"})

This function will return a unique ID number of the invoking character, or, if a
character name is specified, of that player.
这个函数将会返回一个关联角色或者指定名字角色的独有ID数字。

Type is the kind of associated ID number required:
类型是需要返回的关联ID号的相关信息：

 0 - Character ID       //   0 - 角色的ID
 1 - Party ID           //   1 - 队伍的ID
 2 - Guild ID           //   2 - 工会的ID
 3 - Account ID         //   3 - 账号的ID
 4 - Battle Ground ID   //   4 - 战场的ID
 5 - Clan ID            //   5 - 派别的ID

For most purposes other than printing it, a number is better to have than a name
(people do horrifying things to their character names).
除了用来显示以外的大多数目的，使用数字会比使用名称更好。
(有些人喜欢起一些五花八门乱七八糟奇奇怪怪的名字)

If the character is not in a party or not in a guild, the function will return 0
if guild or party number is requested. If a name is specified and the character
is not found, 0 is returned.
如果角色没有队伍或者没有加入工会，该函数将会返回0。如果设置了指定的角色名而该角色
没有找到，那么也会返回0。

If getcharid(0) returns a zero, the script got called not by a character and
doesn't have an attached RID. Note that this will cause the map server to
print "player not attached!" error messages, so it is preferred to use
"playerattached" to check for the character attached to the script.
如果getcharid(0)返回了0值，那么该脚本将不会关联任何角色和RID。注意，这回令地图
服务器显示"未关联玩家!"的错误信息，因此最好使用"playerattached"命令确认是否有。角色
关联了该脚本。

if (getcharid(2) == 0)
	mes "Only members of a guild are allowed here!";    //mes "这里只允许有工会的人员进入!";

---------------------------------------

*getnpcid(<type>{,"<npc name>"});
*getnpcid(<类型>{,"<npc名称>"});

Retrieves IDs of the currently invoked NPC. If a unique npc name is
given, IDs of that NPC are retrieved instead. Type specifies what ID
to retrieve and can be one of the following:
检索当前调用的NPC的ID。如果指定了一个npc的独有名，该NPC的ID将被检索。
要检索的ID的指定类型，可以是以下类型之一：

    0 - NPC Game ID          //0 - NPC 在游戏中的 ID

If an invalid type is given or the NPC does not exist, 0 is returned.
如果给了无效的类型或者NPC不存在，将会返回0。

---------------------------------------

*getchildid({<char_id>})
*getmotherid({<char_id>})
*getfatherid({<char_id>})
*getchildid({<角色编号>})
*getmotherid({<角色编号>})
*getfatherid({<角色编号>})


These functions return the character ID of the attached player's child,
mother, mother, or father, respectively. It returns 0 if no ID is found.
这几个函数会分别返回相应角色编号对应角色的小孩，母亲或者父亲ID。如果没找到
则会返回0。

    if (getmotherid()) mes "Your mother's ID is: " + getmotherid();       //if (getmotherid()) mes " 你母亲的 ID 是: " + getmotherid();

---------------------------------------

*ispartneron({<char_id>})
*ispartneron({<角色编号>})

This function returns 1 if the invoking character's marriage partner is
currently online and 0 if they are not or if the character has no partner.
如果关联角色的双亲有在线则这个函数会返回1，如果没在线或者没有双亲则返回0。

---------------------------------------

*getpartnerid({<char_id>})
*getpartnerid({<角色编号>})

This function returns the character ID of the invoking character's marriage
partner, if any. If the invoking character is not married, it will return 0,
which is a quick way to see if they are married:
这个函数会返回关联角色(已婚)的配偶ID。如果没有结婚，则返回0，
这是一个快速判断角色是否已婚的命令。

    if (getpartnerid()) mes "I'm not going to be your girlfriend!";      //  if (getpartnerid()) mes "我不能成为你的女朋友!";
    if (getpartnerid()) mes "You're married already!";                   //  if (getpartnerid()) mes "你已经结婚了!";

---------------------------------------

*getlook(<type>{,<char_id>})
*getlook(<类型>{,<角色编号>})

This function will return the number for the current character look value
specified by type. See 'setlook' for valid look types.
这个函数会返回当前角色的指定类型的外观值。参考'setlook'里的关于外观类型的说明。

This can be used to make a certain script behave differently for characters
dressed in black.
这可以用来根据角色的不同外观值来设置某些脚本的不同执行方式。

---------------------------------------

*getsavepoint(<information type>{,<char_id>})
*getsavepoint(<信息类型>{,<角色编号>})

This function will return information about the invoking character's save point.
You can use it to let a character swap between several recorded save points.
Available information types are:
这个函数用来返回关联角色或者指定ID角色的储存点信息。
你可以用这个命令来让角色在一些被记录的储存点间往返。
可用的类型是：

 0 - Map name (a string)    //    0 - 地图名(字符串格式)
 1 - X coordinate           //    1 - X 坐标
 2 - Y coordinate           //    2 - Y 坐标

---------------------------------------

*getcharip({"<character name>"|<account id>|<char id>})
*getcharip({"<角色名字>"|<账号id>|<角色编号>})

This function will return the IP address of the invoking character, or, if a player
is specified, of that character. A blank string is returned if no player is attached.
这个函数将会返回关联角色或者指定玩家/角色的IP地址。如果没有玩家关联。则会返回一个空字符串。

Examples:
例子：

// Outputs IP address of attached player.        //     // 输出关联角色的IP地址.
	mes "Your IP: " + getcharip();               //     	mes "你的 IP: " + getcharip();
                                                 //     
// Outputs IP address of character "Silver".     //     // 输入角色"银色"的IP地址.
	mes "Silver's IP: " + getcharip("Silver");   //     	mes "银色 的IP: " + getcharip("Silver");

---------------------------------------

*vip_status(<type>,{"<character name>"})
*vip_status(<类型>,{"<角色名字>"})

Returns various information about a player's VIP status.
返回关于玩家VIP状态的各种信息。

Valid types:
有效类型：
 VIP_STATUS_ACTIVE - VIP status: true if the player is a VIP or false if not   //     VIP_STATUS_ACTIVE - VIP 状态: 如果玩家是VIP就返回true如果不是就返回false
 VIP_STATUS_EXPIRE - VIP expire timestamp if the player is VIP or 0 if not     //     VIP_STATUS_EXPIRE - 如果玩家是VIP就返回VIP过期时间戳，如果不是就返回0
 VIP_STATUS_REMAINING - VIP time remaining in seconds                          //     VIP_STATUS_REMAINING - VIP的剩余时间(秒)

NOTE: This command is only available if the VIP System is enabled.
注意：这个命令只有在启用了VIP系统才会生效。

---------------------------------------

*vip_time <time>,{"<character name>"};
*vip_time <时间>,{"<角色名字>"};

Changes a player's VIP time (in minutes). A positive value will increase time, and a
negative value will decrease time.
更改玩家的VIP时间(以分钟计)。正值是增加时间，负值是减少时间。

NOTE: This command is only available if the VIP System is enabled.
注意：这个命令只有在启用了VIP系统才会生效。

---------------------------------------

*addspiritball <count>,<duration>{,<char_id>};
*addspiritball <数量>,<期间>{,<角色编号>};

Adds spirit ball to player for 'duration' in milisecond.
给玩家增加持续时间为'期间'(单位：毫秒)的若干个气功球。（译注：武道家的那种气功球）

---------------------------------------

*delspiritball <count>{,<char_id>};
*delspiritball <数量>{,<角色编号>};

Deletes the spirit ball(s) from player.
减少玩家身上附加的气功球。

---------------------------------------

*countspiritball {<char_id>};
*countspiritball {角色编号>};

Counts the spirit ball that player has.
对玩家身上的气功球数量进行计数。

---------------------------------------

*ignoretimeout <flag>{,<char_id>};
*ignoretimeout <标志>{,<角色编号>};

Disables the SECURE_NPCTIMEOUT function on the character invoking the script,
or by the given character ID/character name.
对关联玩家或者指定ID的角色禁用SECURE_NPCTIMEOUT(NPC超时保护)函数。

有效标志:

 0 - Enabled SECURE_NPCTIMEOUT.    //     0 - 启用 SECURE_NPCTIMEOUT.
 1 - Disable SECURE_NPCTIMEOUT.    //     1 - 禁用 SECURE_NPCTIMEOUT.

Note: SECURE_NPCTIMEOUT must be enabled for this to work.
注意：SECURE_NPCTIMEOUT必须先启用命令才生效。

---------------------------------------
\\
2,2 Item-related commands                //物品相关命令
\\
---------------------------------------

*getequipid({<equipment slot>,<char_id>})
*getequipid({<装备位置>,<角色编号>})

This function returns the item ID of the item slot that calls the script
on the invoking character or the specified equipment slot. If nothing is
equipped there, it returns -1.
Valid equipment slots are:
这个函数会返回关联角色或者指定ID角色身上指定装备位置的物品编号。如果该位置
没有装备，则返回 -1。

EQI_COMPOUND_ON (-1)      - Item slot that calls this script (In context of item script) - exclusive to getequipid  - 调用该脚本的物品装备位置 (-1)(根据前后的语句决定)
EQI_ACC_L (0)             - Accessory 1                             - 装饰品1 (0)(左边那个)
EQI_ACC_R (1)             - Accessory 2                             - 装饰品2 (1)(右边那个)
EQI_SHOES (2)             - Footgear (shoes, boots)                 - 鞋子 (2)
EQI_GARMENT (3)           - Garment (mufflers, hoods, manteaux)     - 披肩 (3)          
EQI_HEAD_LOW (4)          - Lower Headgear (beards, some masks)     - 头饰下 (4)         
EQI_HEAD_MID (5)          - Middle Headgear (masks, glasses)        - 头饰中 (5)         
EQI_HEAD_TOP (6)          - Upper Headgear                          - 头饰上 (6)         
EQI_ARMOR (7)             - Armor (jackets, robes)                  - 身体装备 (7)            
EQI_HAND_L (8)            - Left hand (weapons, shields)            - 左手装备 (8)           
EQI_HAND_R (9)            - Right hand (weapons)                    - 右手装备 (9)           
EQI_COSTUME_HEAD_TOP (10) - Upper Costume Headgear                  - 时装头上 (10)
EQI_COSTUME_HEAD_MID (11) - Middle Costume Headgear                 - 时装头中 (11)
EQI_COSTUME_HEAD_LOW (12) - Lower Costume Headgear                  - 时装头下 (12)
EQI_COSTUME_GARMENT (13)  - Costume Garment                         - 时装披肩 (13) 
EQI_AMMO (14)    		  - Arrow/Ammunition                        - 投射物 (14)    (译注：即箭矢，子弹，炮弹，飞镖等等这些)	 
EQI_SHADOW_ARMOR (15)     - Shadow Armor                            - 影子身体装备 (15)    
EQI_SHADOW_WEAPON (16)    - Shadow Weapon                           - 影子武器 (16)   
EQI_SHADOW_SHIELD (17)    - Shadow Shield                           - 影子盾牌 (17)   
EQI_SHADOW_SHOES (18)     - Shadow Shoes                            - 影子鞋子 (18)    
EQI_SHADOW_ACC_R (19)     - Shadow Accessory 2                      - 影子装饰品2 (19)(右边那个)    
EQI_SHADOW_ACC_L (20)     - Shadow Accessory 1                      - 影子装饰品1 (20)(左边那个)   

Notice that a few items occupy several equipment slots, and if the character is
wearing such an item, 'getequipid' will return its ID number for either slot.
注意，如果角色在某位置穿戴了占据多装备位置的装备，那么每个被占据位置都会返回相同的物品编号。

Can be used to check if you have something equipped, or if you haven't got
something equipped:
可以用来检测你身上的装备，或者没穿装备。

	if (getequipid(EQI_HEAD_TOP) == 2234)           //    if (getequipid(EQI_HEAD_TOP) == 2234)
		mes "What a lovely Tiara you have on";      //    	mes "你戴着一个好可爱的后冠";
	else                                            //    else
		mes "Come back when you have a Tiara on";   //    	mes "当你戴上后冠后再回来找我吧";
	close;                                          //    close;

You can also use it to make sure people don't pass a point before removing an
item totally from them. Let's say you don't want people to wear Legion Plate
armor, but also don't want them to equip if after the check, you would do this:
你可以用这个命令来确保玩家无法带着禁止携带的物品经过某个地点。举例来说，你如果不
想让玩家穿着秘银金属铠甲或者携带，你可以这样写脚本：

	if (getequipid(EQI_ARMOR) == 2341 || getequipid(EQI_ARMOR) == 2342) {   //判断身上是不是穿着秘银金属铠甲(有洞或无洞)
		mes "You are wearing some Legion Plate Armor, please drop that in your stash before continuing";
		//mes "你穿着秘银金属铠甲, 请你把它扔进仓库才能继续";
		close;
	}
	// the || is used as an or argument, there is 2341 and 2342 cause there are     // '||' 符号是参数的或判断,  2341 和 2342 分别是
	// two different legion plate armors, one with a slot one without.              // 无洞和有洞的秘银金属铠甲.

	if (countitem(2341) > 0 || countitem(2432) > 0) {
		mes "You have some Legion Plate Armor in your inventory, please drop that in your stash before continuing";
		//mes "你身上带着秘银金属铠甲, 请你把它扔进仓库才能继续";
		close;
	}
	mes "I will lets you pass.";    //mes "我会让你通过.";
	close2;
	warp "place",50,50;
	end;

---------------------------------------

*getequipuniqueid(<equipment slot>{,<char_id>})
*getequipuniqueid(<装备位置>{,<角色编号>})

This function returns the unique ID (as a string) of the item equipped in the equipment slot
specified on the invoking character. If nothing is equipped there, it returns an empty string.
See 'getequipid' for a full list of valid equipment slots.
这个函数会返回关联角色或指定ID角色相关装备位置上物品的独有ID(一个字符串)。如果该位置没有装备，则返回一个空
字符串。参考'getequipid'里列出的可用装备位置常量。

---------------------------------------

*getequipname(<equipment slot>{,<char_id>})
*getequipname(<装备位置>{,<角色编号>})

Returns the jname of the item equipped in the specified equipment slot on the
invoking character, or an empty string if nothing is equipped in that position.
Does the same thing as getitemname(getequipid()). Useful for an NPC to state
what your are wearing, or maybe saving as a string variable.
See 'getequipid' for a full list of valid equipment slots.
返回关联角色指定装备位置上的物品名称(txt版本物品数据库里的jname，yml版本里是Name)，
如果对应位置没有装备，那么将返回一个空字符串。使用getitemname(getequipid())也能达到
相同的目的。可以用来让一个NPC确认你的装备状态，或者作为字符串变量保存。
参考'getequipid'里列出的可用装备位置常量。

        if ( getequipname(EQI_HEAD_TOP) != "" )
	        mes "So you are wearing a " + getequipname(EQI_HEAD_TOP) + " on your head";
			//mes "你头上戴着" + getequipname(EQI_HEAD_TOP) + " 头饰";
	else
	        mes "You are not wearing any head gear";
			//mes "你没有戴着任何头饰。";

---------------------------------------

*getitemname(<item id>)
*getitemname(<aegis item name>)
*getitemname(<物品编号>)
*getitemname(<aegis物品名称>)

Given the database ID number of an item, this function will return the text
stored in the 'Name' field in item_db_*.yml for text version
or 'name_english' field for SQL version.
这个命令将通过物品编号或者aegis物品名称返回该物品在物品数据库里的
名称(yml里的Name: 名称 或者SQL版本里的'name_english'区域)。

---------------------------------------

*getbrokenid(<number>{,<char_id>})
*getbrokenid(<数量>{,<角色编号>})

This function will search the invoking character's inventory for any broken
items, and will return their item ID numbers. Since the character may have
several broken items, 1 given as an argument will return the first one found, 2
will return the second one, etc. Will return 0 if no such item is found.
这个函数将会寻找关联角色或者指定ID角色身上携带的损坏物品并返回物品的独有ID。
一旦角色有些许损坏的物品，1作为参数可以返回第一个检测到的损坏物品，2会返回
第二个，类推。如果没有找到损坏的物品，则返回0。

	// Let's see if they have anything broken:   //让我们看看他们有没有损坏的东西
	if (getbrokenid(1) == 0)
		mes "You don't have anything broken, quit bothering me.";
		//mes "你没有损坏的物品, 不要打扰我快出去.";
	else
	// They do, so let's print the name of the first broken item: //如果有，就让我们把第一个发现的损坏物品的名称显示出来
		mes "Oh, I see you have a broken " + getitemname(getbrokenid(1)) + " here!";
		//mes "哦, 我看到你这里有一个损坏的 " + getitemname(getbrokenid(1)) + " !";
	end;

---------------------------------------

*getequipisequiped(<equipment slot>{,<char_id>})
*getequipisequiped(<装备位置>{,<角色编号>})

This functions will return 1 if there is an equipment placed on the specified
equipment slot and 0 otherwise. For a list of equipment slots
see 'getequipid'. Function originally used by the refining NPCs:
如果指定的装备位置上有装备，这个函数将会返回1，其他情况为0。
参考'getequipid'里列出的可用装备位置常量。该函数原本用于精炼NPC：

    if (getequipisequiped(EQI_HEAD_TOP)) {
        mes "[Refiner]";                                    //   mes "[精炼师傅]";
        mes "That's a fine hat you are wearing there...";   //   mes "你戴着一个不错的帽子...";
        close;
	} else {
		mes "[Refiner]";                                    //   mes "[精炼师傅]";
		mes "Do you want me to refine your dumb head?";     //   mes "要不要我把你的脑袋锻冶得聪明一点啊?";
		close;
	}

---------------------------------------

*getequipisenableref(<equipment slot>{,<char_id>})
*getequipisenableref(<装备位置>{,<角色编号>})

Will return 1 if the item equipped on the invoking character in the specified
equipment slot is refinable, and 0 if it isn't. For a list of equipment slots
see 'getequipid'.
判断关联角色或者指定ID角色相关装备位置的装备是否可以精炼，可以返回1，不能精炼
返回0。参考'getequipid'里列出的可用装备位置常量。

	if (getequipisenableref(EQI_HEAD_TOP)) {
		mes "[Refiner]";                         //    mes "[精炼师傅]";
		mes "Ok I can refine this";              //    mes "Ok我能精炼这个";
		close;
	} else {
		mes "[Refiner]";                         //    mes "[精炼师傅]";
		mes "I can't refine this hat!...";       //    mes "这个帽子我无法精炼!...";
		close;
	}

---------------------------------------

*getequiprefinerycnt(<equipment slot>{,<char_id>})
*getequiprefinerycnt(<装备位置>{,<角色编号>})

Returns the current number of pluses for the item in the specified equipment
slot. For a list of equipment slots see 'getequipid'.
返回指定装备位置的装备精炼度。参考'getequipid'里列出的可用装备位置常量。

Can be used to check if you have reached a maximum refine value, default for
this is +10:
可以用来判定是否达到精炼最大值，默认是+10。 (译注：应该是早期的情况)

	if (getequiprefinerycnt(EQI_HEAD_TOP) < 10)
		mes "I will now upgrade your " + getequipname(EQI_HEAD_TOP);
		//mes "我将精炼你的 " + getequipname(EQI_HEAD_TOP);
	else
		mes "Sorry, it's not possible to refine hats better than +10";
		//mes "抱歉, 无法精炼到高于 +10";
	close;

---------------------------------------

*getequipweaponlv(<equipment slot>{,<char_id>})
*getequipweaponlv(<装备位置>{,<角色编号>})

This function returns the weapon level for the weapon equipped in the specified
equipment slot on the invoking character. For a list of equipment slots see
'getequipid'.
这个函数将会返回关联玩家身上指定武器装备位置的武器等级。
参考'getequipid'里列出的可用装备位置常量。

Only EQI_HAND_L and EQI_HAND_R normally make sense, since only weapons have
a weapon level. You can, however, probably, use this field for other equippable
custom items as a flag or something.
正常只有EQI_HAND_L和EQI_HAND_R有意义，因为只有武器有等级。但是，您也许可以将此字段
用作其他装备上的自定义项标志或其他内容。

If no item is equipped in this slot, or if it doesn't have a weapon level
according to the database, 0 will be returned.
如果这个位置没有装备，或者在数据库里没有设置武器等级，那么将返回0。

Examples:
例子：

// Right hand can only contain a weapon.  //右手只能装备武器
    switch (getequipweaponlv(EQI_HAND_R)) {
      case 1: mes "You are holding a lvl 1 weapon."; break;  //   case 1: mes "你拿着1个 lvl 1 的武器."; break;
      case 2: mes "You are holding a lvl 2 weapon."; break;  //   case 2: mes "你拿着1个 lvl 2 的武器."; break;
      case 3: mes "You are holding a lvl 3 weapon."; break;  //   case 3: mes "你拿着1个 lvl 3 的武器."; break;
      case 4: mes "You are holding a lvl 4 weapon."; break;  //   case 4: mes "你拿着1个 lvl 4 的武器."; break;
      case 5: mes "You are holding a lvl 5 weapon, hm, must be a custom design..."; break;  //  case 5: mes "你拿着1个 lvl 5 的武器,嗯, 一定是自定的..."; break;
      default: mes "Seems you don't have a weapon on."; break;  //  default: mes "你好像没有带着武器."; break;
    }

// Left hand can hold either a weapon or shield.     //左手可以是武器或者盾牌
    if (getequipid(EQI_HAND_R) == 0) {
        mes "Seems you have nothing equipped here.";   //    mes "你这里好像没有装备物品.";
        close;
    }
    switch (getequipweaponlv(EQI_HAND_L)) {
      case 0: mes "You are holding a shield, so it doesn't have a level."; break;    //case 0: mes "你拿着的是盾牌，所以没有等级."; break;
      case 1: mes "You are holding a lvl 1 weapon."; break;  //    case 1: mes "你拿着1个 lvl 1 的武器."; break;
      case 2: mes "You are holding a lvl 2 weapon."; break;  //    case 2: mes "你拿着1个 lvl 2 的武器."; break;
      case 3: mes "You are holding a lvl 3 weapon."; break;  //    case 3: mes "你拿着1个 lvl 3 的武器."; break;
      case 4: mes "You are holding a lvl 4 weapon."; break;  //    case 4: mes "你拿着1个 lvl 4 的武器."; break;
      case 5: mes "You are holding a lvl 5 weapon, hm, must be a custom design..."; break;    //case 5: mes "你拿着1个 lvl 5 的武器,嗯, 一定是自定的..."; break;
    }

---------------------------------------

*getequiparmorlv({<equipment slot>{,<char_id>}})
*getequiparmorlv({<装备槽>{,<角色编码>}})

This function returns the armor level for the item equipped in the specified
equipment slot on the invoking character. For a list of equipment slots see
'getequipid'.
此函数返回调用角色指定装备槽中装备的物品的护甲等级。
有关装备槽的列表，请参阅 "getequipid"。

If no item is equipped in this slot, or if it doesn't have an armor level
according to the database, 0 will be returned.
如果该插槽中没有装备任何物品，或者根据数据库显示该物品没有护甲等级，则返回 0。

    if (getequipid(EQI_ARMOR) == 0) {
        mes "Seems you have nothing equipped here.";
        close;
    }
    switch (getequiparmorlv(EQI_ARMOR)) {
      case 1: mes "You are wearing a lvl 1 armor."; break;
      case 2: mes "You are wearing a lvl 2 armor."; break;
      case 3: mes "You are wearing a lvl 3 armor, hm, must be a custom design..."; break;
    }

---------------------------------------

*getequippercentrefinery(<equipment slot>{,<enriched>,<char_id>})
*getequippercentrefinery(<装备位置>{,<浓缩>,<角色编号>})

This function calculates and returns the percent value chance to successfully
refine the item found in the specified equipment slot of the invoking character
by +1. There is no actual formula, the success rate for a given weapon level of
a certain refine level is found in the db/(pre-)re/refine_db.yml file. For a list of
equipment slots see 'getequipid'.
这个函数会计算并返回关联角色身上指定装备位置的物品精炼 +1的成功率。这里没有实际公式，
给定等级武器的精炼成功率可以在db/(pre-)re/refine_db.yml文件里找到。
参考'getequipid'里列出的可用装备位置常量。

If enriched parameter is set to true, chance to successfully refine the item with
enriched material is returned instead.
如果浓缩参数被设置为true，精炼成功率将会变为使用浓缩材料对应的精炼成功率。

These values can be displayed for the player to see, or used to calculate the
random change of a refine succeeding or failing and then going through with it
(which is what the official NPC refinery scripts use it for)
这些值可以显示给玩家看，或者通过计算一个随机的或失败的变化结果来显示。
(这就是官方精炼脚本NPC使用它的目的)

// This will find a random number from 0 - 99 and if that is equal to or more
// than the value recovered by this command it will go to L_Fail
// 这将会得到一个 0 - 99 的随机数，如果该数大于等于这个命令返回的值，则跳转到
// L_Fail（译注：精炼失败）。
    if (getequippercentrefinery(EQI_HAND_L)<=rand(100)) goto L_Fail;

---------------------------------------

*getequiprefinecost(<equipment slot>,<type>,<information>{,<char id>})
*getequiprefinecost(<装备位置>,<类型>,<信息>{,<角色编号>})

This function returns refine cost for equipment in <equipment slot> based on
passed arguments <type> and <information>.
这个函数返回指定<装备位置>的根据<类型>和<信息>参数传递回来的精炼费用信息。

Valid cost types are:
有效的费用类型是：

REFINE_COST_NORMAL     - For normal refining                 - 普通精炼费用
REFINE_COST_HD         - For refining with HD ores           - 使用强化金属的精炼费用
REFINE_COST_ENRICHED   - For refining with enriched ores     - 使用浓缩金属的精炼费用

This function will return required cost for refining based on <information> argument.
这个函数将会返回基于给定参数<信息>的精炼费用信息。

Valid information types are:
有效的信息类型是：

REFINE_ZENY_COST       - Zeny               - Zeny
REFINE_MATERIAL_ID     - Material Item ID   - 材料的物品编号

This function will return -1 on failure. The function fails if the cost type
is invalid or if there is no item in the equipment slot.
这个函数如果获取信息失败将返回-1。获取信息失败的原因可能是费用类型无效或者
相应的装备位置没有装备。

---------------------------------------

*refineui({<char id>})
*refineui({<角色编号>})

Opens the refine UI for the attached player or the given character id.
给关联玩家或者指定ID的角色开启精炼UI界面。

This feature requires 2016-10-12aRagexeRE or newer.
这个功能需要2016-10-12aRagexeRE及以后的客户端才可使用。

---------------------------------------

*getareadropitem("<map name>",<x1>,<y1>,<x2>,<y2>,<item>)
*getareadropitem("<地图名称>",<x1>,<y1>,<x2>,<y2>,<物品>)

This function will count all the items with the specified ID number lying on the
ground on the specified map within the x1/y1-x2/y2 square on it and return that
number.
这个函数将会对掉落在指定地图的在x1/y1-x2/y2矩形区域里的指定ID物品进行计数。

This is the only function around where a parameter may be either a string or a
number! If it's a number, it means that only the items with that item ID number
will be counted. If it is a string, it is assumed to mean the 'english name'
field from the item database.
最后的<物品>参数可以是字符串或者数字。如果是数字，则代表相应的物品编号。如果是字符串
，则必须使用物品数据库里相应的物品英文名。

---------------------------------------

*getequipcardcnt(<equipment slot>)
*getequipcardcnt(<装备位置>)

This function will return the number of cards that have been compounded onto a
specific equipped item for the invoking character. See 'getequipid' for a list
of possible equipment slots.
这个函数将会返回关联玩家相应装备位置上插入的卡片的数量。
参考'getequipid'里列出的可用装备位置常量列表。

---------------------------------------

*getinventorylist {<char_id>};
*getinventorylist {<角色编号>};

This command sets a bunch of arrays with a complete list of whatever the
invoking character has in their inventory, including all the data needed to
recreate these items perfectly if they are destroyed. Here's what you get:
这个命令将会返回一批数组，里面存有关联玩家物品栏里的完整的物品信息列表，
包括所有需要的物品信息，用来完美地重新建立一个被删除物品。下面是能获取的信息：

@inventorylist_id[]                - array of item ids.                                             - 物品的ID数组.
@inventorylist_idx[]               - array of item inventory index.                                 - 物品清单索引数组。
@inventorylist_amount[]            - their corresponding item amounts.                              - 对应的物品数量.
@inventorylist_equip[]             - on which position the item is equipped (see EQP_* constants)   - 该物品倍装备在哪个位置 (参考 EQP_* 常量)
                                     It will contain 0 if the item is not equipped.                   如果物品没有被装备，则返回0.
@inventorylist_refine[]            - for how much it is refined.                                    - 物品的精炼值.
@inventorylist_identify[]          - whether it is identified.                                      - 物品是否已鉴定.
@inventorylist_attribute[]         - whether it is broken.                                          - 物品是否损坏.
@inventorylist_card1[]             - These four arrays contain card data for the items.             - 这4个数组包含了物品的卡片数据.
@inventorylist_card2[]               These data slots are also used to store names                    这些插卡数据也经常用来存储插在物品上面的卡片/
@inventorylist_card3[]               inscribed on the items, so you can explicitly check              附魔的名称，这样你就可以明确检验玩家是否得到了
@inventorylist_card4[]               if the character owns an item made by a specific                 指定物品制作者做出的物品。(译注：拆卡脚本，
                                     craftsman.                                                       多重附魔脚本经常会用到这个数组返回的物品插卡信息)
@inventorylist_expire[]            - expire time (Unix time stamp). 0 means never expires.          - 失效时间 (Unix时间戳). 0 表示不会失效.
@inventorylist_bound[]             - the bound type of the items (see BOUND_* constants)            - 物品的绑定类型 (参考 BOUND_* 常量)
@inventorylist_enchantgrade[]      - the enchantgrade of the items                                  - 物品的附魔等级
@inventorylist_count               - the number of items in these lists.                            - 在该物品列表里的物品总数.
@inventorylist_option_id1[]        - first array of random option IDs                               - 第一组随机属性 ID
@inventorylist_option_value1[]     - first array of random option values                            - 第一组随机属性值
@inventorylist_option_parameter1[] - first array of random option parameters                        - 第一组随机属性参数
@inventorylist_option_id2[]        - second array of random option IDs                              - 第二组随机属性 ID
@inventorylist_option_value2[]     - second array of random option values                           - 第二组随机属性值
@inventorylist_option_parameter2[] - second array of random option parameters                       - 第二组随机属性参数
@inventorylist_option_id3[]        - third array of random option IDs                               - 第三组随机属性 ID
@inventorylist_option_value3[]     - third array of random option values                            - 第三组随机属性值
@inventorylist_option_parameter3[] - third array of random option parameters                        - 第三组随机属性参数
@inventorylist_option_id4[]        - fourth array of random option IDs                              - 第四组随机属性 ID
@inventorylist_option_value4[]     - fourth array of random option values                           - 第四组随机属性值
@inventorylist_option_parameter4[] - fourth array of random option parameters                       - 第四组随机属性参数
@inventorylist_option_id5[]        - fifth array of random option IDs                               - 第五组随机属性 ID
@inventorylist_option_value5[]     - fifth array of random option values                            - 第五组随机属性值
@inventorylist_option_parameter5[] - fifth array of random option parameters                        - 第五组随机属性参数
@inventorylist_tradable            - Returns if an item is tradable or not (Pass item_trade.txt, bound, and rental restrictions).
                                                                                                    - 返回物品是否可以交易(item_trade.txt里设置的绑定，交易，租赁限制).
@inventorylist_favorite            - Returns if an item is favorite or not                          - 返回项目是否为喜好物

This could be handy to save/restore a character's inventory, since no other
command returns such a complete set of data, and could also be the only way to
correctly handle an NPC trader for carded and named items who could resell them
- since NPC objects cannot own items, so they have to store item data in
variables and recreate the items.
这可以方便地存储/恢复一个角色的物品栏，除此之外没有哪个命令可以返回如此详细的
一组数据，并且也是唯一可以正确处理重新交易已插过卡或者已经命名过物品的NPC的方法，
由于NPC对象不能拥有物品，因此必须将物品的数据以变量形式储存并重新创建出来。

Notice that the variables this command generates are all temporary, attached to
the character, and integer.
注意这个命令产生的那些变量全部都是临时的，关联相关角色的，整数形式的。

Be sure to use @inventorylist_count to go through these arrays, and not
'getarraysize', because the arrays are not automatically cleared between runs
of 'getinventorylist'.
一定要使用@inventorylist_count来遍历这些数组，不要使用'getarraysize'，因为
这些数组不会在下一次使用'getinventorylist'之前自动地清空。

---------------------------------------

*cardscnt()

This function will return the number of cards inserted into the equipment
from which the function is called.
这个函数将会返回调用处装备的插卡数量。

This function is intended for use in item scripts.
这个函数用于物品脚本。

---------------------------------------

*getrefine()

This function will return the refine count of the equipment from which the
function is called.
这个函数将会返回调用处装备的精炼值。

This function is intended for use in item scripts.
这个函数用于物品脚本。

---------------------------------------

*getnameditem(<item id>,"<name to inscribe>"|<char id>);
*getnameditem("<item name>","<name to inscribe>"|<char id>);
*getnameditem(<物品编号>,"<命名的名字>"|<角色编号>);
*getnameditem("<物品名称>","<命名的名字>"|<角色编号>);

This function is equivalent to using 'getitem', however, it will not just give
the character an item object, but will also inscribe it with a specified
character's name. You may not inscribe items with arbitrary strings, only with
names of characters that actually exist. While this isn't said anywhere
specifically, apparently, named items may not have cards in them, slots or no -
these data slots are taken by the character ID who's name is inscribed. Only one
remains free and it's not quite clear if a card may be there.
这个函数和使用'getitem'相同，尽管如此，它不仅仅是给角色一个物品，而是会用指定ID
角色的名字或者给定的命名的名字命名该物品。你不能用任意字符串命名，只能用实际存在
的角色的名字。

This function will return 1 if an item was successfully created and 0 if it
wasn't for whatever reason. Like 'getitem', this function will also accept an
'english name' from the item database as an item name and will return 0 if no
such item exists.
如果物品成功创建则函数返回1，如果失败返回0.如同'getitem'，该函数支持使用物品数据库里的
物品名称'english name'，如果找不到对应物品则返回0。

---------------------------------------

*getitemslots(<item ID>)
*getitemslots(<物品编号>)

This function will look up the item with the specified ID number in the database
and return the number of slots this kind of items has - 0 if they are not
slotted. It will also be 0 for all non-equippable items, naturally, unless
someone messed up the item database. It will return -1 if there is no such item.
这个函数会返回物品数据库里对应ID物品的插孔数，如果没有孔就返回0。
如果是不可装备的物品也会返回0，一般来说是这样，除非有人乱改物品数据库。
如果没有找到相应的物品，则返回-1.

Example:
例子：

//.@slots now has the amount of slots of the item with ID 1205.
//.@slots 的值将会等于ID 1205的物品的插孔数.
	.@slots = getitemslots(1205);

---------------------------------------

*getiteminfo(<item ID>,<type>)
*getiteminfo(<item name>,<type>)
*getiteminfo(<aegis item name>,<type>)
*getiteminfo(<物品编号>,<类型>)
*getiteminfo(<物品名称>,<类型>)
*getiteminfo(<aegis物品名称>,<类型>)

This function will look up the item with the specified ID number in the database
and return the info set by TYPE argument.
It will return -1 if there is no such item or "" if the aegis item name is requested.
这个函数将会根据给定的类型参数，搜寻指定ID物品在物品数据库里的相关信息。
如果没有找到相应物品，则会返回 -1 或者 ""。


Valid types are:
有效的类型是：
	ITEMINFO_BUY             (0)   -  Buy Price                    //  -  买价                               
	ITEMINFO_SELL            (1)   -  Sell Price                   //  -  卖价                               
	ITEMINFO_TYPE            (2)   -  Type                         //  -  物品类型                               
	ITEMINFO_MAXCHANCE       (3)   -  maxchance (max drop chance of this item, e.g. 1 = 0.01%)    //  -  最大掉落率 ( 1 = 0.01%)
		                        if = 0, then monsters don't drop it at all (rare or a quest item) //  = 0, 魔物不会掉落 (稀有品或者任务物品)
		                        if = 10000, then this item is sold in NPC shops only              //  = 10000, 该物品将只能在NPC商店里出售
	ITEMINFO_GENDER          (4)   -  Gender                       //  -  性别                               
	ITEMINFO_LOCATIONS       (5)   -  Location(s)                  //  -  装备位置                               
	ITEMINFO_WEIGHT          (6)   -  Weight                       //  -  重量                               
	ITEMINFO_ATTACK          (7)   -  ATK                          //  -  攻击力                               
	ITEMINFO_DEFENSE         (8)   -  DEF                          //  -  防御力                               
	ITEMINFO_RANGE           (9)   -  Range                        //  -  射程                               
	ITEMINFO_SLOT           (10)   -  Slot                         //  -  孔数                               
	ITEMINFO_VIEW           (11)   -  View                         //  -  外观值                               
	ITEMINFO_EQUIPLEVELMIN  (12)   -  equipment LV                 //  -  装备等级                               
	ITEMINFO_WEAPONLEVEL    (13)   -  weapon LV                    //  -  武器等级                               
	ITEMINFO_ALIASNAME      (14)   -  AliasName                    //  -  别名(译注：会替代原AegisName发送到客户端的另一个AegisName)                               
	ITEMINFO_EQUIPLEVELMAX  (15)   -  equipment LV Max             //  -  最大装备等级                               
	ITEMINFO_MAGICATTACK    (16)   -  matk if RENEWAL is defined   //  -  魔法攻击力(复兴端)                               
	ITEMINFO_ID             (17)   -  item ID                      //  -  物品编号                               
	ITEMINFO_AEGISNAME      (18)   -  aegis item name              //  -  aegis物品名称                               
	
See the sample in 'doc/sample/getiteminfo.txt'.
参考 'doc/sample/getiteminfo.txt'里面的例子.

---------------------------------------

*getequipcardid(<equipment slot>,<card slot>)
*getequipcardid(<装备位置>,<卡片插孔>)

Returns value from equipped item slot in the indicated slot (0, 1, 2, or 3).
从指定装备位置的装备上返回对应序号(0, 1, 2, 或 3)插孔里所插入的卡片ID。

This function returns CARD ID, CARD0_FORGE, CARD0_CREATE, or CARD0_PET (for card 0, if the item is produced).
It's useful for when you want to check whether an item contains cards or if it's signed.
这个函数返回CARD ID, CARD0_FORGE, CARD0_CREATE, 或者 CARD0_PET
用于你想确认指定位置装备上的插卡情况。

---------------------------------------

*mergeitem({,<char_id>});
*mergeitem({,<角色编号>});

Open merge item window to merge available item can be merged.
开启合并物品的窗口以合并可以合并的物品。

Examples
例子
1. See the NPC 'npc/re/other/merge_item.txt'.        //   1. 参考 NPC 'npc/re/other/merge_item.txt'.
2. Simple usage:                                     //   2. 简单的用法:
    mes "Let's check if any item can be merged.";    //       mes "让我们确认一下是否有东西可以合并.";
    close2;                                          //       close2;
    mergeitem;                                       //       mergeitem;
    end;                                             //       end;

---------------------------------------

*mergeitem2({<item_id>{,<char_id>}});
*mergeitem2({"<item name>"{,<char_id>}});
*mergeitem2({<物品编号>{,<角色编号>}});
*mergeitem2({"<物品名称>"{,<角色编号>}});

Merge all stackable items that separated by GUID flags
(either by flag 4 item_flag.txt or GUID  in item_group).
If no item ID/name given, all possible items in player's inventory will be merged.
合并所有被工会标志分离开的可以堆叠的物品。
(item_flag.txt里定义了flag 4或者item_group里的GUILD物品)
如果没有给出物品编号/名称，那么将会合并玩家物品栏里所有可堆叠的物品。

---------------------------------------

*getequiptradability(<equipment slot>{,<char id>});
*getequiptradability(<装备位置>{,<角色编号>});

Returns true if the item in <equipment slot> is tradable.
Returns false otherwise.
如果指定装备位置的物品可以交易，那么返回true，不能就返回false。

---------------------------------------

*identifyall({<type>{,<account_id>}});
*identifyall({<类型>{,<账号id>}});

Returns the count of unidentified items in the player inventory.
If <type> is true the command will identify all the unidentified items as well (default).
If <type> is false the command only returns the count of unidentified items.
返回玩家物品栏里未鉴定物品的数量。
如果<类型>设置为true(默认值)，该命令同时还会鉴定所有未鉴定的物品。
如果<类型>设置为false，该命令只会返回未鉴定物品的数量。

---------------------------------------

*getenchantgrade()

This function will return the enchantgrade of the equipment from which the
function is called.
这个函数将会返回调用处装备的等级

This function is intended for use in item scripts.
这个函数用于物品脚本。

---------------------------------------
//
2,1.- End of item-related commands.      //物品相关命令结束
//
---------------------------------------

*getmapxy("<variable for map name>",<variable for x>,<variable for y>{,<type>,"<search value>"})
*getmapxy("<地图名称变量>",<位置坐标x变量>,<位置坐标y变量>{,<类型>,"<搜索值>"})

This function will locate a character object, NPC object or pet's coordinates
and place their coordinates into the variables specified when calling it. It
will return 0 if the search was successful, and -1 if the parameters given were
not variables or the search was not successful.
这个函数将会搜索并定位一个角色对象，NPC对象或者宠物的坐标，并将他们的位置信息赋值到
调用该函数时指定的变量里。如果搜索成功就返回1，如果搜索失败或者给定的参数不是变量
则会返回 -1。

Type is the type of object to search for:
类型是要搜索的对象类型：

	BL_PC   - Character object (default)     - 角色对象 (默认)
	BL_NPC  - NPC object                     - NPC对象
	BL_PET  - Pet object                     - 宠物对象
	BL_HOM  - Homunculus object              - 生命体对象
	BL_MER  - Mercenary object               - 佣兵对象
	BL_ELEM - Elemental object               - 元素精灵对象

The search value is optional. If it is not specified, the location of the
invoking character will always be returned for types BL_PC and BL_PET,
the location of the NPC running this function for type BL_NPC.
搜索值是可选的。如果没有指定，BL_PC和BL_PET类型通常会返回关联角色(的宠物)的位置信息，
BL_NPC类型则是运行该函数的NPC的位置信息。

If a search value is specified, for types BL_PC and BL_NPC, the
character or NPC with the specified name or GID will be located.
如果指定一个搜索值，BL_PC 或 BL_NPC类型将会定位并返回指定名字或者指定GID
的角色或NPC所在的位置信息。

If type is BL_PET/BL_HOM/BL_MER/BL_ELEM, the search
will locate the current object of the character who's name/GID is given in the
search value, it will NOT locate the object by name.
如果类型是BL_PET/BL_HOM/BL_MER/BL_ELEM，该命令会搜索并定位当前对象所属的
根据搜索值确定的角色(搜索值为角色的名字/GID)。

Example:
例子：

    prontera,164,301,3%TAB%script%TAB%Meh%TAB%730,{                                             //   prontera,164,301,3%TAB%script%TAB%梅%TAB%730,{
        mes "My name is Meh. I'm here so that Nyah can find me.";                               //       mes "我的名字是 梅. 我在这里以便 尼耶 可以找到我.";
        close;                                                                                  //       close;
    }                                                                                           //   }
                                                                                                //  
    prontera,164,299,3%TAB%script%TAB%Nyah%TAB%730,{                                            //   prontera,164,299,3%TAB%script%TAB%尼耶%TAB%730,{
        mes "My name is Nyah.";                                                                 //       mes "我的名字是 尼耶.";
        mes "I will now search for Meh all across the world!";                                  //       mes "我将全世界寻找 梅!";
        if (getmapxy(.@mapname$, .@mapx, .@mapy, BL_NPC, "Meh") != 0) {                         //       if (getmapxy(.@mapname$, .@mapx, .@mapy, BL_NPC, "梅") != 0) {
                mes "I can't seem to find Meh anywhere!";                                       //               mes "我好像到处都找不到 梅!";
                close;                                                                          //               close;
        }                                                                                       //       }
        mes "And I found him on map " + .@mapname$ + " at X:" + .@mapx + " Y:" + .@mapy + " !"; //       mes "我发现他在地图 " + .@mapname$ + " 的坐标 X:" + .@mapx + " 的坐标Y:" + .@mapy + " !";
        close;                                                                                  //       close;
   }                                                                                            //  }

Notice that NPC objects disabled with 'disablenpc' will still be located.
注意：即使NPC对象用'disablenpc'命令关闭后仍然可以被定位。

---------------------------------------

*mapid2name(<map ID>)
*mapid2name(<地图ID>)

Returns the map name of the given map ID. Returns an empty string if given
map ID doesn't exist.
根据给定的地图ID返回对应地图的名称。如果地图ID不存在，则返回空字符串。

---------------------------------------

*getgmlevel({<char_id>})
*getgmlevel({角色编号>})

This function will return the (GM) level associated with the player group to which
the invoking character belongs. If this is somehow executed from a console command,
99 will be returned, and 0 will be returned if the account has no GM level.
这个函数将会返回关联角色所属的角色组别中对应的GM等级。如果这是通过控制台命令执行的，
则会返回99，如果该账号没有GM等级，则返回0。

This allows you to make NPC's only accessible for certain GM levels, or behave
specially when talked to by GMs.
这个可以用来设置对应不同GM级别做出不同响应的NPC，或者GM才能触发的项目。

   if (getgmlevel()) mes "What is your command, your godhood?";
   //if (getgmlevel()) mes "你的命令是什么, 你的权限?";

---------------------------------------

*getgroupid({<char_id>})
*getgroupid({<角色编号>})

This function will return the group id to which the invoking player belongs.
这个函数将会返回关联玩家所属的组别id

---------------------------------------

*gettimetick(<tick type>)
*gettimetick(<时间戳类型>)

This function will return a tick depending on <tick type>:
 0: The server's tick, a measurement in milliseconds used by the server's timer
    system. This tick is an unsigned int which loops every ~50 days.
 1: The time, in seconds, since the start of the current day.
 2: The system time in UNIX epoch time, or the number of seconds elapsed since
    January 1st, 1970. Useful for reliably measuring time intervals.
	
这个函数将会返回根据参数<tick type>要求的时间戳：
 0: 服务器的时间戳，服务器计时器系统使用的以毫秒为单位的测量值。
 1: 时间，以秒为单位，从当日起始点开始计算。
 2: UNIX新纪元时间里的系统时间，或者从1970年1月1日开始到现在历经的秒数。用于可靠地测量时间间隔。

---------------------------------------

*gettime(<type>)
*gettime(<类型>)

This function will return specified information about the current system time.
这个函数将会返回关于当前系统时间的指定信息。

DT_SECOND - Seconds (of the current minute)  //秒 (当前分钟)
DT_MINUTE - Minutes (of the current hour)    //分钟 (当前小时)
DT_HOUR - Hour (of the current day)          //小时 (当前日)
DT_DAYOFWEEK - Week day (constants for MONDAY to SUNDAY are available)  //星期几 (MONDAY 至 SUNDAY的常量可用)
DT_DAYOFMONTH - Day of the current month     // 本月份的第几天
DT_MONTH - Month (constants for JANUARY to DECEMBER are available)  //月份 (JANUARY 至 DECEMBER的常量可用)
DT_YEAR - Year  //年
DT_DAYOFYEAR - Day of the year   //本年的第几天
DT_YYYYMMDD - current date in the form YYYYMMDD   //当前日期，格式YYYYMMDD(译注：YYYY年MM月DD日)

It will only return numbers. If another type is supplied -1 will be returned.
它只会返回数字。如果提供了其他类型将会返回-1。

	if (gettime(DT_DAYOFWEEK) == SATURDAY) mes "It's a Saturday. I don't work on Saturdays.";
	//if (gettime(DT_DAYOFWEEK) == SATURDAY) mes "今天是周六. 我周六不上班.";

---------------------------------------

*gettimestr(<"time format">,<max length>{,<time_tick>})
*gettimestr(<"时间格式">,<最大长度>{,<时间戳类型>})

This function will return a string containing time data as specified by the
time format.
此函数将返回包含时间格式的指定时间数据的字符串。

This uses the C function 'strfmtime', which obeys special format characters. For
a full description see, for example, the description of 'strfmtime' at
http://www.delorie.com/gnu/docs/glibc/libc_437.html
All the format characters given in there should properly work.
Max length is the maximum length of a time string to generate.
这用到遵循特殊的格式字符的C函数'strfmtime'。有关完整说明，请参考:
http://www.delorie.com/gnu/docs/glibc/libc_437.html(译注：可自行搜索C函数strfmtime的用法)
其中给出的所有格式字符都能正常工作。
最大长度 是要生成的时间字符串的最大长度。

The example given in rAthena sample scripts works like this:
rAthena示例脚本中给出的示例如下：

  mes gettimestr("%Y-%m/%d %H:%M:%S",21);

The example above will print the current date and time like 'YYYY-MM/DD HH:MM:SS'.
The following example will print the date and time when the player's VIP status
expires by the given <time_tick>:
上述例子将显示当前日期和时间，格式为'YYYY-MM/DD HH:MM:SS'。(YYYY年-MM月/DD日 HH小时:MM分钟:SS秒)
如果给定<时间戳类型>，下面的例子将会显示关联玩家的VIP到期的日期和时间：

  mes gettimestr("%Y-%m/%d %H:%M:%S",21,vip_status(VIP_STATUS_EXPIRE));

---------------------------------------

*getusers(<type>)
*getusers(<类型>)

This function will return a number of users on a map or the whole server. What
it returns is specified by Type.
这个函数将会返回在一个地图上或者整个服务器的用户数量。返回什么取决于所指定的类型。

Type can be one of the following values, which control what will be returned:
下面是可用的类型，将决定返回什么：

    0 - Count of all characters on the map of the invoking character.     - 计算关联角色所在地图上角色的总数.
    1 - Count of all characters in the entire server.                     - 计算整个服务器中角色的总数.
    8 - Count of all characters on the map of the NPC the script is       - 计算执行该命令的NPC所在地图的角色总数
        running in.                                                         

---------------------------------------

*getmapusers("<map name>")
*getmapusers("<地图名称>")

This function will return the number of users currently located on the specified
map.
这个函数将会返回指定地图当前的用户数量。

This is used officially in PVP scripts to check whether a room is filled to capacity.
这在PVP脚本用于检查房间是否已满。

---------------------------------------

*getareausers("<map name>",<x1>,<y1>,<x2>,<y2>)
*getareausers("<地图名称>",<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>)

This function will return the count of connected characters which are located
within the specified area - an x1/y1-x2/y2 square on the specified map.
这个函数将会返回位于指定地图的指定矩形区域(坐标x1/y1-坐标x2/y2)中角色的数量。

This is useful for maps that are split into many buildings, such as all the
"*_in" maps, due to all the shops and houses.
这经常用于建筑物内部的集成地图中，例如所有那些带"*_in"后缀的地图，用来表示
商店和房间内部的。

---------------------------------------

*getunits(<type>{,<array_variable>[<first value>]})
*getmapunits(<type>,<"map name">{,<array_variable>[<first value>]})
*getareaunits(<type>,<"map name">,<x1>,<y1>,<x2>,<y2>{,<array_variable>[<first value>]})
*getunits(<类型>{,<数组变量>[<首值>]})
*getmapunits(<类型,<"地图名称">{,<数组变量>[<首值>]})
*getareaunits(<类型>,<"地图名称">,<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>{,<数组变量>[<首值>]})

The 'getunits' command will return the number of <type> objects active on the server.
'getunits'命令将会返回服务器上对应<类型>对象的数量。

The 'getmapunits' command will return the number of <type> objects active on the
specified <"map name">.
'getmapunits'命令将会返回指定<"地图名称">上对应<类型>对象的数量。

The 'getareaunits' command will return the number of <type> objects actively located
within the specified area where <x1>, <y1>, <x2>, <y2> form the area.
'getareaunits'命令将会返回指定<"地图名称">上矩形区域<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>
里面对应<类型>对象的数量。

Type is the type of object to search for:
<类型>是要寻找的对象类型：

	BL_PC   - Character objects   //  - 角色对象
	BL_MOB  - Monster objects     //  - 魔物对象
	BL_PET  - Pet objects         //  - 宠物对象
	BL_HOM  - Homunculus objects  //  - 生命体对象
	BL_MER  - Mercenary objects   //  - 佣兵对象
	BL_NPC  - NPC objects         //  - NPC对象
	BL_ELEM - Elemental objects   //  - 元素精灵对象

If <array_variable> is provided:
	- An int variable will return the list of GID.
	- A string variable will return the list of names.
如果可选参数<数组变量>提供了:
	- 一个整数形变量(可自定首值)，将会返回GID列表.
	- 一个字符串变量(可自定首值)，将会返回名字列表.

Example 1:
例子 1：
	// getting the players count and building a string array of the names.
	// 获取玩家的数量并建立一个包含所有人名字的字符串数组.
	.@num = getunits(BL_PC,.@array$[0]);

	mes "the number of Users Connected to the server is " + .@num + " .";  //  mes "连接到服务器上的用户数量有 " + .@num + " .";
	mes "list of Players names :";                                         //  mes "玩家的名字列表 :";
	freeloop(1);	// for if the list was too big.      //防止列表过大
	for(.@i=0;.@i<getarraysize(.@array$);.@i++)
		mes (.@i + 1) + " " + .@array$[.@i];
	freeloop(0);
	end;

Example 2:
例子 2：
	// getting the npc count in Prontera and building a string array of the names.
	//获取普隆德拉地图上npc的数量并建立一个包含所有npc名字的字符串数组.
	.@num = getmapunits(BL_NPC,"prontera",.@array$[0]);

	mes "the number of NPCs in Prontera is " + .@num + " .";   //   mes "在普隆德拉的NPC数量是 " + .@num + " .";
	mes "list of NPCs name :";                                 //   mes "NPC名字列表 :";
	freeloop(1);	// for if the list was too big.       //防止列表过大
	for(.@i=0;.@i<getarraysize(.@array$);.@i++)
		mes (.@i + 1) + " " + .@array$[.@i];
	freeloop(0);
	end;

Example 3:
例子 3：
	// getting the monster count in Prontera with specific coordinates and building a int array of the GIDs.
	//获取普隆德拉地图上指定坐标区域里魔物的数量并建立一个包含所有魔物GID的数组.
	.@num = getareaunits(BL_MOB,"prontera",154,186,159,182,.@array[0]);

	mes "the number of Monsters in Prontera in that Coordinates is " + .@num + " .";  //  mes "在普隆德拉那个区域的魔物数量是 " + .@num + " .";
	mes "list of Monsters GID :";                                                     //  mes "魔物GID列表 :";
	freeloop(1);	// for if the list was too big.     //防止列表过大
	for(.@i=0;.@i<getarraysize(.@array);.@i++)
		mes (.@i + 1) + " " + .@array[.@i];
	freeloop(0);
	end;

---------------------------------------
\\
2,2.- Guild-related commands            //工会相关的命令
\\
---------------------------------------

*getguildname(<guild id>)
*getguildname(<工会id>)

This function returns a guild's name given an ID number. If there is no such
guild, "null" will be returned.
这个函数返回给定工会id的工会的名称。如果没有对应的工会，则返回"null"。

Example:
例子：
	mes "The guild " + getguildname(10007) + " are all nice people.";
	//mes "工会 " + getguildname(10007) + " 全都是不错的人.";

---------------------------------------

*getguildmember <guild id>{,<type>{,<array_variable>}};
*getguildmember <工会id>{,<类型>{,<数组变量>}};

This command will find all members of a specified guild and returns their names
(or character id or account id depending on the value of "type") into an array
of temporary global variables.
这个命令会搜索指定工会的所有成员并返回他们的名字(或者根据<类型>返回id或账号id，)
到一个临时全局变量数组里。

执行此命令时,

$@guildmembername$[] is a global temporary string array which contains all the //   是一个包含所有工会成员名字的临时全局字符串变量。
                     names of these guild members.                             //   
                     (only set when type is 0 or not specified)                //   (当类型设置为 0 或者没有设置)
                                                                                  
$@guildmembercid[]   is a global temporary number array which contains the     //   是一个包含所有工会成员角色编号的临时全局字符串变量。
                     character id of these guild members.                      //   
                     (only set when type is 1)                                 //   (当类型设置为 1)
                                                                                  
$@guildmemberaid[]   is a global temporary number array which contains the     //  是一个包含所有工会成员账号id的临时全局字符串变量。
                     account id of these guild members.                        //  
                     (only set when type is 2)                                 //   (当类型设置为 2)
                                                                                  
$@guildmembercount   is the number of guild members that were found.           //   是搜索到的工会成员总数.

The guild members will be found regardless of whether they are online or offline.
Note that the names come in no particular order.
无论成员是否在线，工会里所有成员都会被搜索到。
请注意，名称没有特定的顺序。

Be sure to use $@guildmembercount to go through this array, and not
'getarraysize', because it is not cleared between runs of 'getguildmember'.
要遍历数组一定要用$@guildmembercount，而不是'getarraysize'，因为在多次使用'getguildmember'
中间数组不会被清空。

If 'array_variable' is set, the result will be stored to that variable instead
using global variable.
如果'数组变量'被设置了，那么结果会被存储进该数组中。

For usage examples, see 'getpartymember'.
使用的例子参考'getpartymember'.

---------------------------------------

*getguildmaster(<guild id>)
*getguildmaster(<工会id>)

This function return the name of the master of the guild which has the specified
ID number. If there is no such guild, "null" will be returned.
这个函数会返回指定工会ID的工会会长的名字。如果没有找到相应工会，则返回"null"。

Example 1:
例子 1：
	// Prints the guild master of guild 10007, whoever that might be.
	// 显示工会10007会长的名字.
	mes getguildmaster(10007) + " runs " + getguildname(10007);

Example 2:
例子 2：
	// Checks if the character is the guild master of the specified guild.
	//确认该角色是不是指定工会的会长
	.@GID = getcharid(2);
	if (.@GID == 0) {
		mes "Sorry, you are not in a guild.";           //mes "抱歉, 你没有加入工会.";
		close;
	}
	if (strcharinfo(0) != getguildmaster(.@GID)) {
		mes "Sorry, you don't own the guild you are in.";   //  mes "抱歉, 你在的这个工会不是你的.";
		close;
	}
	mes "Welcome, guild master of " + getguildname(.@GID);  //   mes "欢迎, 会长 " + getguildname(.@GID);
	close;

---------------------------------------

*getguildmasterid(<guild id>)
*getguildmasterid(<工会id>)

This function will return the character ID number of the guild master of the
guild specified by the ID. 0 if the character is not a guild master of any guild.
这个函数将会返回指定ID工会会长的角色编号。如果没有找到则返回0。

---------------------------------------

*is_guild_leader({<guild ID>})
*is_guild_leader({<工会ID>})

This command will return true if the player attached to the script is the leader
of his/her guild, or, if a guild ID is specified, of that guild.
如果关联玩家是自身所属工会的会长则该命令将会返回true，如果指定了工会ID，
则判断是否是指定工会ID的会长。

---------------------------------------

*getcastlename("<map name>")
*getcastlename("<地图名称>")

This function returns the name of the castle when given the map name for that
castle. The data is read from 'db/castle_db.txt'.
这个函数将会返回<地图名称>对应的工会城堡名字。相关数据参考'db/castle_db.txt'。

---------------------------------------

*getcastledata("<map name>",<type of data>)
*setcastledata "<map name>",<type of data>,<数值>;
*getcastledata("<地图名称>",<数据类型>)
*setcastledata "<地图名称>",<数据类型>,<数值>;

This function returns the castle ownership information for the castle referred
to by its map name. Castle information is stored in `guild_castle` SQL table.
此函数用于返回指定地图名称对应城堡的城堡所有权信息。
城堡信息存储在`guild_castle`SQL表里。

Types of data correspond to `guild_castle` table columns:
数据类型对应于“guild_castle”表里的：

CD_GUILD_ID          - Guild ID.                                                //    - 工会ID.
CD_CURRENT_ECONOMY   - Castle Economy score.                                    //    - 工会发展度.
CD_CURRENT_DEFENSE   - Castle Defense score.                                    //    - 工会防御度.
CD_INVESTED_ECONOMY  - Number of times the economy was invested in today.       //    - 今天的发展度投资次数.
CD_INVESTED_DEFENSE  - Number of times the defense was invested in today.       //    - 今天的防御度投资次数.
CD_NEXT_TIME         - unused                                                   //    - 未使用
CD_PAY_TIME          - unused                                                   //    - 未使用
CD_CREATE_TIME       - unused                                                   //    - 未使用
CD_ENABLED_KAFRA     - Is 1 if a Kafra was hired for this castle, 0 otherwise.  //    - 已雇佣卡普拉为1，其他为0.
CD_ENABLED_GUARDIAN0 - Is 1 if the 1st guardian is present (Soldier Guardian)   //    - 如果已设置了第1个守卫为1 (剑士守卫)
CD_ENABLED_GUARDIAN1 - Is 1 if the 2nd guardian is present (Soldier Guardian)   //    - 如果已设置了第2个守卫为1 (剑士守卫)
CD_ENABLED_GUARDIAN2 - Is 1 if the 3rd guardian is present (Soldier Guardian)   //    - 如果已设置了第3个守卫为1 (剑士守卫)
CD_ENABLED_GUARDIAN3 - Is 1 if the 4th guardian is present (Archer Guardian)    //    - 如果已设置了第4个守卫为1 (弓箭手守卫)
CD_ENABLED_GUARDIAN4 - Is 1 if the 5th guardian is present (Archer Guardian)    //    - 如果已设置了第5个守卫为1 (弓箭手守卫)
CD_ENABLED_GUARDIAN5 - Is 1 if the 6th guardian is present (Knight Guardian)    //    - 如果已设置了第6个守卫为1 (骑士守卫)
CD_ENABLED_GUARDIAN6 - Is 1 if the 7th guardian is present (Knight Guardian)    //    - 如果已设置了第7个守卫为1 (骑士守卫)
CD_ENABLED_GUARDIAN7 - Is 1 if the 8th guardian is present (Knight Guardian)    //    - 如果已设置了第8个守卫为1 (骑士守卫)

All types of data have their meaning determined by War of Emperium scripts,
with exception of:
所有类型的数据的含义均由工会战脚本决定，以下情况除外：
 - CD_GUILD_ID that is always considered ID of the guild that owns the castle,     //   - CD_GUILD_ID 城堡所有者公会的ID,
 - CD_CURRENT_DEFENSE that is used in Guardians & Emperium HP calculations,        //   - CD_CURRENT_DEFENSE 守卫和华丽金属当前的HP量,
 - CD_ENABLED_GUARDIANX that is always considered to hold guardian presence bits.  //   - CD_ENABLED_GUARDIANX 守卫当前位.

The 'setcastledata' command will behave identically, but instead of returning
values for the specified types of accessible data, it will alter them and cause
them to be sent to the char-server for storage.
'setcastledata'用法也一样，但是是用来写入值而不是返回，写入的值会被传输到角色
服务器并储存。

Changing Guild ID or Castle Defense will trigger additional actions, like
recalculating guardians' HP.
改变工会ID或者工会防御将会牵涉到其他属性，例如重新计算守卫的HP。

---------------------------------------

*getgdskilllv(<guild id>,<skill id>)
*getgdskilllv(<guild id>,"<skill name>")
*getgdskilllv(<工会id>,<技能编号>)
*getgdskilllv(<工会id>,"<技能名称>")

This function returns the level of the skill <skill id> of the guild <guild id>.
If the guild does not have that skill, 0 is returned.
If the guild does not exist, -1 is returned.
Refer to 'db/(pre-)re/skill_db.yml' for the full list of skills. (GD_* are guild skills)
这个函数会返回给定工会id给定工会技能编号的等级。
如果工会没有该技能则返回0。如果工会不存在则返回-1。
参考'db/(pre-)re/skill_db.yml'里的工会技能列表。(GD_*前缀的是工会技能)

---------------------------------------

*requestguildinfo <guild id>{,"<event label>"};
*requestguildinfo <工会id>{,"<事件标签>"};

This command requests the guild data from the char server and merrily continues
with the execution. Whenever the guild information becomes available (which
happens instantly if the guild information is already in memory, or later, if it
isn't and the map server has to wait for the char server to reply) it will run
the specified event as in a 'donpcevent' call.
这个命令会从角色服务器请求工会数据并继续执行。当取得工会信息()后将会运行指定标签的事件，
如同使用'donpcevent'命令。

---------------------------------------

*getmapguildusers("<map name>",<guild id>)
*getmapguildusers("<地图名称>",<工会id>)

Returns the amount of characters from the specified guild on the given map.
返回给定地图上指定工会的角色数量。

Example:
例子：

mes "You have " + getMapGuildUsers("prontera",getcharid(2)) + " guild members in Prontera.";
//mes "你有 " + getMapGuildUsers("prontera",getcharid(2)) + " 个工会成员在普隆德拉.";

---------------------------------------
//
2,2.- End of guild-related commands      //工会相关命令结束
//
---------------------------------------

*getskilllv(<skill id>)
*getskilllv("<skill name>")
*getskilllv(<技能编号>)
*getskilllv("<技能名称>")

This function returns the level of the specified skill that the invoking
character has. If they don't have the skill, 0 will be returned. The full list
of character skills is available in 'db/(pre-)re/skill_db.yml'.
这个函数将会返回关联角色的指定技能的等级。如果没有该技能，则返回0。有关角色技能
的完整列表请参考'db/(pre-)re/skill_db.yml'。

There are two main uses for this function, it can check whether the character
has a skill or not, and it can tell you if the level is high enough.
这个函数主要有2种用途，一个是确定关联角色是否有该技能，一个是可以告诉你这个技能
有几级。

Example 1:
例子 1：
	if (getskilllv(152))
		mes "You have got the skill Throw Stone";   //mes "你已学会 投掷石头 技能";
	else
		mes "You don't have Throw Stone";         //mes "你没有学会 投掷石头 技能";
	close;

Example 2:
例子 2：
	if (getskilllv(28) >= 5)
		mes "Your heal lvl is 5 or more";   //mes "你的治愈术等级达到或者超过了5级";
	else if (getskilllv(28) == 10)
		mes "Your heal lvl has been maxed";  //mes "你的治愈术等级满级了";
	else
		mes "You heal skill is below lvl 5";  //mes "你的治愈术等级低于5级";
	close;

---------------------------------------

*getskilllist({<char_id>});
*getskilllist({<角色>});

This command sets a bunch of arrays with a complete list of skills the
invoking character has. Here's what you get:
这个命令会创建一串数组，存储关联角色的技能列表。下面是可以获得的数据：

@skilllist_id[]   - skill ids.                                  //   - 所有技能编号.
@skilllist_lv[]   - skill levels.                               //   - 所有技能等级.
@skilllist_flag[] - see 'skill' for the meaning of skill flags. //   - 技能标志，有关技能标志的含义，请参见'skill'。
@skilllist_count  - number of skills in the above arrays.       //   - 以上这些数组里技能的数量.

While 'getskillv' is probably more useful for most situations, this is the
easiest way to store all the skills and make the character something else for a
while. Advanced job for a day? This could also be useful to see how many
skills a character has.
虽然'getskillv'在大多数情况下可能更有用，但这是存储所有技能并使角色暂时处于某种特殊状态的最简单方法。
例如成为高等级职业一天？这也可以用来确定一个角色拥有多少个技能。


This command does not count skills which are set as flag 4 (permament granted) (ALL_BUYING_STORE/ALL_INCCARRY)
如果技能标志设置为4，则该命令不会计算。(永久技能)(ALL_BUYING_STORE开设采购商店/ALL_INCCARRY负重量上升R)

---------------------------------------
*getrandmobid(<type>{,<flag>{,<level>}})
*getrandmobid(<类型>{,<标志>{,<等级>}})

This command returns a random monster ID from the random monster group.
With <flag> you can apply certain restrictions which monsters of the group can be returned.
Returns 0 if one of the parameters is invalid or no monster could be found with the given parameters.
此命令从随机怪物组中返回一个随机怪物 ID。
使用 <标志>，您可以对可以返回组中哪些怪物施加某些限制。
如果其中一个参数无效或使用给定参数找不到怪物，则返回 0。

Valid <type> are:
有效的<类型>有：
	MOBG_BRANCH_OF_DEAD_TREE
	MOBG_PORING_BOX
	MOBG_BLOODY_DEAD_BRANCH
	MOBG_RED_POUCH_OF_SURPRISE
	MOBG_CLASSCHANGE
	MOBG_TAEKWON_MISSION
	
Valid <flag> are:
有效的<标志>有：
	RMF_NONE            = 0x00 - Apply no flags         无标志
	RMF_DB_RATE         = 0x01 - Apply the summon success chance found in the list (otherwise get any monster from the db)     应用列表中的召唤成功几率（否则从数据库中获取任何怪物）
	RMF_CHECK_MOB_LV    = 0x02 - Apply a monster level check      应用怪物等级检查
	RMF_MOB_NOT_BOSS    = 0x04 - Selected monster should not be a Boss type (default)   所选怪物不应是 Boss 类型（默认值）
	                           - (except those from MOBG_BLOODY_DEAD_BRANCH)    (来自 MOBG_BLOODY_DEAD_BRANCH 的除外）
	RMF_MOB_NOT_SPAWN   = 0x08 - Selected monster must have normal spawn   所选怪物必须有正常产生机制
	RMF_MOB_NOT_PLANT   = 0x10 - Selected monster should not be a Plant type    选择的怪物不应是植物类型
	RMF_ALL             = 0xFF - Apply all flags     应用所有标志
	
---------------------------------------


*getmonsterinfo(<mob ID>,<type>)
*getmonsterinfo(<魔物ID>,<类型>)

This function will look up the monster with the specified ID number in the
mob database and return the info set by TYPE argument.
It will return -1 if there is no such monster (or the type value is invalid),
or "null" if you requested the monster's name.
这个命令将会从魔物数据库里搜索给定魔物ID并返回所指定类型的数据。
如果找不到魔物数据则返回-1(或者使用了不支持的类型)，如果返回类型为魔物名称则返回"null"。

Valid types are:
可用类型有：
	MOB_NAME - monster's name, if there is no such monster "null" is returned             //    MOB_NAME - 魔物的名称，如果找不到魔物返回"null"
	MOB_LV - monster's level                                                              //    MOB_LV - 魔物的等级
	MOB_MAXHP - monster's maximum hp                                                      //    MOB_MAXHP - 魔物的最大HP
	MOB_BASEEXP - monster's base experience                                               //    MOB_BASEEXP - 魔物的基础经验
	MOB_JOBEXP - monster's job experience                                                 //    MOB_JOBEXP - 魔物的职业经验
	MOB_ATK1 - monster's atk                                                              //    MOB_ATK1 - 魔物的物理攻击力1
	MOB_ATK2 - monster's atk2                                                             //    MOB_ATK2 - 魔物的物理攻击力2
	MOB_DEF - monster's def                                                               //    MOB_DEF - 魔物的防御
	MOB_MDEF - monster's mdef                                                             //    MOB_MDEF - 魔物的魔法防御
	MOB_RES - monster's res                                                               //    MOB_RES - 魔物的物理免疫
	MOB_MRES - monster's mres                                                             //    MOB_MRES - 魔物的魔法免疫
	MOB_STR - monster's str                                                               //    MOB_STR - 魔物的力量
	MOB_AGI - monster's agi                                                               //    MOB_AGI -魔物的敏捷
	MOB_VIT - monster's vit                                                               //    MOB_VIT - 魔物的体质
	MOB_INT - monster's int                                                               //    MOB_INT - 魔物的智力
	MOB_DEX - monster's dex                                                               //    MOB_DEX - 魔物的灵巧
	MOB_LUK - monster's luk                                                               //    MOB_LUK - 魔物的幸运
	MOB_RANGE - monster's range                                                           //    MOB_RANGE - 魔物的视野范围
	MOB_RANGE2 - monster's range2                                                         //    MOB_RANGE2 - 魔物的攻击范围2
	MOB_RANGE3 - monster's range3                                                         //    MOB_RANGE3 - 魔物的技能攻击范围3
	MOB_SIZE - monster's size                                                             //    MOB_SIZE - 魔物的体型
	MOB_RACE - monster's race                                                             //    MOB_RACE - 魔物的种族
	MOB_ELEMENT - monster's element(doesn't return the element level, only the element ID)//    MOB_ELEMENT - 魔物的属性(不会返回属性等级，只返回属性ID)
	MOB_MODE - monster's mode                                                             //    MOB_MODE - 魔物的行为模式
	MOB_MVPEXP - monster's mvp experience                                                 //    MOB_MVPEXP - 魔物的MVP经验
	MOB_ID - monster's ID                                                                 //    MOB_ID - 魔物的编号

For more details, see the sample in 'doc/sample/getmonsterinfo.txt'.
更多的细节说明，请参考 'doc/sample/getmonsterinfo.txt'中的例子.

---------------------------------------

*getmobdrops(<mob id>)
*getmobdrops(<魔物id>)

This command will find all drops of the specified mob and return the item IDs
and drop percentages into arrays of temporary global variables.
'getmobdrops' returns 1 if successful and 0 if the mob ID doesn't exist.
这个命令将会找到指定魔物所有掉落物的ID和掉率，并存储在一个临时全局变量数组中。
'getmobdrops'如果执行成功会返回1，如果魔物ID指定的魔物不存在则返回0。

Upon executing this,
执行后返回的数组：

$@MobDrop_item[] is a global temporary number array which contains the   //  一个临时全局变量数字型数组，存储有对应ID魔物掉落的所有物品的ID。
                 item IDs of the monster's drops.                        //  
                                                                         //  
$@MobDrop_rate[] is a global temporary number array which contains the   //  一个临时全局变量数字型数组，存储有对应ID魔物掉落的所有物品的掉率。
                 drop percentages of each item. (1 = .01%)               //   (1 = .01%)
                                                                         //  
$@MobDrop_nosteal[] is a global temporary number array which contains the    一个全局临时数字数组，
                 StealProtected flag of each item. (default false)           其中包含每个项目的 StealProtected 标志。(默认为 false）

$@MobDrop_randomopt[] is a global temporary number array which contains the  一个全局临时数字数组，包含每个项目的随机选项组 ID。(默认为 0）
                 random option group ID of each item. (default 0)
$@MobDrop_count is the number of item drops found.                       //  掉落物的总数.

Be sure to use $@MobDrop_count to go through the arrays, and not
'getarraysize', because the temporary global arrays are not cleared between
runs of 'getmobdrops'. If a mob with 7 item drops is looked up, the arrays would
have 7 elements. But if another mob is looked up and it only has 5 item drops,
the server will not clear the arrays for you, overwriting the values instead. So
in addition to returning the 5 item drops, the 6th and 7th elements from the
last call remain, and you will get 5+2 item drops, of which the last 2 don't
belong to the new mob. $@MobDrop_count will always contain the correct number
(5), unlike 'getarraysize()' which would return 7 in this case.
一定要用$@MobDrop_count来遍历数组而不能使用'getarraysize'，因为所有临时全局变量
在下一次使用'getmobdrops'命令前不会自动清空数组。如果搜索到魔物有7个掉落物，那么
这些数组里就会有7个元素。但是如果你搜索了另一个只有5个掉落物的魔物，那么服务器不会
自动清空之前那个数组，而是将其覆盖，第6、7个元素仍然还是旧的数值。这样新的数组的大小
还是7,但是最后两个元素就不是新魔物的掉落物了。但是$@MobDrop_count总是会给出正确的
魔物掉落物数量(5)，而你用'getarraysize()'的话在这种情况下会返回7。

Example:
例子：

	// get a Mob ID from the user
	// 从用户输入里获取魔物ID
	input .@mob_id;

	if (getmobdrops(.@mob_id)) {	// 'getmobdrops' returns 1 on success   //'getmobdrops'返回1表示已找到相关魔物
		// immediately copy global temporary variables into scope variables, // 立即复制全局随机变量到指定变量
		// since we don't know when 'getmobdrops' will get called again for  //由于我们不知道什么时候'getmobdrops'会再次
		// another mob, overwriting your global temporary variables          //被调用搜索其他魔物，因此创建一个新的变量数组接收
		.@count = $@MobDrop_count;
		copyarray .@item[0],$@MobDrop_item[0],.@count;
		copyarray .@rate[0],$@MobDrop_rate[0],.@count;

		mes getmonsterinfo(.@mob_id,MOB_NAME) + " - " + .@count + " drops found:";  //  mes getmonsterinfo(.@mob_id,MOB_NAME) + " - " + .@count + " 会掉落:";
		for( .@i = 0; .@i < .@count; .@i++ ) {
			mes .@item[.@i] + " (" + getitemname(.@item[.@i]) + ") " + .@rate[.@i]/100 + ((.@rate[.@i]%100 < 10) ? ".0":".") + .@rate[.@i]%100 + "%";
		}
	} else {
		mes "Unknown monster ID.";     //      mes "未知魔物ID.";
	}
	close;

---------------------------------------

*skillpointcount({<char_id>})
*skillpointcount({<角色编号>})

Returns the total amount of skill points a character possesses (SkillPoint+SP's used in skills)
This command can be used to check the currently attached characters total amount of skill points.
This means the skill points used in skill are counted, and added to SkillPoints (number of skill points not used).
This command does not count skills which are set as flag 4 (permament granted) (ALL_BUYING_STORE/ALL_INCCARRY)
返回角色拥有的技能点数总数(剩余技能点数+已加完的技能点数)。
这个命令可以用来确定关联角色当前技能点数总数。
这意味着已加在技能上的点数，加上还未加的技能点数。
这个命令将不会计算flag 4标志的技能(永久技能)(ALL_BUYING_STORE开设采购商店/ALL_INCCARRY负重量上升R)

Example 1:
例子 1：
	.@skillPoints = skillpointcount();
	mes "You have " + .@skillPoints + " skill points in total!";
	//mes "你总共有 " + .@skillPoints + " 点技能点!";

Example 2:
例子 2：
	if (skillpointcount() > 20)
		mes "Wow, you have more then 20 Skill Points in total!";
		//mes "哇, 你已经有超过20点的技能点数了!";

---------------------------------------

*getscrate(<effect type>,<base rate>{,<GID>})
*getscrate(<效果类型>,<基础几率>{,<GID>})

This function will return the chance of a status effect affecting the invoking
character, in percent, modified by the their current defense against said
status. The 'base rate' is the base chance of the status effect being inflicted,
in percent.
这个函数将会返回关联角色的状态效果附加几率，以百分比计，并经过自身状态抗性的修正。
'base rate'是该状态效果附加的基础几率，以百分比计。

    if (rand(100) > getscrate(Eff_Blind, 50)) goto BlindHimNow;

You can see the full list of available effect types you can possibly inflict in
'db/const.txt' under 'Eff_'.
关于可以使用的状态效果完整列表，你可以参考'db/const.txt'里带有'Eff_'前缀的常量。

---------------------------------------

========================
|3.- Checking commands.|            //检查类命令
========================
---------------------------------------

*playerattached()

Returns the ID of the player currently attached to the script. It will return
0 if no one is attached, or if the attached player no longer exists on the map
server. It is wise to check for the attached player in script functions that
deal with timers as there's no guarantee the player will still be logged on
when the timer triggers. Note that the ID of a player is actually their
account ID.
返回当前关联本脚本的玩家ID。如果没人关联或者关联的角色已经从地图服务器登出则返回0。
由于无法保证脚本关联的角色启动计时器后，当计时器到点触发脚本函数的时候，该玩家是否
还在线，这时使用该命令检测是明智的做法。注意ID是玩家实际的账号ID。


---------------------------------------

*getattachedrid();

Returns RID from running script. Script may not be attached to any RID like
a floating script or function and will return 0.
返回当前运行脚本的RID。脚本无法关联任何浮动脚本或者函数，这种情况下会返回0。

---------------------------------------

*isloggedin(<account id>{,<char id>})
*isloggedin(<账号id>{,<角色编号>})

This function returns 1 if the specified account is logged in and 0 if they
aren't. You can also pass the char id to check for both account and char id.
如果指定账号id有在线则返回1，不在线返回0。也可以附加<角色编号>参数以同时确认
账号和该角色编号是否在线。

---------------------------------------

*checkweight(<item id>,<amount>{,<item id>,<amount>,<item id>,<amount>,...});
*checkweight("<item name>",<amount>{,"<item name>",<amount>,"<item name>",<amount>,...});
*checkweight2(<id_array>,<amount_array>);
*checkweight(<物品编号>,<数量>{,<物品编号>,<数量>,<物品编号>,<数量>,...});
*checkweight("<物品名称>",<数量>{,"<物品名称>",<数量>,"<物品名称>",<数量>,...});
*checkweight2(<id数组>,<数量数组>);

These functions will compute and return 1 if the total weight of the specified
number of specific items does not exceed the invoking character's carrying
capacity, and 0 otherwise. It is important to see if a player can carry the
items you expect to give them, failing to do that may open your script up to
abuse or create some very unfair errors.
这些函数将会计算指定数量的指定物品重量之和是否超过关联角色的负重，没超过返回1，
超过返回0。这在使用脚本给玩家物品之前使用，以确认接收物品后是否会导致玩家超重。

The second function will check an array of items and amounts, and also
returns 1 on success and 0 on failure.
带2的命令将会检查一组物品的一组对应数量的总重量，如果没超重返回1，超重返回0。

The functions, in addition to checking to see if the player is capable of
holding a set amount of items, also ensure the player has room in their
inventory for the item(s) they will be receiving.
这些函数不仅能确定玩家的负重是否能接收给定数量的指定物品，还能确认是否会超出玩家
的携带上限。

Like 'getitem', this function will also accept an 'english name' from the
database as an argument.
和'getitem'一样，该函数也支持使用物品的英文名称来作为参数。

Example 1:
例子 1：

	if (checkweight(512,10)) {
		getitem 512,10;
	} else {
		mes "Sorry, you cannot hold this amount of apples!";  //mes "抱歉, 你无法接收这些数量的苹果!";
	}

Example 2:
例子 2：

	setarray .@item[0],512,513,514;
	setarray .@amount[0],10,5,5;
	if (!checkweight2(.@item,.@amount)) {
		mes "Sorry, you cannot hold this amount of fruit!";  //mes "抱歉, 你无法接收这些数量的水果!";
	}

---------------------------------------

*basicskillcheck()

This function will return the state of the configuration option
'basic_skill_check' in 'battle_athena.conf'. It returns 1 if the option is
enabled and 0 if it isn't. If the 'basic_skill_check' option is enabled, which
it is by default, characters must have a certain number of basic skill levels to
sit, request a trade, use emotions, etc. Making your script behave differently
depending on whether the characters must actually have the skill to do all these
things might in some cases be required.'basic_skill_check'
这个函数将会返回'player.conf'(译注：原文是写'battle_athena.conf')配置文件里的
'basic_skill_check'设置项的配置。如果设置为'yes'则返回1，设置'no'则返回0。
本设置的具体效果参考'player.conf'里的说明。

---------------------------------------

*checkoption(<option number>{,<char_id>})
*checkoption1(<option number>{,<char_id>})
*checkoption2(<option number>{,<char_id>})
*setoption <option number>{,<flag>{,<char_id>}};
*checkoption(<状态项数字>{,<角色编号>})
*checkoption1(<状态项数字>{,<角色编号>})
*checkoption2(<状态项数字>{,<角色编号>})
*setoption <状态项数字>{,<标志>{,<角色编号>}};

The 'setoption' series of functions check for a so-called option that is set on
the invoking character. 'Options' are used to store status conditions and a lot
of other non-permanent character data of the yes-no kind. For most common cases,
it is better to use 'checkcart','checkfalcon','checkriding' and other similar
functions, but there are some options which you cannot get at this way. They
return 1 if the option is set and 0 if the option is not set.
'setoption'系列函数用来检测关联玩家身上被附加的状态项。'Options'一般用来存储角色
的状态和其他非永久的角色数据(采用yes-no开关的方式)。在大多数情况下，使用
'checkcart','checkfalcon','checkriding'等函数会更好，但是有些状态项无法用这种方式
取得。如果玩家身上有设施的参数指定的状态则函数返回1，没有则返回0.

Option numbers valid for the first (option) version of this command are:
第一版命令(option)有效的状态项数字为：

0x1       - Sight in effect.                              - 火狩效果.
0x2       - Hide in effect.                               - 隐匿效果.
0x4       - Cloaking in effect.                           - 伪装效果.
0x8       - Cart number 1 present.                        - 当前手推车改装模式1.
0x10      - Falcon present.                               - 当前带鹰.
0x20      - Peco Peco present.                            - 当前骑乘大嘴鸟.
0x40      - GM Perfect Hide in effect.                    - GM完全隐藏模式.
0x80      - Cart number 2 present.                        - 当前手推车改装模式2.
0x100     - Cart number 3 present.                        - 当前手推车改装模式3.
0x200     - Cart number 4 present.                        - 当前手推车改装模式4.
0x400     - Cart number 5 present.                        - 当前手推车改装模式5.
0x800     - Orc head present.                             - 当前兽人头.
0x1000    - The character is wearing a wedding sprite.    - 结婚造型.
0x2000    - Ruwach is in effect.                          - 光猎效果.
0x4000    - Chasewalk in effect.                          - 暗影追踪效果.
0x8000    - Flying or Xmas suit.                          - 飞行或者圣诞装束.
0x10000   - Sighttrasher.                                 - 自动念咒状态？.
0x100000  - Warg present.                                 - 当前骑狼.
0x200000  - The character is riding a warg.               - 骑狼状态.

Option numbers valid for the second version (opt1) of this command are:
第二版命令(opt1)有效的状态项数字为：

1 - Petrified.                                         - 石化.
2 - Frozen.                                            - 冰冻.
3 - Stunned.                                           - 昏迷.
4 - Sleeping.                                          - 睡眠.
6 - Petrifying (the state where you can still walk)    - 石化 (未完全石化还能行走的状态)

Option numbers valid for the third version (opt2) of this command are:
第三版命令(opt2)有效的状态项数字为：

0x1  - Poisoned.          - 中毒.
0x2  - Cursed.            - 诅咒.
0x4  - Silenced.          - 沉默.
0x8  - Signum Crucis (plays a howl-like sound effect, but otherwise no visible effects are displayed) - 天使之光 (只有音效不会显示状态动画的技能)
0x10 - Blinded.           - 暗黑.
0x80 - Deadly poisoned.   - 致命毒素.

Option numbers (except for opt1) are bit-masks - you can add them up to check
for several states, but the functions will return true if at least one of them
is in effect.
状态项数字(除了opt1)都是掩码 - 您可以将它们相加以检查多个状态，不过要检测到其中至少
有一项状态有被附加才返回true。

'setoption' will set options on the invoking character. There are no second and
third versions of this command, so you can only change the values in the first
list (cloak, cart, ruwach, etc). if flag is 1 (default when omitted),
the option will be added to what the character currently has; if 0, the option is removed.
'setoption'将会把状态附加到关联玩家身上。该命令没有第二或者第三版，因此你只能改变第一个
列表里的值(伪装，手推车，光猎，这些)。如果标志设置为1(如果省略的默认值)，则对关联玩家
已有状态中附加该状态，如果0，则移除该状态。

This is definitely not a complete list of available option flag numbers. Ask a
core developer (or read the source: src/map/status.hpp) for the full list.
这绝对不是可用状态项标志的完整列表。询问代码的开发者(或者参考源文件src/map/status.hpp)
以获取完整的列表。

---------------------------------------

*setcart {<type>{,<char_id>}};
*checkcart({<char_id>});
*setcart {<类型>{,<角色编号>}};
*checkcart({<角色编号>});

If <type> is 0 this command will remove the cart from the character.
Otherwise it gives the invoking character a cart. The cart given will be
cart number <type> and will work regardless of whether the character is a
merchant class or not.
注意如果<类型>设置为0则该命令会将角色的手推车移除。其他情况下则会给关联角色
设置一辆手推车。如果设置了<类型>则会给角色一辆手推车，无论角色是否是商人系职业。
Note: the character needs to have the skill MC_PUSHCART to gain a cart
注意：角色必须有手推车使用技能才能使用手推车。

The accompanying function will return 1 if the invoking character has a cart
(any kind of cart) and 0 if they don't.
如果关联角色已经得到手推车则函数还会返回1，如果没有返回0。

    if (checkcart()) mes "But you already have a cart!";   //if (checkcart()) mes "你已经有一辆手推车了!";

---------------------------------------

*setfalcon {<flag>{,<char_id>}};
*checkfalcon({<char_id>});
*setfalcon {<标志>{,<角色编号>}};
*checkfalcon({<角色编号>});

If <flag> is 0 this command will remove the falcon from the character.
Otherwise it gives the invoking character a falcon. The falcon will be there
regardless of whether the character is a hunter or not. It will (probably) not
have any useful effects for non-hunters though.
Note: the character needs to have the skill HT_FALCON to gain a falcon
如果<标志>设置为0则会移除角色的猎鹰。其他情况则会给予角色一只猎鹰。
无论角色是否是猎人都会得到猎鹰，不过可能没什么用处。
注意：角色必须有驯鹰术才能得到猎鹰。

The accompanying function will return 1 if the invoking character has a falcon
and 0 if they don't.
如果关联角色已经得到猎鹰则函数还会返回1，如果没有返回0。

    if (checkfalcon()) mes "But you already have a falcon!";       //if (checkfalcon()) mes "你已经有一只猎鹰了!";

---------------------------------------

*setriding {<flag>{,<char_id>}};
*checkriding({<char_id>});
*setriding {<标志>{,<角色编号>}};
*checkriding({<角色编号>});

If <flag> is 0 this command will remove the mount from the character.
Otherwise it gives the invoking character a PecoPeco (if they are a Knight
series class), a GrandPeco (if they are a Crusader series class), or
a Gryphon (if they are a Royal Guard). Unlike 'setfalcon' and 'setcart'
this will not work at all if they aren't of a class which can ride.
Note: the character needs to have the skill KN_RIDING to gain a mount
如果<标志>设置为0则会移除角色的坐骑。其他情况则会给予角色一只坐骑(骑士系列
为大嘴鸟，十字军系列则是渡渡鸟，皇家卫士则为狮鹫)。不同于'setfalcon'和'setcart'
，如果角色不是有坐骑的职业则无法获得坐骑。
注意：角色必须有骑乘术才能得到坐骑。


The accompanying function will return 1 if the invoking character is riding a
bird and 0 if they aren't.
如果关联角色已经得到坐骑则函数还会返回1，如果没有返回0。

    if (checkriding()) mes "PLEASE leave your bird outside! No riding birds on the floor here!";  //  if (checkriding()) mes "请将你的鸟留在外面! 这里不允许骑鸟!";

---------------------------------------

*setdragon {<color>{,<char_id>}};
*checkdragon({<char_id>});
*setdragon {<颜色>{,<角色编号>}};
*checkdragon({<角色编号>});

The 'setdragon' function toggles mounting a dragon for the invoking character.
It will return 1 if successful, 0 otherwise.
'setdragon'函数会改变关联角色的骑龙状态。如果成功返回1，否则返回0。

The available colors are:
可用的颜色类型是：
 1 - Green Dragon (default)      - 绿龙 (默认)
 2 - Brown Dragon                - 棕龙
 3 - Gray Dragon                 - 灰龙
 4 - Blue Dragon                 - 蓝龙
 5 - Red Dragon                  - 红龙

Note: the character must be a Rune Knight and have the skill RK_DRAGONTRAINING to gain a mount
注意：角色必须是符文其实并且有学习驯龙术才能取得坐骑。

The accompanying function will return 1 if the invoking character is riding a
dragon and 0 if they aren't.
如果关联角色已经得到龙则函数还会返回1，如果没有返回0。

---------------------------------------

*setmadogear {<flag>{,<type>{,<char_id>}}};
*checkmadogear({<char_id>});
*setmadogear {<标签>{,<类型>{,<角色编号>}}};
*checkmadogear({<角色编号>});

If <flag> is false this command will remove the mount from the character.
Otherwise it gives the invoking character a Mado (if they are a Mechanic and have the skill NC_MADOLICENCE).
如果<标签>设置为false则该命令会移除角色的坐骑。
其他情况下则会给关联角色一个魔导器(如果职业是机匠并有魔导机械执照技能)。

When using client version PACKETVER_MAIN_NUM >= 20191120 or PACKETVER_RE_NUM >= 20191106
the <type> flag can be used to specify a specific madogear.
如果使用了 PACKETVER_MAIN_NUM >= 20191120 or PACKETVER_RE_NUM >= 20191106 以上的客户端，
<类型>标签可以用来指定一个特定的魔导器。
Types:
类型：
	MADO_ROBOT (default)     //魔导机械(默认)
	MADO_SUIT                //魔导机械装甲

The accompanying function will return 1 if the invoking character has a
Mado and 0 if they don't.
如果关联角色已经得到魔导器则函数还会返回1，如果没有返回0。

---------------------------------------

*setmounting {<char_id>};
*ismounting({<char_id>});
*setmounting {<角色编号>};
*ismounting({<角色编号>});

The 'setmounting' function toggles cash mount for the invoking character.
It will return 1 if successful, 0 otherwise.
'setmounting'函数将会给关联角色设置一个商城坐骑。

Note: Character must not be mounting a non-cash mount (eg. dragon, peco, wug, etc.)
注意：角色不能处于非商城坐骑状态的骑乘状态(如：骑龙，大嘴鸟，渡渡鸟，等等。)

The accompanying function will return 1 if the invoking character has a
cash mount and 0 if they don't.
如果关联角色已经得到商城坐骑则函数还会返回1，如果没有返回0。

---------------------------------------

*checkwug({<char_id>});
*checkwug({<角色编号>});

This function will return 1 if the invoking character has a
warg and 0 if they don't.
如果关联角色骑狼则这个函数会返回1，如果没有返回0。

---------------------------------------

*checkvending({"<Player Name>"})
*checkvending({"<玩家名字>"})

Checks if the player is vending or has has a buyingstore. Additionally
it gives you the information whether the player uses autotrade or not.
Name is optional, and defaults to the attached player if omitted.
检查玩家是否处于开设采购商店或者售卖商店。另外还会给你玩家是否使用了
离线挂店的信息。名字是可选参数，如果省略默认就对应关联玩家。

The returned value is bitmask of.
返回值是掩码。
  0 = doesn't have a vending or buyingstore (which also means he can't use autotrade)   //没有开设采购商店或者售卖商店(也意味着不会使用离线挂店)
  1 = normal vending            //普通售卖商店
  2 = using @autotrade          //离线挂店中
  4 = has a buyingstore         //有一个采购商店

Examples:
例子：
	//This will check Aaron's state      //这会检测Aaron的状态
	.@state = checkvending("Aaron");
	if (.@state&1)
		mes "Aaron is currently vending!";    //mes "Aaron正在开设售卖商店!"; 
	if (.@state&4)
		mes "Aaron has a buying store!";      //mes "Aaron正在开设采购商店!";
	if (.@state&2)
		mes "Aaron is autotrading!";          //mes "Aaron正在离线挂店!";

---------------------------------------

*checkchatting({"<Player Name>"})
*checkchatting({"<玩家名字>"})

Checks if the player is in a chatroom.
Name is optional, and defaults to the attached player if omitted.
Returns 1 if they are in a chat room, 0 if they are not.
检查玩家是不是在聊天室里。
名字是可选参数，如果省略则默认是关联玩家。
如果在聊天室里就返回1，不在就返回0。

Examples:
例子：
	//This will check if the attached player in a chat room or not.
	//这回检查关联玩家是不是在一个聊天室里
	if (checkchatting())
		mes "You are currently in a chat room!";  //  mes "你目前正在一个聊天室里!";

---------------------------------------

*checkidle({"<Player Name>"})
*checkidle({"<玩家名字>"})

Returns the time, in seconds, that the specified player has been idle.
Name is optional, and defaults to the attached player if omitted.
返回指定玩家发呆的时间，单位是秒。
名字是可选参数，如果省略则默认是关联玩家。

---------------------------------------

*checkidlehom({"<Player Name>"})
*checkidlehom({"<玩家名字>"})

Returns the time, in seconds, that the specified player has been idle for homunculus item/exp share.
Name is optional, and defaults to the attached player if omitted.
This will only work if 'hom_idle_no_share' and 'idletime_hom_option' are enabled (see '/conf/battle/homunc.conf').
返回指定玩家使用生命体挂机(物品/经验)的时间，单位是秒。
名字是可选参数，如果省略则默认是关联玩家。
这个命令只能在'/conf/battle/homunc.conf'配置文件里将'hom_idle_no_share'和'idletime_hom_option'配置设置为启用
才能使用。

---------------------------------------

*checkidlemer({"<Player Name>"})
*checkidlemer({"<玩家名字>"})

Returns the time, in seconds, that the specified player has been idle for mercenary item share.
Name is optional, and defaults to the attached player if omitted.
This will only work if 'mer_idle_no_share' and 'idletime_mer_option' are enabled (see '/conf/battle/drops.conf').
返回指定玩家使用佣兵挂机(物品、经验)的时间，单位是秒。
名字是可选参数，如果省略则默认是关联玩家
这个命令只能在'/conf/battle/drops.conf'配置文件里将'mer_idle_no_share'和'idletime_mer_option'配置设置为启用
才能使用。

---------------------------------------

*agitcheck()
*agitcheck2()
*agitcheck3()

These function will let you check whether the server is currently in WoE:FE mode
(agitcheck()), WoE:SE mode (agitcheck2()), or WoE:TE mode (agitcheck3()) and will
return true if War of Emperium is on and false if it isn't.
这些函数可以检查服务器当前是否处于工会战WoE:FE模式(agitcheck())，或者工会战WoE:SE模式(agitcheck2())
或者工会战WoE:TE模式 (agitcheck3())。如果工会战启动则返回true，关闭则返回false。

---------------------------------------

*isnight()
*isday()

These functions will return 1 or 0 depending on whether the server is in night
mode or day mode. 'isnight' returns 1 if it's night and 0 if it isn't, 'isday'
the other way around. They can be used interchangeably, pick the one you like
more:
这些函数会返回当前服务器是处于白天模式还是夜晚模式(1或0)。'isnight'在处于夜晚
的情况下返回1，否则返回0。'isday'类同。它们可以互换使用，选择你想用的：

    // These two are equivalent:  //这两句是等同的：
    if (isday()) mes "I only prowl in the night.";            //     if (isday()) mes "我只在夜里徘徊.";
    if (isnight() != 1) mes "I only prowl in the night.";     //     if (isnight() != 1) mes "我只在夜里徘徊.";

---------------------------------------

*checkre(<type>)
*checkre(<类型>)

Checks if a renewal feature is enabled or not in renewal.hpp, and returns 1 if
enabled and 0 for disabled.
检查是否在renewal.hpp里是否设置了复兴版的内容。如果启用返回1，关闭返回0。

The renewal feature to check is determined by the number <type>.
<类型>数字决定了要检测的复兴版内容：
 0 - RENEWAL enabled (game renewal server mode)             //0 - RENEWAL 启用 (服务器使用复兴版模式)      
 1 - RENEWAL_CAST (renewal cast time)                       //1 - RENEWAL_CAST (复兴版的咏唱时间)                
 2 - RENEWAL_DROP (renewal drop rate algorithms)            //2 - RENEWAL_DROP (复兴版的物品掉落率算法)     
 3 - RENEWAL_EXP (renewal exp rate algorithms)              //3 - RENEWAL_EXP (复兴版的经验值算法)       
 4 - RENEWAL_LVDMG (renewal level modifier on damage)       //4 - RENEWAL_LVDMG (复兴版的等级伤害模式)
 5 - RENEWAL_ASPD (renewal ASPD)                            //5 - RENEWAL_ASPD (复兴版的攻击速度)                     

---------------------------------------
\\
3,1.- Item-related commands             //物品相关命令
\\
---------------------------------------

*isequipped(<id>{,<id>{,..}})

This function will return 1 if the invoking character has all of the item
IDs given equipped (if card IDs are passed, then it checks if the cards are
inserted into slots in the equipment they are currently wearing). Theoretically
there is no limit to the number of items that may be tested for at the same time.
If even one of the items given is not equipped, 0 will be returned.
如果关联角色有装备参数里给定的全部物品编号则函数会返回1(如果是卡片则检查插了卡的装备
是否有装备在身上)。理论上可以设置的id数量没有限制，命令会同时检测所有物品。
但是只要有1个给定的物品没有装备，则会返回0。

    // (Poring,Santa Poring,Poporing,Marin)    //(波利，圣诞波利，波波利，冰波利)
    if (isequipped(4001,4005,4033,4196)) mes "Wow! You're wearing a full complement of possible poring cards!";
	//if (isequipped(4001,4005,4033,4196)) mes "哇! 你装备了全套的波利卡片!";
    // (Poring)  //波利
    if (isequipped(4001)) mes "A poring card is useful, don't you think?";
	//if (isequipped(4001)) mes "波利卡片很有用,你不觉得是吗?";

The function was meant for item scripts to support the cards released by Gravity
in February 2005, but it will work just fine in normal NPC scripts.
以前这个函数是用在物品脚本中的，不过现在也可以用在普通的NPC脚本里。

---------------------------------------

*isequippedcnt(<id>{,<id>{,..}})

This function is similar to 'isequipped', but instead of 1 or 0, it will return
the amount of item/card equipped that were found on the invoking character from the given list.
这个函数和'isequipped'类似，但不是返回1或者0，而是会返回指定id参数的物品/卡片在关联角色身上装备的数量。

Example:
例子
    if (isequippedcnt(4001,4005,4033,4196) == 5)
		mes "Finally got 5 cards from poring monsters type?";
		//mes "你已经有了5张波利类魔物的卡片?";

---------------------------------------

*checkequipedcard(<card id>)
*checkequipedcard(<卡片id>)

This function will return 1 if the card specified by its item ID number is
inserted into any equipment they have in their inventory, currently equipped or
not.
如果给定卡片id对应的卡片插入装备里并被关联的角色装备在身上，则函数会返回1，否则0。

---------------------------------------
//
3,1.- End of item-related commands     //物品相关命令结束
//
---------------------------------------

==============================
|4.- Player-related commands.|         //玩家相关命令
==============================
---------------------------------------

*attachrid(<account ID>{,force})
*detachrid;
*attachrid(<账号ID>{,force})
*detachrid;

These commands allow the manipulation of the script's currently attached player.
While 'attachrid' allows attaching of a different player by using its account id
for the parameter RID, 'detachrid' makes the following commands run as if the
script was never invoked by a player.
这两个命令可以操控脚本当前对角色的关联。'attachrid'允许脚本通过使用账号ID代替RID参数
关联一个不同的玩家，'detachrid'则可以使脚本如同无关联玩家一样运行。

The command returns false if the player cannot be attached (if the account is offline
or does not exist), and true upon success.
如果玩家无法被关联(如果账号离线或者不存在)该命令会返回false，成功则返回true。

By default the command is executed with force, which causes to attach the player
even if he is currently attached to another script. Since this is not always the
desired behavior you can also specify false to the command and it will only return 
true if the player is online and was not attached to another script.
默认情况下该命令附加force参数运行，即使玩家当前有关联其他脚本也可以强制关联。
由于这并不必要的，您也可以给命令附加参数false，并且仅当玩家在线且未关联其他脚本时，
该命令才会返回true。


---------------------------------------

*addrid(<type>{,<flag>{,<parameters>}});
*addrid(<类型>{,<标志>{,<参数>}});

This command will attach other RIDs to the current script without detaching the
invoking RID. It returns 1 if successful and 0 upon failure.
这个命令会在不取消当前RID关联的情况下关联其他RID到当前的脚本。
如果成功返回1失败返回0。

<type> determines what RIDs are attached:
<类型>决定哪些RID会被关联：
 0: All players in the server.     //所有服务器上的玩家
 1: All players in the map of the invoking player, or the invoking NPC if no player is attached.  //当前关联玩家所在地图上的所有玩家，如果没有关联的玩家则关联NPC。
 2: Party members of a specified party ID.   //指定ID队伍的队伍成员
    [ Parameters: <party id> ]               //[参数: <队伍id>]
 3: Guild members of a specified guild ID.   指定ID工会的工会成员
    [ Parameters: <guild id> ]               //[参数: <工会id>]
 4: All players in a specified area of the map of the invoking player (or NPC).    //当前关联玩家(或NPC)所在地图指定区域的所有玩家
    [ Parameters: <x0>,<y0>,<x1>,<y1> ]      //[ 参数: <坐标x0>,<坐标y0>,<坐标x1>,<坐标y1> ]
 5: All players in the map.                  //所有地图上的玩家
    [ Parameters: "<map name>" ]             //[ 参数: "<地图名称>" ]
 Account ID: If type is Account ID, attach the specified account ID.
 账号ID：如果类型是账号ID，将关联指定的账号ID

<flag> can prevent certain players from being attached:
<标志> 可以防止某些玩家被关联：
 0: Players are always attached. (default)  //   0: 已经被关联的玩家. (默认)
 1: Players currently running another script will not be attached. //  1: 当前已经关联了其他脚本的玩家将不会被关联。

---------------------------------------

*rid2name(<rid>)

Converts rid to name. Note: The player/monster/NPC must be online/enabled.
Good for PCKillEvent where you can convert 'killedrid' to the name of the player.
将rid转换成名字。注意：玩家/魔物/NPC必须在线或者已激活。
一个推荐用法是在PCKillEvent事件中将'killedrid'转换成玩家的名字。

Note: rid2name may not produce correct character names since rid = account id.
      It will return the current online character of the account only.
注意：如果rid = 账号id该命令可能无法正确生成角色名字。它将会返回该账号id当前
      在线的角色的名字。

---------------------------------------

*message "<character name>","<message>";
*message "<角色名字>","<信息>";

That command will send a message to the chat window of the character specified
by name. The text will also appear above the head of that character. It will not
be seen by anyone else.
这个命令会在指定名字的角色头上聊天窗里显示指定的信息。但是其他人不会看到。

---------------------------------------

*dispbottom "<message>"{,<color>{,<char_id>}};
*dispbottom "<信息>"{,<颜色>{,<角色编号>}};

This command will send the given message with color into the invoking character's chat
window. The color format is in RGB (0xRRGGBB). The color is
by default green
这个命令将会发送一条指定颜色的信息到关联角色的聊天窗里。颜色代码为RGB(0xRRGGBB)。默认绿色。

---------------------------------------

*showscript "<message>"{,<GID>, <flag>};
*showscript "<信息>"{,<GID>, <标志>};

Makes attached player or GID says a message like shouting a skill name, the message
will be seen to everyone around but not in chat window.
flag: Specify target
   AREA - Message is sent to players in the vicinity of the source (default).
   SELF - Message is sent only to player attached.
让关联玩家或者GID像喊出技能名称一样发送一条消息，该消息能让周围所有人看见但是不会出现
在聊天输入窗里。
标志：指定目标
   AREA - 信息将会发送到目标周围附近的玩家(默认).
   SELF - 信息将只会发送到关联的玩家.

---------------------------------------

*warp "<map name>",<x>,<y>{,<char id>};
*warp "<地图名称>",<坐标x>,<坐标y>{,<角色编号>};

This command will take the invoking character or <char id>, if specified, to the specified map, and if
wanted, specified coordinates too, but these can be random.
这个命令将会把关联玩家(或者指定<角色编号>)传送到指定的地图，如果需要，还可以
传送到指定的坐标。

	warp "place",50,55;

This would take them to X 50 Y 55 on the map called "place". If your X and Y
coordinates land on an unwalkable map square, it will send the warped character
to a random place. Same will happen if they are both zero:
上述命令将会把玩家传送到"place"地图的坐标X50和坐标Y55处。如果坐标X和Y是个不可
通行的区域，则会传送到随机地点。如果两个坐标都设置为0也会这样。

	warp "place",0,0;

Notice that while warping people to coordinates 0,0 will normally get them into
a random place, it's not certain to always be so. Darned if I know where this is
actually coded, it might be that this happens because square 0,0 is unwalkable
on all official maps. If you're using custom maps, beware.
注意，XY坐标设置为0通常情况下会传送到随机地点，但是也不是完全会这样。实际上，
这是因为在大多数情况下0，0这个坐标是不可通行的。如果你使用了非官方的自制地图，
那么可能会出现例外情况。

There are also three special 'map names' you can use.
"<地图名称>"参数可以有3个特殊名称：

"Random" will warp the player randomly on the current map.
"Save" and "SavePoint" will warp the player back to their save point.
"Random"将会把玩家传送到当前地图的随机位置。
"Save" 和 "SavePoint"将会把玩家传送回他们的储存点。

---------------------------------------

*areawarp "<from map name>",<x1>,<y1>,<x2>,<y2>,"<to map name>",<x3>,<y3>{,<x4>,<y4>};
*areawarp "<起始地图名称>",<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>,"<目标地图名称>",<坐标x3>,<坐标y3>{,<坐标x4>,<坐标y4>};

This command is similar to 'warp', however, it will not refer to the invoking
character, but instead, all characters within a specified area, defined by the
x1/y1-x2/y2 square, will be warped. Nobody outside the area will be affected,
including the activating character, if they are outside the area.
这个命令类似'warp'，但是，不会关联具体角色，而是将所有在指定坐标区域(坐标x1,y1至坐标x2,y2的方形区域)里的玩家
传送。区域外的角色不会被传送，包括关联或启动脚本的角色，只要不在传送的区域内，就不会被传送。

	areawarp "place",10,10,120,120,"place2",150,150;

Everyone that is in the area between X 10 Y 10 and X 120 Y 120, in a square
shape, on the map called "place", will be affected, and warped to "place2" X 150
Y 150
所有在地图"place"矩形区域X 10 Y 10 至 X 120 Y 120的玩家，都会被传送到动图"place2"
的坐标X 150 Y 150处。

	areawarp "place",10,10,120,120,"place2",0,0;

By using ,0,0; as the destination coordinates it will take all the characters in
the affected area to a random set of co-ordinates on "place2".
如果目的地坐标设置为,0,0，则全部作用角色将会传送到"place2"的随机位置。

	areawarp "place",10,10,120,120,"place2",150,150,200,200;

By using the optional x4 and y4 parameters, the destination coordinates will be a
random place within the defined x3/y3-x4/y4 square.
如果设置了可选参数坐标x4和y4，那么目的地的坐标将会在x3/y3-x4/y4的方形区域内。

Like 'warp', areawarp will also explicitly warp characters randomly into the
current map if you give the 'to map name' as "Random".
类似'warp'，areawarp命令如果传送的目的地设置为"Random"，则会传送到当前地图的随机位置。

See also 'warp'.
其他参考'warp'.

---------------------------------------

*warpparty "<to_mapname>",<x>,<y>,<party_id>,{"<from_mapname>",<range x>,<range y>};
*warpparty "<目标地图名称>",<坐标x>,<坐标y>,<队伍id>,{"<起始地图名称>",<范围x>,<范围y>};

Warps a party to specified map and coordinate given the party ID, which you can get with
getcharid(1). You can also request another party id given a member's name with getcharid(1,<player_name>).
传送一个给定ID的队伍到指定地图的坐标，也可以用getcharid(1)获取关联玩家的队伍id。
你也可以通过给定一个队员名称，然后使用命令getcharid(1,<玩家名称>)获取其他队伍的id作为参数。

You can use the following "map names" for special warping behavior:
你可以使用下面的"地图名称"来指定特殊的传送目的地：
Random:       All party members are randomly warped in their current map (as if they   //   全部队员传送到当前地图的随机位置(如同使用苍蝇翅膀)
              all used a fly wing)                                                        
SavePointAll: All party members are warped to their respective save point.             //   全部队员传送到他们各自的储存点
SavePoint:    All party members are warped to the save point of the currently          //   全部队员传送到当前关联角色的储存点(如果
              attached player (will fail if there's no player attached).               //   没有玩家关联将会失败)
Leader:       All party members are warped to the leader's position. The leader must   //   全部队员传送到队长的位置。队长必须在线。
              be online and in the current map-server for this to work.                   
RandomAll:    All party members are warped to the same random position in their current map  所有组队队员都会被传送到当前地图中的同一随机位置

If you specify a from_mapname, 'warpparty' will only affect those on that map.
如果给定了起始地图名称，'warpparty'将只会作用于该地图。

The <range x> and <range y> optional values allow for a randomization with the
player's warp point. The values will randomly add or subtract from the given <x>
and <y> coordinates.
如果设置了可选参数的<范围x>,<范围y>，则会传送到目标地图坐标的<范围x>,<范围y>随机
范围(以目的地坐标为中心，<范围x>,<范围y>为半径的矩形区域中)。

Example:
例子：
	mes "[Party Warper]";                     //    mes "[队伍传送员]";
	mes "Here you go!";                       //    mes "你要去这里!";
	close2;                                   //    close2;
	.@party_id = getcharid(1);                //    .@party_id = getcharid(1);
	warpparty "prontera",150,100,.@party_id;  //    warpparty "prontera",150,100,.@party_id;
	close;                                    //    close;

---------------------------------------

*warpguild "<map name>",<x>,<y>,<guild_id>;
*warpguild "<地图名称>",<坐标x>,<坐标y>,<工会id>;

Warps a guild to specified map and coordinate given the guild id, which you can get with
getcharid(2). You can also request another guild id given the member's name with getcharid(2,<player_name>).
传送一个给定ID的工会成员到指定地图的坐标，也可以用getcharid(2)获取关联玩家的工会id。
你也可以通过给定一个工会成员名称，然后使用命令getcharid(2,<玩家名称>)获取其他工会的id作为参数。

You can use the following "map names" for special warping behavior:
你可以使用下面的"地图名称"来指定特殊的传送目的地：
Random:       All guild members are randomly warped in their current map (as if they      //   全部工会成员传送到当前地图的随机位置(如同使用苍蝇翅膀)
              all used a fly wing)                                                           
SavePointAll: All guild members are warped to their respective save point.                //   全部工会成员传送到他们各自的储存点
SavePoint:    All guild members are warped to the save point of the currently             //   全部工会成员传送到当前关联角色的储存点(如果
              attached player (will fail if there's no player attached).                  //   没有玩家关联将会失败)
                                                                                         
Example:
例子：

warpguild "prontera",x,y,Guild_ID;

---------------------------------------

*warppartner("<map name>",<x>,<y>);
*warppartner("<地图名称>",<坐标x>,<坐标y>);

This function will find the invoking character's marriage partner, if any, and
warp them to the map and coordinates given. It will return 1 upon success and
0 if the partner is not online, the character is not married, or if there's no
invoking character (no RID). 0,0 will, as usual, normally translate to random coordinates.
这个函数会寻找关联角色的配偶，如果有的话，并将他们传送到给定的地图和坐标。
如果成功则返回1，如果配偶不在线，或者角色没有结婚，或者没有关联角色(没有RID)则返回0。
如果坐标设置为0,0,则一般会传送到随机坐标。

---------------------------------------

*savepoint "<map name>",<x>,<y>{,{<range x>,<range y>,}<char_id>};
*save "<map name>",<x>,<y>{,{<range x>,<range y>,}<char_id>};
*savepoint "<地图名称>",<坐标x>,<坐标y>{,{<范围 x>,<范围 y>,}<角色编号>};
*save "<地图名称>",<坐标x>,<坐标y>{,{<范围 x>,<范围 y>,}<角色编号>};

These commands save where the invoking character will return to upon clicking
"Return to Save Point", after death and in some other cases. The two versions are
equivalent. They ignore any and all mapflags, and can make a character respawn where
no teleportation is otherwise possible.
这两个命令会设置关联玩家的储存点，在死亡后点击了"回到储存点"或者使用蝴蝶翅膀以后返回。
这两个版本的命令是相同的。无视任何地图标签。

The <range x> and <range y> optional values allow for a randomization with the
player's save point. The values will randomly add or subtract from the given <x>
and <y> coordinates.
<范围 x>,<范围 y>是可选参数，如果设置了会将储存点设置为一个以<坐标x>,<坐标y>为中心，
<范围 x>,<范围 y>为半径的矩形区域。玩家返回时会随机出现在这个区域内。

	savepoint "place",350,75;
	savepoint "place",350,75,2,2; // Randomly save the character between 348,73 and 352,77
                                  // 角色存储点设置为 348,73 和 352,77之间的随机位置
---------------------------------------

*heal <hp>,<sp>{,<char_id>};
*heal <血量>,<魔法值>{,<角色编号>};

This command will heal a set amount of HP and/or SP on the invoking character.
这个命令恢复关联角色或者给定ID角色指定数量的血量或者魔法值。

	heal 30000,0; // This will heal 30,000 HP              // 恢复30,000 血量
	heal 0,30000; // This will heal 30,000 SP              // 恢复 30,000 魔法值
	heal 300,300; // This will heal 300 HP and 300 SP      // 恢复 300 血量 和 300 魔法值

This command just alters the hit points and spell points of the invoking
character and produces no other output whatsoever.
这个命令只会改变关联角色的血量和魔法值而不会输出其他数据。

---------------------------------------

*healap <ap>{,<char_id>};

This command will heal a set amount of AP on the invoking character.
该命令将治疗调用角色身上一定量的 AP。

	healap 10;  // This will give 10 AP    加10AP
	healap -10; // This will remove 10 AP  减10AP

This command just alters the activity points of the invoking
character and produces no other output whatsoever.
该命令只是更改调用角色的活动点数，不产生任何其他输出。

---------------------------------------

*itemheal <hp>,<sp>{,<char_id>};
*itemheal <血量>,<魔法值>{,<角色编号>};

This command heals relative amounts of HP and/or SP on the invoking character.
Unlike heal, this command is intended for use in item scripts. It applies
potion-related bonuses, such as alchemist ranking, cards, and status changes.
When used inside an NPC script, certain bonuses are omitted.
这个命令会恢复关联玩家或者指定ID玩家的给定数量的血量或者魔法值。
和heal不同，这个命令用于物品脚本。它应用于药剂相关的奖励，例如炼金排名，卡片，
和属性改变。当用于NPC脚本里，某些奖励会被省略。

The command also applies a SP/VIT-related bonus:
该命令也应用于魔法值/体质-相关的奖励：
	heal = heal * [(100 + STATUS*2) / 100]

Example:
例子：
	// If the player has 50 vit and no bonuses, this will heal      // 如果玩家体质是50并且没有其他奖励, 下面命令会恢复
	// anything from 200 to 300 HP and 5 SP                         // 200到3000的血量和5魔法值。
	itemheal rand(100,150),5;

---------------------------------------

*percentheal <hp>,<sp>{,<char_id>};
*percentheal <血量>,<魔法值>{,<角色编号>};

This command will heal the invoking character. It heals the character, but not
by a set value - it adds percent of their maximum HP/SP.
这个命令用来恢复关联角色一定比例的血量/魔法值。

	percentheal 100,0; // This will heal 100% HP               // 恢复100%的血量
	percentheal 0,100; // This will heal 100% SP               // 恢复100%的魔法值
	percentheal 50,50; // This will heal 50% HP and 50% SP     // 恢复50%血量和50%魔法值

So the amount that this will heal will depend on the total amount of HP or SP
you have maximum. Like 'heal', this will not call up any animations or effects.
那么，这将会根据你血量和魔法值最大值来决定恢复量的占比。和'heal'一样，这个命令
执行时不会有任何动画和效果。

---------------------------------------

*recovery <type>{,<option>,<revive_flag>{,<map name>}};
*recovery <类型>{,<选项>,<复活标志>{,<地图名称>}};

This command will revive and fully restore the HP/SP of the selected characters.
It returns 1 upon successful use.
这个命令会将所选角色复活并回满血量和魔法值。如果成功则返回1。

<type> is the target, and determines the <option> parameter:
<类型>即是目标的类型，并决定了<选项>里的参数
 0: Player  -> Character ID number                   //   0: 玩家   -> 角色编号
 1: Party   -> Party ID number                       //   1: 队伍   -> 队伍ID
 2: Guild   -> Guild ID number                       //   2: 工会   -> 工会ID
 3: Map     -> Map name (a string)                   //   3: 地图   -> 地图名称 (字符串)
 4: All     -> None (takes <revive_flag> as option)  //   4: 全部   -> 无 (将<复活标志>作为选项)

If no option is specified, the invoking player's character ID, party ID, guild ID,
or map will be used.
如果可选参数<选项>没有设置，则关联玩家的角色编号，队伍ID，工会ID或者所在地图将被对应使用。

<revive_flag> determines the action:
<恢复标志> 决定了效果：
 1: Revive and heal all players (default)       //复活并回复所有玩家(默认)
 2: Heal living players only                    //只回复活着的玩家
 4: Revive dead players only                    //只复活死亡玩家

<map name> can optionally be used to define a single map to execute the command on
for types 1 (party) and 2 (guild).
<地图名称> 是可选参数，在类型为1(玩家)和2(工会)时用来定义执行该命令的地图。

Examples:
例子：
	// Only revive characters in invoking party on map "morocc"      // 只在梦罗克地图复活关联队伍里的玩家
	recovery 1,getcharid(1),4,"morocc";

	// Fully heal (don't revive) all members of invoking character's guild    //完全回复(不复活)所有关联角色工会里的成员
	recovery 2,getcharid(2),2;

	// Revive and fully heal everyone in map "prontera"    //复活并回复普隆德拉上所有人
	recovery 3,"prontera";

	// Only revive all dead characters on server    //只复活服务器上所有死亡的角色
	recovery 4,4;

---------------------------------------

*jobchange <job number>{,<upper flag>,<char_id>};
*jobchange <职业编号>{,<扩展标签>,<角色编号>};

This command will change the job class of the invoking character.
这个命令会改变关联角色的职业种类。

	jobchange 1; // This would change your player into a Swordman    //会将玩家变成剑士
	jobchange 4002; // This would change your player into a Swordman High    //会将玩家变成高级剑士

This command does work with numbers, but you can also use job names. The full
list of job names and the numbers they correspond to can be found in
'src/map/script_constants.hpp'.
这个命令设置的职业使用数字编号，到那时也可以用职业名称。职业名称和编号的对应清参考
'src/map/script_constants.hpp'。

	// This would change your player into a Swordman     //会将玩家变成剑士
	jobchange Job_Swordman;
	// This would change your player into a Swordman High   //会将玩家变成高级剑士
	jobchange Job_Swordman_High;

'upper flag' can alternatively be used to specify the type of job one changes
to. For example, jobchange Job_Swordman,1; will change the character to a high
swordsman. The upper values are:
<扩展标签>可选，用来指定变更的职业类型。例如，jobchange Job_Swordman,1;这个语句会
将角色改变为高级剑士。扩展值可以指定为：
-1 (or when omitted): preserves the current job type.   //   -1 (或者省略): 保留当前职业类型.
0: Normal/standard classes                              //   0: 普通/基本 类型
1: High/Advanced classes                                //   1: 高级/高等 类型
2: Baby classes                                         //   2: 宝宝 类型

This command will also set a permanent character-based variable
'jobchange_level' which will contain the job level at the time right before
changing jobs, which can be checked for later in scripts.
这个命令也可以设置一个基于角色的永久变量'jobchange_level'，包含了变更职业
时该角色的当前职业等级，可以在后期的脚本中使用。

---------------------------------------

*jobname(<job number>)
*jobname(<职业编号>)

This command retrieves the name of the given job using the map_msg entries 550->655.
这个命令会检索给定职业编号所对应的名称并用地图信息550->655条发信息给你。

	mes "[Kid]";                                                                 //    mes "[小孩]";
	mes "I never thought I'd met a " + jobname(Class) + " here of all places.";  //    mes "我没想到居然会在这遇见一个 " + jobname(Class) + " 。";
	close;                                                                       //    close;

---------------------------------------

*eaclass({<job number>,<char_id>})
*eaclass({<职业编号>,<角色编号>})

This commands returns the "eA job-number" corresponding to the given class, and
uses the invoking player's class if none is given. The eA job-number is also a
class number system, but it's one that comes with constants which make it easy
to convert among classes. The command will return -1 if you pass it a job number
which doesn't have an eA job-number equivalent.
这个命令返回给定职业类型对应的"eA职业编号"，如果没有给定职业类型则对应当前调用角色的职业。
eA职业编号也是一种职业类型系统，采用常量表示职业类型。如果给定的职业编号没有对应
的eA职业编号，则返回-1。

	.@eac = eaclass();
	if ((.@eac&EAJ_BASEMASK) == EAJ_SWORDMAN)
		mes "Your base job is Swordman.";     //mes "你的基础职业是剑士.";
	if (.@eac&EAJL_UPPER)
		mes "You are a rebirth job.";
	if ((.@eac&EAJ_UPPERMASK) == EAJ_SWORDMAN)
		mes "You must be a Swordman, Baby Swordman or High Swordman.";   //mes "你一定是一个剑士，宝宝剑士或者高级剑士。";

For more information on the eA Job System, see the docs/ea_job_system.txt file.
请参阅docs/ea_job_system.txt文件以获得更多的关于eA职业系统的相关信息。

---------------------------------------

*roclass(<job number>{,<gender>})
*roclass(<职业编号>{,<性别>})

Does the opposite of eaclass. That is, given an eA job-number, it returns the
corresponding RO class number. A gender is required because both Bard and Dancers
share the same eA job-number (EAJ_BARDDANCER), and uses the invoking player's
gender if none is given (if no player is attached, male will be used by default).
The command will return -1 if there is no valid class to represent the specified
job (for example, if you try to get the baby version of a Taekwon class).
和eaclass相反。即是，给定一个eA职业编号，将会返回对应的RO职业编号。性别参数是用来
区分诗人和舞娘(因为这两个职业的eA职业编号都是EAJ_BARDDANCER)，如果没有设定该参数
则采用调用角色的性别(如果没有角色关联，则采用默认的男性)。如果没有与给定职业相对应
的有效职业种类则该命令会返回-1(例如，跆拳职业返回宝宝类型)。

	.@eac = eaclass();
	//Check if class is already rebirth   //检查职业类型是否是已经转生的
	if (.@eac&EAJL_UPPER) {
		mes "You look strong.";           //mes "你看上去很强壮.";
		close;
	}
	.@eac = roclass(.@eac|EAJL_UPPER);    
	//Check if class has a rebirth version     //检查职业是有转生类型
	if (.@eac != -1) {
		mes "Bet you can't wait to become a " + jobname(.@eac) + "!";    //mes "你无法转职成为 " + jobname(.@eac) + "!";
		close;
	}

---------------------------------------

*changebase <job ID number>{,<account ID>};
*changebase <职业ID编号>{,<账号ID>};

This command will change a character's appearance to that of the specified job
class. Nothing but appearance will change.
这个命令会改变一个角色的外观为指定的职业类型。仅变更外观而不改变其他东西。

The command will run for the invoking character unless an account ID is given.
除非给定账号ID，否则命令只作用于调用角色。

	changebase Job_Novice; // Changes player to Novice sprite.    // 将玩家变更为初学者外观.
	changebase Class; // Changes player back to default sprite.   // 将玩家变回原来的职业外观.

---------------------------------------

*classchange(<view id>{,"<NPC name>","<flag>"});
*classchange(<外观值>{,"<NPC名称>","<标志>"});

This command is very ancient, its origins are clouded in mystery.
It will send a 'display id change' packet to everyone in the immediate area of
the NPC object, which will supposedly make the NPC look like a different sprite,
an NPC sprite ID, or a monster ID. This effect is not stored anywhere and will
not persist (Which is odd, cause it would be relatively easy to make it do so)
and most importantly, will not work at all since this command was broken with
the introduction of advanced classes. The code is written with the assumption
that the lowest sprite IDs are the job sprites and the anything beyond them is
monster and NPC sprites, but since the advanced classes rolled in, they got the
ID numbers on the other end of the number pool where monster sprites float.
这个命令非常古老，它的起源已无从考证。
它会向所有NPC周围所有在场的人发送一个'改变显示id'封包，以此改变NPC的外观，
可以是NPC的外观ID，或者是魔物的ID。这个效果不会存储在任何地方并且不是永久性的。
(译注：仅当玩家在视野内时接收到这个命令发送的封包才能看到外观变化，视野外的
玩家或者离开视野后，效果就会消失。)

As a result it is currently impossible to call this command with a valid view
id. It will do nothing whatsoever if the view ID is below 4047. Getting it to
run will actually just crash the client.

It could be a real gem if it can be gotten to actually do what it's supposed to
do, but this will only happen in a later SVN revision.

Empty <NPC name> means attached NPC.
<NPC名称>放空表示关联的NPC。

Target for <flag>:
<标志>的目标是：
- bc_area : Sprite is sent to players in the vicinity of the source (default value).  //可视范围内的玩家(默认)
- bc_self : Sprite is sent only to player attached.      //只对关联玩家显示

---------------------------------------

*changesex({<char_id>});
*changesex({<角色编号>});

This command will change the gender for the attached character's account. If it
was male, it will become female, if it was female, it will become male. The
change will be written to the character server, the player will receive the
message: "Need disconnection to perform change-sex request..." and the player
will be immediately kicked to the login screen. When they log back in, they will
be the opposite sex.
这个命令会改变关联角色账号的性别。如果是男性，则会变为女性，如果是女性，则会
变为男性。该变化会被写入角色服务器，玩家会受到信息：“需要断开连接以执行更改性别请求...”
然后玩家会立即下线并退回连接画面。当重新连接后，将会变为相对的性别。

If there are any Dancer/Gypsy or Bard/Clown characters on the account,
they will also have their skills reset upon 'changesex'.
如果该账号上有舞娘/冷艳舞姬或者吟游诗人/搞笑艺人，则将重新设置技能。

---------------------------------------

*changecharsex({<char_id>});
*changecharsex({<角色编号>});

This command will change the gender of the attached character. If it
was male, it will become female, if it was female, it will become male. The
change will be written to the character server, the player will receive the
message: "Need disconnection to perform change-sex request..." and the player
will be immediately kicked to the login screen. When they log back in, they will
be the opposite sex.
这个命令会改变关联角色的性别。如果是男性会变为女性，如果是女性会变为男性。
该变化会被写入角色服务器，玩家会受到信息：“需要断开连接以执行更改性别请求...”
然后玩家会立即下线并退回连接画面。当重新连接后，将会变为相对的性别。

If the character being changed is a Dancer/Gypsy or Bard/Clown class type,
the character will also have their skills reset upon 'changecharsex'.
如果角色是舞娘/冷艳舞姬或者吟游诗人/搞笑艺人，则将重新设置技能。

---------------------------------------

*getexp <base_exp>,<job_exp>{,<char_id>};
*getexp <基础经验>,<职业经验>{,<角色编号>};

This command will give the invoking character a specified number of base and job
experience points. Used for a quest reward. Negative values won't work.
这个命令会给调用角色一个指定数值的基础或者职业经验点数。用于任务的奖励。
负值不能使用。

The EXP values are adjustted by 'quest_exp_rate' config value, VIP bonus, Guild
Tax and EXP boost items such Battle Manual, Bubble Gum, or items that have
SC_EXPBOOST or SC_ITEMBOOST.
获得的经验值会经过'quest_exp_rate'设置，VIP奖励，工会精炼缴纳，经验倍增物品的修正。

	getexp 10000,5000;

---------------------------------------

*getexp2 <base_exp>,<job_exp>{,<char_id>};
*getexp2 <基础经验>,<职业经验>{,<角色编号>};

This command is safety version of 'set' command for BaseExp and JobExp. If using
'set' while the BaseExp or JobExp value is more than 2,147,483,647 (INT_MAX) will
causing overflow error.
这个命令是一个比用'set'命令改变基础和职业经验更安全的版本。如果使用'set'则当基础经验
或者职业经验大于2,147,483,647(整形数值的最大允许值)就会发生溢出错误。

Unlike 'getexp', this command ignores the adjustment factors!
和'getexp'不同，此命令忽略调整系数！

---------------------------------------

*getbaseexp_ratio(<percent>{,<base_level>{,char_id});
*getbaseexp_ratio(<百分比>{,<基础等级>{,角色编号});

Returns the amount of base experience representing the given <percent> of the
required base experience at <base_level>. If no base level is specified the base
level of the attached character will be used.
返回<基础等级>下所需基础经验的<百分比>。如果没有指定基础等级，
则将使用关联角色的基础等级。

---------------------------------------

*getjobexp_ratio(<percent>{,<job_level>{,char_id});
*getjobexp_ratio(<百分比>{,<职业等级>{,角色编号});

Returns the amount of job experience representing the given <percent> of the
required job experience at <job_level>. If no job level is specified the job
level of the attached character will be used.
返回<职业等级>下所需职业经验的<百分比>。
如果没有指定职业等级，则将使用关联角色的职业等级。

---------------------------------------

*setlook <look type>,<look value>{,<char_id>};
*changelook <look type>,<look value>{,<char_id>};
*setlook <形象类型>,<形象值>{,<角色编号>};
*changelook <形象类型>,<形象值>{,<角色编号>};

'setlook' will alter the look data for the invoking character. It is used
mainly for changing the palette used on hair and clothes: you specify which look
type you want to change, then the palette you want to use. Make sure you specify
a palette number that exists/is usable by the client you use.
'changelook' works the same, but is only client side (it doesn't save the look value).
'setlook'会改变调用角色的形象数据。主要用于改变发型和服装的染色：你可以指定你要改变的形象值，
然后是你要使用的染色。要保证你指定的染色编号在你使用的客户端存在并可用。
'changelook'类似，但是只作用于客户端(形象值不会被保存)。

	// This will change your hair color, so that it uses palette 8, what ever your
	// palette 8 is, your hair will use that color
	//这会改变你的发色，故使用8号色板，不管你的8号色板是什么，你的头发都会被染成对应颜色。

	setlook LOOK_HAIR_COLOR,8;

	// This will change your clothes color, so they are using palette 1, whatever
	// your palette 1 is, your clothes will then use that set of colors.
	//这会改变你的衣服颜色，故使用1号色板，不管你的1号色板是什么，你的衣服都被染成对应颜色。

	setlook LOOK_CLOTHES_COLOR,1;

Here are the possible look types:
这些是能使用的形象类型：

 LOOK_BASE - Base sprite               //基础外形图块
 LOOK_HAIR - Hairstyle                 //发型
 LOOK_WEAPON - Weapon                  //武器
 LOOK_HEAD_BOTTOM - Head bottom        //头下
 LOOK_HEAD_TOP - Head top              //头上
 LOOK_HEAD_MID - Head mid              //头中
 LOOK_HAIR_COLOR - Hair color          //发色
 LOOK_CLOTHES_COLOR - Clothes color    //衣服颜色
 LOOK_SHIELD - Shield                  //盾牌
 LOOK_SHOES - Shoes                    //鞋子
 LOOK_BODY2 - Body style               //身体外形

Whatever 'shoes' means is anyone's guess, ask Gravity - the client does nothing
with this value. It still wants it from the server though, so it is kept, but
normally doesn't do a thing.
鞋子外观设置当前仅是保留值，没有任何实际作用。


Only the look data for hairstyle, hair color and clothes color are saved to the
char server's database and will persist. Body style will also persist if 'save_body_style'
configuration is enabled in '/conf/battle/client.conf'. The rest freely change as the character
puts on and removes equipment, changes maps, logs in and out and otherwise you
should not expect to set them. In fact, messing with them is generally
hazardous, do it at your own risk, it is not tested what will this actually do -
it won't cause database corruption and probably won't cause a server crash, but
it's easy to crash the client with just about anything unusual.
只有发型，发色和衣服的染色和外观数据会被永久储存到角色服务器的数据库中。身体的造型如果在'/conf/battle/client.conf'
中的'save_body_style'配置项中启用，则也会被永久保存。其余的可以通过角色变更装备，更换地图，出入游戏
而变更，除此之外你无法永久变更。实际上，变更这些有一定风险，需要自行评估，有因数据库混乱
和客户端因异常而造成的崩溃。

However, it might be an easy way to quickly check for empty view IDs for
sprites, which is essential for making custom headgear.
尽管如此，这是是一个简单快捷的检查空外观ID的途径，是制作自定义头饰的必不可少的方法。

Since a lot of people have different palettes for hair and clothes, it's
impossible to tell you what all the color numbers are. If you want a serious
example, there is a Stylist script inside the default rAthena installation that
you can look at: 'npc/custom/stylist.txt'
由于有很多人有各种各样不同的头发和服装色板，因此无法告诉你有全部的颜色代码。如果你
想要一个例子，可以参考rAthena自带脚本 'npc/custom/stylist.txt'里的造型师。

---------------------------------------

*pushpc <direction>,<cells>;
*pushpc <方向>,<区格>;

This command will push the currently attached player to given direction by given
amount of square cells. Direction is the same as used when declaring NPCs, and
can be specified by using one of the DIR_* constants (src/map/script_constants.hpp).
这个命令会将当前关联角色向指定方向推开给定数量的区格。方向的设置方法同NPC，并且可以
使用DIR_*开头的常量(src/map/script_constants.hpp)。

The knock-back is not restricted by items or map flags, only obstacles are taken
into account. If there is not enough space to perform the push (e.g. due to a
wall), the character is pushed only up to the obstacle.
击退不受物品或地图标志的限制，只考虑障碍物。如果没有足够的空间可以被推开(例如，碰到
围墙)，角色将只被推到紧靠障碍物的位置。

	// pushes the character 5 cells in 3 o'clock direction from its
	// current position.
	//将角色从当前位置推向3点方向5个区格处。
	pushpc DIR_EAST, 5;

---------------------------------------

*recalculatestat;

This command will force a stat recalculation for the attached player.
此命令将强制重新计算玩家附加的状态。

---------------------------------------

*needed_status_point(<type>,<val>{,<char id>});
*needed_status_point(<类型>,<值>{,<角色编号>});

Returns the number of stat points needed to change the specified stat <type> by <val>.
If <val> is negative, returns the number of stat points that would be needed to
raise the specified stat from (current value - <val>) to current value.
返回需要多少<值>的素质点数才可达到指定的状态<类型>。
如果<值>为负数，则返回将指定的状态从（当前值 - <值>）提升到当前值所需的素质点数。


---------------------------------------

*jobcanentermap("<mapname>"{,<JobID>});
*jobcanentermap("<地图名称>"{,<职业ID>});

Return true if player (decided by job) can enter the map, false otherwise.
如果玩家当前的职业可以进入该地图，则返回true，否则返回false。

For optional 'JobID', see constant of Job_*, or use player's Class, BaseJob,
and BaseClass. If no player is attached, this param must have a value.
可选参数<职业ID>参考Job_*常量，或者使用玩家的职业种类，基础职业，或者基础职业类别。
如果无玩家关联，则此参数必须设置值。

See also db/[pre-]re/job_noenter_map.txt
参考db/[pre-]re/job_noenter_map.txt(译注：限制职业进入的地图列表)

---------------------------------------

*get_revision()

This command will return the SVN revision number that the server is currently
running on.
这个命令会返回当前运行中的服务器的SVN版本号。

	if (get_revision() >= 15000)
		mes "Welcome to rAthena!";

---------------------------------------

*get_githash()

This command will return the Git Hash that the server is currently running on.
这个命令会返回当前运行中的服务器的Git Hash。

	mes "Welcome to rAthena! Git Hash: " + get_githash();

---------------------------------------
\\
4,1.- Item-related commands            //物品相关命令
\\
---------------------------------------

*getitem <item id>,<amount>{,<account ID>};
*getitem "<item name>",<amount>{,<account ID>};
*getitem <物品编号>,<数量>{,<账号ID>};
*getitem "<物品名称>",<数量>{,<账号ID>};

This command will give an amount of specified items to the invoking character.
If an optional account ID is specified, and the target character is currently
online, items will be created in their inventory instead. If they are not
online, nothing will happen.
这个指令将会给调用的角色指定数量的指定物品。如果可选参数账号ID给定，并且目标角色
当前在线，物品就会在他的物品栏里被创建。如果不在线，则什么都不会发生。

In the first and most commonly used version of this command, items are
referred to by their database ID number found inside 'db/item_db.yml'.
在该命令的第一个也是最常用的版本中，物品的ID来自数据库'db/item_db.yml'里面。

	getitem 502,10 // The person will receive 10 apples    //取得10个苹果
	getitem 617,1  // The person will receive 1 Old Violet Box    //取得10个神秘紫箱

This transaction is logged if the log script generated transactions option is
enabled.
如果启用“记录脚本生成的事件”选项，则会记录此事件。

You may also create an item by its name in the 'english name' field in the
item database:
你也可以用物品数据库里的物品名称来创建物品。

	getitem "RED_POTION",10;   //取得10个红色药水

Which will do what you'd expect. If it can't find that name in the database,
apples will be created anyway. It is often a VERY GOOD IDEA to use it like this.
如果名称没有在数据库里找到，则会创建出苹果。


This is used in pretty much all NPC scripts that have to do with items and
quite a few item scripts. For more examples check just about any official script.
这在几乎所有与物品有关的NPC脚本中都会使用。相关例子可以从任何官方脚本中查到。

---------------------------------------

*getitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*getitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*getitem3 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitem3 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitem4 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitem4 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitem2 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*getitem2 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*getitem3 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*getitem3 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*getitem4 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*getitem4 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};

This command will give an amount of specified items to the invoking character.
If an optional account ID is specified, and the target character is currently
online, items will be created in their inventory instead. If they are not
online, nothing will happen. It works essentially the same as 'getitem' but is
a lot more flexible.
这个命令将给予调用角色给定数量的指定物品。如果可选参数账号ID有指定，并且目标角色
当前在线，物品将会在他的物品栏里被创建。如果不在线，则什么都不会发生。基本上和'getitem'
用法一样，但是灵活很多。

Those parameters that are different from 'getitem' are:
这些和'getitem'的参数不同的有：

identify    - Whether you want the item to be identified (1) or not (0).    //鉴定  - 物品是否已鉴定(已鉴定为1，未鉴定为0)
refine      - For how many pluses will it be refined.                       //精炼  - 精炼度，不能超过最大精炼值
              It will not let you refine an item higher than the max refine.
attribute   - Whether the item is broken (1) or not (0).                    //损坏  - 物品是否损坏(损坏为1，未损坏为0)
card1,2,3,4 - If you want a card compound to it, place the card ID number into   //卡片1,2,3,4  - 插卡位置1，2，3，4，参数为卡片ID
              the specific card slot.

Card1-card4 values are also used to store name information for named items, as
well as the elemental property of weapons and armor. You can create a named item
in this manner, however, if you just need a named piece of standard equipment,
it is much easier to the 'getnameditem' function instead.
卡片1-卡片4的值也可以用来存储命名物品的名字信息，也可以是武器或者装甲的属性。你可以
用这种方式创建一个命名物品，尽管如此，如过你只是要创建一个普通的命名物品，
用'getnameditem'命令会更好。

You will need to keep these values if you want to destroy and then perfectly
recreate a named item, for this see 'getinventorylist'.
如果你要移除然后再完整重建一个命名物品，你将需要保存这些值，请参考'getinventorylist'。

If you still want to try creating a named item with this command because
'getnameditem' won't do it for you cause it's too limited, you can do it like
this. Careful, minor magic ahead.
如果你仍然要用这个命令创建一个命名物品，由于'getnameditem'的限制，你可以参考如下例子。

	// First, let's get an ID of a character who's name will be on the item.   //首先，获取要命名的角色名字对应的角色编号
	// Only an existing character's name may be there.                         //只有存在的角色名字可以使用
	// Let's assume our character is 'Adam' and find his ID.                   //假定角色的名字是'Adam'并找到他的ID
	.@charid = getcharid(0,"Adam");

	// Now we split the character ID number into two portions with a binary    //现在，我们使用二进制移位操作将字符ID号分成两部分。
	// shift operation. If you don't understand what this does, just copy it.  //如果你不清楚这些用来做什么，就复制过去就好。
	.@card3 = .@charid & 65535;
	.@card4 = .@charid >> 16;

	// If you're inscribing non-equipment, .@card1 must be 254.                //如果要命名的是非装备，.@card1必须是254
	// Arrows are also not equipment.                                          //箭矢也不是装备
	.@card1 = 254;

	// For named equipment, card2 means the Star Crumbs and elemental          //命名装备的卡片2表示制作该装备使用的星星的角和属性石。
	// crystals used to make this equipment. For everything else, it's 0.      //其他情况则是0。
	.@card2 = 0;

	// Now, let's give the character who invoked the script some               //现在，给予调用这个脚本的角色一个带有Adam名字的苹果
	// Adam's Apples:
	getitem2 512,1,1,0,0,.@card1,.@card2,.@card3,.@card4;

This wasn't tested with all possible items, so I can't give any promises,
experiment first before relying on it.
由于未测试全部可能类型的物品，因此使用前要先进行测试。

To create equipment, continue this example it like this:
创建装备物品，参考以下例子：

	// We've already have card3 and card4 loaded with correct      //上面例子已经取得了卡片3和卡片4的正确值   
	// values so we'll just set up card1 and card2 with data       //因此我们只要设置卡片1和卡片2的数据
	// for an Ice Stiletto.                                        //来获得一把冰属性双刃短剑

	// If you're inscribing equipment, .@card1 must be 255.        //如果你要命名装备，.@card1必须是255。
	.@card1 = 255;

	// That's the number of star crumbs in a weapon.               //这是武器使用的星星的角的数量
	.@sc = 2;

	// That's the number of elemental property of the weapon.      //这是武器的属性编号
	.@ele = 1;

	// And that's the wacky formula that makes them into           //这是一个古怪的公式，使它们成为一个单一的数字。
	// a single number.
	.@card2 = .@ele+((.@sc*5)<<8);

	// That will make us an Adam's +2 VVS Ice Stiletto:            //制造出一个2级强悍Adam制造的冰属性双刃短剑
	getitem2 1216,1,1,2,0,.@card1,.@card2,.@card3,.@card4;

Experiment with the number of star crumbs - I'm not certain just how much will
work most and what it depends on. The valid element numbers are:
星星之角的最大数量未经测试。有效的属性编号为：

 1 - Ice, 2 - Earth 3 - Fire 4 - Wind.
 1 - 水, 2 - 土 3 - 火 4 - 风.

You can, apparently, even create duplicates of the same pet egg with this
command, creating a pet which is the same, but simultaneously exists in two
eggs, and may hatch from either, although, I'm not sure what kind of a mess will
this really cause.
甚至可以用这个命令创建一个相同的宠物蛋的复制品，被创建的宠物相同，但是同时存在于
这两个蛋，并可以从任何一个中孵化，虽然，我不确定这到底会造成什么样的混乱。

'getitem3' is advance version of 'getitem2' that also use Item Random Option as additional values.
<RandomIDArray>    : Array variable of ID for item random option, see db/[pre-]re/item_randomopt_db.txt
<RandomValueArray> : Array variable of item random option's value.
<RandomParamArray> : Array variable of item random option's param.
'getitem3' 是比'getitem2'更高版本的可以使用物品随机属性作为附加值的命令。
<随机属性ID数组>    : 物品随机属性ID的变量数组, 参考db/[pre-]re/item_randomopt_db.txt
<随机属性值数组> : 物品随机属性值的变量数组.
<随机属性参数数组> : 物品随机属性参数的变量数组.
'getitem4' is advance version of 'getitem3' that also use the grade as additional values.
getitem4 "是 "getitem3 "的高级版本，也使用级别作为附加值。
Valid grades are:
有效级别为：
	ENCHANTGRADE_NONE		- No grade        无级别
	ENCHANTGRADE_D			- Grade D         级别D
	ENCHANTGRADE_C			- Grade C         级别C
	ENCHANTGRADE_B			- Grade B         级别B
	ENCHANTGRADE_A			- Grade A         级别A


Example to get Crimson Weapon with Ghost property:
创建念属性绯红色大驹短剑的例子：
	// +9 Crimson Dagger [2]
	setarray .@OptID[0],RDMOPT_WEAPON_ATTR_TELEKINESIS;
	setarray .@OptVal[0],0;
	setarray .@OptParam[0],0;
	getitem3 28705,1,1,9,0,0,0,0,0,.@OptID,.@OptVal,.@OptParam;

---------------------------------------

*getitembound <item id>,<amount>,<bound type>{,<account ID>};
*getitembound "<item name>",<amount>,<bound type>{,<account ID>};
*getitembound <物品编号>,<数量>,<绑定类型>{,<账号ID>};
*getitembound "<物品名称>",<数量>,<绑定类型>{,<账号ID>};

This command behaves identically to 'getitem', but the items created will be
bound to the target character as specified by the bound type. All items created
in this manner cannot be dropped, sold, vended, auctioned, or mailed, and in
some cases cannot be traded or stored.
这个命令和'getitem'用法的效果相似，但是创建出来的物品会按指定类型绑定目标角色。
用此方法创建出来的物品不能丢弃，卖出，出售，拍卖或者邮寄，并且在一些情况下
不能交易和存仓。

Valid bound types are:
有效的绑定类型是：
 Bound_Account : Account Bound item        : 绑定账号
 Bound_Guild   : Guild Bound item          : 绑定工会
 Bound_Party   : Party Bound item          : 绑定队伍
 Bound_Char    : Character Bound item      : 绑定角色

---------------------------------------

*getitembound2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>{,<account ID>};
*getitembound2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>{,<account ID>};
*getitembound3 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitembound3 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitembound4 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitembound4 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<bound type>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*getitembound2 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<绑定类型>{,<账号ID>};
*getitembound2 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<绑定类型>{,<账号ID>};
*getitembound3 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<绑定类型>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*getitembound3 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<绑定类型>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*getitembound4 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<绑定类型>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*getitembound4 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<绑定类型>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};


This command behaves identically to 'getitem2', but the items created will be
bound to the target character as specified by the bound type. All items created
in this manner cannot be dropped, sold, vended, auctioned, or mailed, and in
some cases cannot be traded or stored.
这个命令和'getitem2'用法和效果相似，不过创建出来物品会按指定类型邦迪目标角色。
用此方法创建出来的物品不能丢弃，卖出，出售，拍卖或者邮寄，并且在一些情况下
不能交易和存仓。

For a list of bound types see 'getitembound'.
绑定类型参考'getitembound'.

'getitembound3' is advance version of 'getitembound2' that also use Item Random Option as additional values.
<RandomIDArray>    : Array variable of ID for item random option, see db/[pre-]re/item_randomopt_db.txt
<RandomValueArray> : Array variable of item random option's value.
<RandomParamArray> : Array variable of item random option's param.
'getitembound3' 是比'getitembound2'更高版本的可以使用物品随机属性作为附加值的命令。
<随机属性ID数组>    : 物品随机属性ID的变量数组, 参考db/[pre-]re/item_randomopt_db.txt
<随机属性值数组> : 物品随机属性值的变量数组.
<随机属性参数数组> : 物品随机属性参数的变量数组.

'getitembound4' is advance version of 'getitembound3' that also use the grade as additional values.
getitembound4 "是 "getitembound3 "的进阶版，也使用级别作为附加值。
Valid grades are:
有效级别为：
	ENCHANTGRADE_NONE		- No grade      无级别
	ENCHANTGRADE_D			- Grade D       级别D
	ENCHANTGRADE_C			- Grade C       级别C
	ENCHANTGRADE_B			- Grade B       级别B
	ENCHANTGRADE_A			- Grade A       级别A


Example to get Crimson Weapon with Ghost property:
创建绑定角色的念属性绯红色大驹短剑的例子：
	// +9 Crimson Dagger [2]
	setarray .@OptID[0],RDMOPT_WEAPON_ATTR_TELEKINESIS;
	setarray .@OptVal[0],0;
	setarray .@OptParam[0],0;
	getitembound3 28705,1,1,9,0,0,0,0,0,BOUND_CHAR,.@OptID,.@OptVal,.@OptParam;

---------------------------------------

*getnameditem <item id>,<character name|character ID>;
*getnameditem "<item name>",<character name|character ID>;
*getnameditem <物品编号>,<角色名字|角色编号>;
*getnameditem "<物品名称>",<角色名字|角色编号>;

Create an item signed with the given character's name.
创建一个带有给定角色名字的物品。

The command returns 1 when the item is created successfully, or 0 if it fails.
Failure occurs when:
- There is no player attached.
- Item name or ID is not valid.
- The given character ID/name is offline.
如果物品创建成功该名令返回1，失败返回0.
失败发生原因有：
- 没有玩家关联。
- 物品名字或者ID不存在。
- 给定ID/名字的角色不在线。

Example:
例子：

//This will give the currently attached player a Aaron's Apple (if Aaron is online).
//这将会给予当前关联玩家一个带有'Aaron'名字的苹果(如果Aaron有在线)
	getnameditem "Apple","Aaron";

//Self-explanatory (I hope).
//获取物品并输出成功信息。
	if (getnameitem("Apple","Aaron")) {
		mes "You now have a Aaron's Apple!";
	}

---------------------------------------

*rentitem <item id>,<time>{,<account_id>};
*rentitem "<item name>",<time>{,<account_id>};
*rentitem <物品编号>,<时间>{,<账号id>};
*rentitem "<物品名称>",<时间>{,<账号id>};

Creates a rental item in the attached character's inventory. The item will expire
in <time> seconds and be automatically deleted. When receiving a rental item,
the character will receive a message in their chat window. The character will
also receive warning messages in their chat window before the item disappears.
在关联角色的物品栏里创建一个租赁物品。经过<时间>(秒)到期后会自动删除。当取得一个
租赁物品时，角色的信息栏里会收到一个消息。物品到期前角色还会在信息栏里收到到期
警告。

When rentals expire it will call the OnUnequip Script of the item. This can be used
for special cases such as removing a status change or resetting a variable or state
of the player.
当租赁到期后会调用卸除装备脚本。以移除该装备临时附加的状态素质等加成。

This command can not be used to rent stackable items. Rental items cannot be
dropped, traded, or placed in guild storage. (i.e. trade mask 67)
Note: 'delitem' in an NPC script can still remove rental items.
Note: 'countitem' will not count any item with a rental timer. Use 'rentalcountitem' instead.
这个命令不能用来租赁可堆叠的物品。
注意：NPC脚本中的'delitem'命令仍然可以删除租赁物品。
注意：'countitem'不会将任何租赁物品记入数量。取而代之的是'rentalcountitem'命令。

---------------------------------------

*rentitem2 <item id>,<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account_id>};
*rentitem2 "<item name>",<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account_id>};
*rentitem3 <item id>,<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account_id>};
*rentitem3 "<item name>",<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account_id>};
*rentitem4 <item id>,<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account_id>};
*rentitem4 "<item name>",<time>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account_id>};
*rentitem2 <物品编号>,<时间>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号id>};
*rentitem2 "<物品名称>",<时间>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号id>};
*rentitem3 <物品编号>,<时间>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性变量数组>{,<账号id>};
*rentitem3 "<物品名称>",<时间>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性变量数组>{,<账号id>};
*rentitem4 <物品编号>,<时间>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性变量数组>{,<账号id>};
*rentitem4 "<物品名称>",<时间>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性变量数组>{,<账号id>};


Creates a rental item in the attached character's inventory. The item will expire
in <time> seconds and be automatically deleted. See 'rentitem' for further details.
在关联角色的物品栏里创建一个租赁物品。经过<时间>(秒)到期后会自动删除。
更多详情请参考'rentitem'。

See 'getitem2' for an explanation of the expanded parameters.
有关扩展参数的说明，请参见“getitem2”。

'rentitem3' is advance version of 'rentitem2' that also use Item Random Option as additional values.
<RandomIDArray>    : Array variable of ID for item random option, see db/[pre-]re/item_randomopt_db.txt
<RandomValueArray> : Array variable of item random option's value.
<RandomParamArray> : Array variable of item random option's param.
'rentitem3' 是比'rentitem2'更高版本的可以使用物品随机属性作为附加值的命令。
<随机属性ID数组>    : 物品随机属性ID的变量数组, 参考db/[pre-]re/item_randomopt_db.txt
<随机属性值数组> : 物品随机属性值的变量数组.
<随机属性参数数组> : 物品随机属性参数的变量数组.

'rentitem4' is advance version of 'rentitem3' that also use the grade as additional values.
'rentitem4'是 'rentitem3'的高级版本，也使用等级作为附加值。
Valid grades are:
有效级别为：
	ENCHANTGRADE_NONE		- No grade       无级别
	ENCHANTGRADE_D			- Grade D        级别D
	ENCHANTGRADE_C			- Grade C        级别C
	ENCHANTGRADE_B			- Grade B        级别B
	ENCHANTGRADE_A			- Grade A        级别A

Example to get Crimson Weapon with Ghost property:
创建租赁念属性绯红色大驹短剑的例子：
	// +9 Crimson Dagger [2]
	setarray .@OptID[0],RDMOPT_WEAPON_ATTR_TELEKINESIS;
	setarray .@OptVal[0],0;
	setarray .@OptParam[0],0;
	rentitem3 28705,(24*60*60),1,9,0,0,0,0,0,.@OptID,.@OptVal,.@OptParam;

---------------------------------------

*makeitem <item id>,<amount>,"<map name>",<X>,<Y>;
*makeitem "<item name>",<amount>,"<map name>",<X>,<Y>;
*makeitem <物品编号>,<数量>,"<地图名称>",<坐标X>,<坐标Y>;
*makeitem "<物品名称>",<数量>,"<地图名称>",<坐标X>,<坐标Y>;

This command will create an item on the specified cell of a map.
这个命令会在指定地图的区格上创建一个物品。

As with any dropped items, the items created with this command will disappear after
a period of time. Using an amount greater than 1 will create a single stack of the
given amount, not multiple stacks of 1.
和其他掉落物品一样，该命令创建出的物品也会在一段时间后消失。如果物品数量大于1，则会
创建一个堆叠起来的物品，而不是数个堆叠数为1的物品。

Like 'getitem', it also accepts an 'english name' field from the database and creates
Apples if the name isn't found.
If the map name is given as "this", the map the invoking character is on will be used.
和'getitem'类似，该命令也可以使用物品名称，如果名称未找到则创建苹果。
如果地图名称设置为"this"，则对应调用角色所在的地图。

---------------------------------------

*makeitem2 <item id>,<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>;
*makeitem2 "<item name>",<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>;
*makeitem3 <item id>,<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>;
*makeitem3 "<item name>",<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>;
*makeitem4 <item id>,<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<canShowEffect>};
*makeitem4 "<item name>",<amount>,"<map name>",<X>,<Y>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<canShowEffect>};
*makeitem2 <物品编号>,<数量>,"<地图名称>",<坐标X>,<坐标Y>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>;
*makeitem2 "<物品名称>",<数量>,"<地图名称>",<坐标X>,<坐标Y>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>;
*makeitem3 <物品编号>,<数量>,"<地图名称>",<坐标X>,<坐标Y>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>;
*makeitem3 "<物品名称>",<数量>,"<地图名称>",<坐标X>,<坐标Y>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>;
*makeitem4 "<物品名称>",<数量>,"<地图名称>",<坐标X>,<坐标Y>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>;


This command will create an item on the specified cell of a map. See 'makeitem' for
further details.
这个命令会在指定地图的区格上创建一个物品。更多详情请参考'makeitem'。

See 'getitem2' for an explanation of the expanded parameters.
有关扩展参数的说明，请参见“getitem2”。

'makeitem3' is advance version of 'makeitem2' that also use Item Random Option as additional values.
<RandomIDArray>    : Array variable of ID for item random option, see db/[pre-]re/item_randomopt_db.txt
<RandomValueArray> : Array variable of item random option's value.
<RandomParamArray> : Array variable of item random option's param.
'makeitem3' 是比'makeitem2'更高版本的可以使用物品随机属性作为附加值的命令。
<随机属性ID数组>    : 物品随机属性ID的变量数组, 参考db/[pre-]re/item_randomopt_db.txt
<随机属性值数组> : 物品随机属性值的变量数组.
<随机属性参数数组> : 物品随机属性参数的变量数组.

'makeitem4' is advance version of 'makeitem3' that also use the grade as additional values.
'makeitem4'是 'makeitem3'的高级版本，也使用级别作为附加值。
Valid grades are:
	ENCHANTGRADE_NONE		- No grade     无级别
	ENCHANTGRADE_D			- Grade D      级别D
	ENCHANTGRADE_C			- Grade C      级别C
	ENCHANTGRADE_B			- Grade B      级别B
	ENCHANTGRADE_A			- Grade A      级别A

Example to get Crimson Weapon with Ghost property:
在地图上创建租赁念属性绯红色大驹短剑的例子：
	// 0.5% chance to get +0 Valkyrie Shield [1]   //0.5%的几率取得巴基力亚钢盾[1]
	// with Neutral Resistance +10% and 5% damage reduction from Demi-Human or Player  //附加10%无属性抗性和5%的人形抗性
	// when Valkyrie Randgris killed        //当打死一只巴基力时创建物品
	OnNPCKillEvent:
		if (killedrid == 1751 && rand(0,10000) > 9950) { // Valkyrie Randgris  巴基力
			getmapxy(.@map$,.@x,.@y,BL_PC);
			setarray .@OptID[0],RDMOPT_ATTR_TOLERACE_NOTHING,RDMOPT_RACE_TOLERACE_HUMAN;
			setarray .@OptVal[0],10,5;
			setarray .@OptParam[0],0;
			makeitem3 2115,1,.@map$,.@x,.@y,0,0,0,0,0,0,0,.@OptID,.@OptVal,.@OptParam;
		}
		end;

---------------------------------------

*cleanarea "<map name>",<x1>,<y1>,<x2>,<y2>;
*cleanmap "<map name>";
*cleanarea "<地图名称>",<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>;
*cleanmap "<地图名称>";

These commands will clear all items lying on the ground on the specified map, either
within the x1/y1-x2/y2 rectangle or across the entire map.
这两个命令可以清除指定地图内的整个或者坐标x1/y1-x2/y2矩形范围区域内的物品。

---------------------------------------

*searchitem <array name>,"<item name>";
*searchitem <数组名称>,"<物品名称>";

This command will fill the given array with the ID of items whose name matches
the given one. It returns the number of items found. For performance reasons,
the results array is limited to 10 items.
这个命令会将所有名称中包含<物品名称>的物品的ID填入给定的数组里。
还会同时返回找到的物品数量。出于性能原因，存储结果的数组限制10个物品。

	mes "What item are you looking for?";                                          //  mes "你在寻找什么东西?";
	input .@name$;                                                                 //  input .@name$;
	.@qty = searchitem(.@matches[0],.@name$);                                      //  .@qty = searchitem(.@matches[0],.@name$);
	mes "I found " + .@qty + " items:";                                            //  mes "我找到了" + .@qty + " 个物品:";
	for (.@i = 0; .@i < .@qty; .@i++)                                              //  for (.@i = 0; .@i < .@qty; .@i++)
		// Display name (eg: "Apple[0]")                                           //  	// 显示名称 (例如 "Apple[0]")
		mes getitemname(.@matches[.@i]) + "[" + getitemslots(.@matches[.@i]) + "]";//  	mes getitemname(.@matches[.@i]) + "[" + getitemslots(.@matches[.@i]) + "]";

---------------------------------------

*delitem <item id>,<amount>{,<account ID>};
*delitem "<item name>",<amount>{,<account ID>};
*delitem <物品编号>,<数量>{,<账号ID>};
*delitem "<物品名称>",<数量>{,<账号ID>};

This command will remove a specified amount of items from the invoking/target character.
Like all the item commands, it uses the item ID found inside 'db/item_db.yml'.
这个命令会移除调用/目标角色指定数量的物品。和其他物品命令一样，物品编号取自'db/item_db.yml'数据库。

    delitem 502,10; // The person will lose 10 apples         //失去10个苹果
    delitem 617,1;  // The person will lose 1 Old Violet Box    //失去1个神秘紫箱

It is always a good idea to check if the player actually has the items before you delete them.
If you try to delete more items that the player has, the player will lose the ones he/she has
and the script will terminate with an error.
在移除物品前最好事先检查一下玩家当前是否拥有等量物品。如果要移除的物品数量多于玩家身上拥有的数量，
那么玩家将会失去该物品并导致脚本出错并终止。

Like 'getitem', this command will also accept an 'english name' field from the
database. If the name is not found, nothing will be deleted.
和'getitem'类似，该命令也可以使用数据库里的英文名称。如果名称找不到，则不会移除任何物品。

---------------------------------------

*cartdelitem <item id>,<amount>{,<account ID>}; 
*cartdelitem "<item name>",<amount>{,<account ID>};
*storagedelitem <item id>,<amount>{,<account ID>};
*storagedelitem "<item name>",<amount>{,<account ID>};
*guildstoragedelitem <item id>,<amount>{,<account ID>};
*guildstoragedelitem "<item name>",<amount>{,<account ID>};
*cartdelitem <物品编号>,<数量>{,<账号ID>}; 
*cartdelitem "<物品名称>",<数量>{,<账号ID>};
*storagedelitem <物品编号>,<数量>{,<账号ID>};
*storagedelitem "<物品名称>",<数量>{,<账号ID>};
*guildstoragedelitem <物品编号>,<数量>{,<账号ID>};
*guildstoragedelitem "<物品名称>",<数量>{,<账号ID>};

This command behaves identically to 'delitem', but deletes items from the player's
cart, storage, or guild storage.
这些命令和'delitem'功能相同，只是移除的是玩家的手推车，仓库，或者工会仓库中的物品。

If no cart is mounted, 'cartdelitem' will return -1.
If player is not in a guild or storage is open, 'guildstoragedelitem' will return -1.
如果没有手推车，'cartdelitem'将会返回 -1。
如果玩家没有加入工会或者工会仓库被打开，'guildstoragedelitem'将会返回 -1。

---------------------------------------

*delitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*delitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*delitem3 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*delitem3 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*delitem4 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*delitem4 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<account ID>};
*delitem2 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*delitem2 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*delitem3 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*delitem3 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*delitem4 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};
*delitem4 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>};

This command will remove a specified amount of items from the invoking/target character.
See 'getitem2' for an explanation of the expanded parameters.
这些命令可以从调用/目标角色的物品栏里移除指定数量的物品。
有关扩展参数的说明，请参见'getitem2'。

'delitem3' is advance version of 'delitem2' that also use Item Random Option as criteria.
<RandomIDArray>    : Array variable of ID for item random option, see db/[pre-]re/item_randomopt_db.txt
<RandomValueArray> : Array variable of item random option's value.
<RandomParamArray> : Array variable of item random option's param.
'delitem3' 是比'delitem2'更高版本的可以使用物品随机属性作为附加值的命令。
<随机属性ID数组>    : 物品随机属性ID的变量数组, 参考db/[pre-]re/item_randomopt_db.txt
<随机属性值数组> : 物品随机属性值的变量数组.
<随机属性参数数组> : 物品随机属性参数的变量数组.

'delitem4' is advance version of 'delitem3' that also use the grade as criteria.
'delitem4'是 'delitem3'的进阶版本，也使用级别作为标准。

---------------------------------------

*delitemidx <index>{,<amount>{,<char id>}}
*delitemidx <索引>{,<数量>{,<角色编号>}}

This command will remove an item at the given inventory index.
这条命令将删除给定物品栏索引处的物品。

If <amount> is not specified, this will remove all of the items at the specified index.
如果未指定 <数量>，则将删除指定索引处的所有项目。

The only way to get the inventory index is by using 'getinventorylist()'. After deleting
an item at the given index, that index can remain empty until the player relogs, requiring
'getinventorylist()' to be called again. If an item is deleted with an invalid index, the
script will terminate with an error.
获取物品栏索引的唯一方法是使用 "getinventorylist()"。
删除给定索引的物品后，该索引可能会保持为空，直到玩家重新登录，
这就需要再次调用 "getinventorylist()"。如果删除的项目索引无效，脚本将以错误结束。

This command returns true on success and false if the item at the given index could not be deleted or if
not enough items were available at the given index.
该命令成功时返回 true，如果给定索引中的项目无法删除或给定索引中没有足够的项目，则返回 false。

Example:
例子：

	// This will remove all Red Potions from player's inventory   这将清除玩家物品栏中的所有红色药水
	getinventorylist();
	for (.@i = 0; .@i < @inventorylist_count; ++.@i)
		if (@inventorylist_id[.@i] == 501)
			delitemidx @inventorylist_idx[.@i];

---------------------------------------

*cartdelitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*cartdelitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*storagedelitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*storagedelitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*guildstoragedelitem2 <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*guildstoragedelitem2 "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<account ID>};
*cartdelitem2 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*cartdelitem2 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*storagedelitem2 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*storagedelitem2 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*guildstoragedelitem2 <物品编号>,<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};
*guildstoragedelitem2 "<物品名称>",<数量>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>};

This command behaves identically to 'delitem2', but deletes items from the player's
cart, storage, or guild storage.
这些命令和'delitem2'功能相同，但是从玩家的手推车，仓库，工会仓库中删除物品。

If no cart is mounted, 'cartdelitem2' will return -1.
If player is not in a guild or storage is open, 'guildstoragedelitem2' will return -1.
如果没有手推车，'cartdelitem2'将会返回 -1。
如果玩家没有加入工会或者工会仓库被打开，'guildstoragedelitem2'将会返回 -1。

---------------------------------------

*countitem(<item id>{,<accountID>})
*countitem("<item name>"{,<accountID>})
*countitem(<物品编号>{,<账号ID>})
*countitem("<物品名称>"{,<账号ID>})

This function will return the number of items for the specified item ID that the
invoking character has in the inventory.
这个函数将会返回调用角色物品栏里指定物品编号的物品的数量。

	mes "[Item Checker]";                                         //  mes "[物品确认者]";
	mes "Hmmm, it seems you have " + countitem(502) + " apples";  //  mes "嗯, 看来你有 " + countitem(502) + " 个苹果";
	close;                                                        //  close;

Like 'getitem', this function will also accept an 'english name' from the
database as an argument.
和'getitem'相同，该函数也可以使用物品数据库里的物品英文名称作为参数。

If you want to state the number at the end of a sentence, you can do it by
adding up strings:
如果要在信息末尾说明数字，可以将字符串相加：

	mes "[Item Checker]";                                                            //   mes "[物品确认者]";
	mes "Hmmm, the total number of apples you are holding is " + countitem("APPLE"); //   mes "嗯, 你携带的苹果总数是 " + countitem("APPLE");
	close;                                                                           //   close;

---------------------------------------

*cartcountitem(<item id>{,<accountID>})
*cartcountitem("<item name>"{,<accountID>})
*storagecountitem(<item id>{,<accountID>})
*storagecountitem("<item name>"{,<accountID>})
*guildstoragecountitem(<nameID>{,<accountID>})
*guildstoragecountitem("<item name>"{,<accountID>})
*cartcountitem(<物品编号>{,<账号ID>})
*cartcountitem("<物品名称>"{,<账号ID>})
*storagecountitem(<物品编号>{,<账号ID>})
*storagecountitem("<物品名称>"{,<账号ID>})
*guildstoragecountitem(<名称ID>{,<账号ID>})
*guildstoragecountitem("<物品名称>"{,<账号ID>})

This command behaves identically to 'countitem', but counts items from the player's
cart, storage, or guild storage.
这些命令和'countitem'功能相同，但是从玩家的手推车，仓库，工会仓库中计算物品的数量。

If no cart is mounted, 'cartcountitem' will return -1.
If player is not in a guild or storage is open, 'guildstoragecountitem' will return -1.
如果没有手推车，'cartcountitem'将会返回 -1。
如果玩家没有加入工会或者工会仓库被打开，'guildstoragecountitem'将会返回 -1。

---------------------------------------

*countitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*countitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*countitem3(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countitem3("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countitem4(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countitem4("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*countitem2(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*countitem2("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*countitem3(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})
*countitem3("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})
*countitem4(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})
*countitem4("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})


Expanded version of 'countitem' function, used for created/carded/forged items.
countitem”功能的扩展版本，用于制作/插卡/锻造的物品

This function will return the number of items for the specified item ID and
other parameters that the invoking character has in the inventory.
See 'getitem2' for an explanation of the expanded parameters.
这个函数会返回调用角色物品栏里拥有的指定物品编号和其他参数的物品的数量。
有关扩展参数的说明，请参见'getitem2'。

'countitem3' is advance version of 'countitem2' that also use Item Random Option as criteria.
<RandomIDArray>    : Array variable of ID for item random option, see db/[pre-]re/item_randomopt_db.txt
<RandomValueArray> : Array variable of item random option's value.
<RandomParamArray> : Array variable of item random option's param.
'countitem3' 是比'countitem2'更高版本的可以使用物品随机属性作为附加值的命令。
<随机属性ID数组>    : 物品随机属性ID的变量数组, 参考db/[pre-]re/item_randomopt_db.txt
<随机属性值数组> : 物品随机属性值的变量数组.
<随机属性参数数组> : 物品随机属性参数的变量数组.

'countitem4' is advance version of 'countitem3' that also use the grade as criteria.
'countitem4'是 'countitem3'的进阶版本，也使用级别作为参数。

---------------------------------------

*cartcountitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*cartcountitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*storagecountitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*storagecountitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*guildstoragecountitem2(<nameID>,<Identified>,<Refine>,<Attribute>,<Card0>,<Card1>,<Card2>,<Card3>{,<accountID>})
*guildstoragecountitem2("<item name>",<Identified>,<Refine>,<Attribute>,<Card0>,<Card1>,<Card2>,<Card3>{,<accountID>})
*cartcountitem2(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*cartcountitem2("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*storagecountitem2(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*storagecountitem2("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*guildstoragecountitem2(<名称ID>,<Identified>,<精炼>,<损坏>,<卡片0>,<卡片1>,<卡片2>,<卡片3>{,<账号ID>})
*guildstoragecountitem2("<物品名称>",<Identified>,<精炼>,<损坏>,<卡片0>,<卡片1>,<卡片2>,<卡片3>{,<账号ID>})

This command behaves identically to 'countitem2', but counts items from the player's
cart, storage, or guild storage.
这些命令和'countitem2'功能相同，但是从玩家的手推车，仓库，工会仓库中计算物品的数量。

If no cart is mounted, 'cartcountitem2' will return -1.
If player is not in a guild or storage is open, 'guildstoragecountitem2' will return -1.
如果没有手推车，'cartcountitem2'将会返回 -1。
如果玩家没有加入工会或者工会仓库被打开，'guildstoragecountitem2'将会返回 -1。

---------------------------------------

*rentalcountitem(<item id>{,<accountID>})
*rentalcountitem("<item name>"{,<accountID>})
*rentalcountitem(<物品编号>{,<账号ID>})
*rentalcountitem("<物品名称>"{,<账号ID>})

This function will return the number of rental items for the specified item ID that the
invoking character has in the inventory.
这个函数将会返回调用角色的物品栏里指定租赁物品编号的物品的数量。

---------------------------------------

*rentalcountitem2(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*rentalcountitem2("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>{,<accountID>})
*rentalcountitem3(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*rentalcountitem3("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*rentalcountitem4(<item id>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*rentalcountitem4("<item name>",<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<grade>,<RandomIDArray>,<RandomValueArray>,<RandomParamArray>{,<accountID>})
*rentalcountitem2(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*rentalcountitem2("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>{,<账号ID>})
*rentalcountitem3(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})
*rentalcountitem3("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})
*rentalcountitem4(<物品编号>,<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})
*rentalcountitem4("<物品名称>",<鉴定>,<精炼>,<损坏>,<卡片1>,<卡片2>,<卡片3>,<卡片4>,<级别>,<随机属性ID数组>,<随机属性值数组>,<随机属性参数数组>{,<账号ID>})


Expanded version of 'rentalcountitem' function, used for created/carded/forged items.
'rentalcountitem'功能的扩展版本，用于制作/插卡/锻造的物品

This function will return the number of rental items for the specified item ID and
other parameters that the invoking character has in the inventory.
See 'getitem2' for an explanation of the expanded parameters.
这个函数会返回调用角色物品栏里拥有的指定租赁物品编号和其他参数的物品的数量。
有关扩展参数的说明，请参见'getitem2'。

'rentalcountitem3' is advance version of 'rentalcountitem2' that also use Item Random Option as criteria.
<RandomIDArray>    : Array variable of ID for item random option, see db/[pre-]re/item_randomopt_db.txt
<RandomValueArray> : Array variable of item random option's value.
<RandomParamArray> : Array variable of item random option's param.
'rentalcountitem3' 是比'rentalcountitem2'更高版本的可以使用物品随机属性作为附加值的命令。
<随机属性ID数组>    : 物品随机属性ID的变量数组, 参考db/[pre-]re/item_randomopt_db.txt
<随机属性值数组> : 物品随机属性值的变量数组.
<随机属性参数数组> : 物品随机属性参数的变量数组.

'rentalcountitem4' is advance version of 'rentalcountitem3' that also use the grade as criteria.
'rentalcountitem4'是 'rentalcountitem3'的进阶版本，也使用级别作为参数。

---------------------------------------

*countbound({<bound type>{,<char_id>}})
*countbound({<绑定类型>{,<角色编号>}})

This function will return the number of different bounded items in the character's
inventory, and sets the arrays @bound_items[] and @bound_amount[] containing all item IDs of the
counted items and their respective amount. If a bound type is specified, only those items will be counted.
这个函数将会返回角色物品栏里不同的绑定物品的数量，并将获取到的物品编号和物品数量分别存储在@bound_items[]和
@bound_amount[]数组里。如果绑定类型被指定，则只返回该类型的绑定物品数量。


For a list of bound types see 'getitembound'.
绑定类型列表请参考'getitembound'。

Example:
例子：
	.@total_type = countbound();
	mes "You currently have " + .@total_type + " different type of bounded items.";
	//mes "你目前有" + .@total_type + " 个不同绑定类型的物品。";
	next;
	mes "The list of bounded items include:";
	//mes "绑定物品列表为:";
	for(.@i = 0; .@i < .@total_type; .@i++)
		mes "x" + @bound_amount[.@i] + " " + getitemname(@bound_items[.@i]);
	close;

---------------------------------------

*groupranditem <group id>{,<sub_group>};
*groupranditem <组编号>{,<子组>};

Returns the item_id of a random item picked from the group specified. The
different groups and their group number are specified in 'db/(pre-)re/item_group_db.txt'.
返回指定物品组里的随机一个物品的id。物品组和组号在'db/(pre-)re/item_group_db.txt'定义。

When used in conjunction with other functions, you can get a random item. For
example, for a random pet lure:
与其他功能组合使用时，你可以获取一个随机物品。
例如，获取一个随机宠物捕捉道具：

getitem groupranditem(IG_Taming),1;

'sub_group' is used to get the available random items of item group from specified random
group. 0 for 'must' item group, and random item group is 1 until 5 (MAX_ITEMGROUP_RANDGROUP+1).
'子组'被用来取得从指定随机组里的随机物品组里的可获取的随机物品。
0为'must'物品组，随机物品组则是1 - 5 (MAX_ITEMGROUP_RANDGROUP+1).

More info, see doc/item_group.txt.
更多信息，请参阅doc/item_group.txt。

---------------------------------------

*getrandgroupitem <group_id>{,<quantity>{,<sub_group>{,<identify>{,<char_id>}}}};
*getrandgroupitem <组编号>{,<数量>{,<子组>{,<鉴定>{,<角色编号>}}}};

Similar to the above example, this command allows players to obtain the specified
quantity of a random item from the group "<group id>". The different groups and
their group number are specified in db/(pre-)re/item_group_db.txt
和上述例子相似，这个命令允许玩家从<组编号>的组里获得指定数量随机物品。不同组及其组号
在db/(pre-)re/item_group_db.txt中指定。

If 'quantity' is not defined or 0, it will uses defined amount from Item Group list.
如果'数量'没有定义或者为0，则会采用物品组列表里定义的数量。

If 'sub_group' is not defined the value will be 1 (since random group is 1 ~ 5, and 0 is
'must' item group).
如果'sub_group'没有定义，则默认值为1(随机组值在 1 ~ 5,0则是'must'物品组。)

For item with type IT_WEAPON, IT_ARMOR, IT_PETARMOR, and IT_SHADOWGEAR will be given
as unidentified item (as defined by itemdb_isidentified in src/map/itemdb.cpp) except
if 'identify' is defined with value 1.
所有类型为IT_WEAPON(武器), IT_ARMOR(护甲), IT_PETARMOR(宠物装备), 和IT_SHADOWGEAR(影子装备)
的物品在获得后都是未鉴定的(在src/map/itemdb.cpp里由itemdb_isidentified定义)除非<鉴定>
参数的值设置为1。

More info, see doc/item_group.txt.
更多信息，请参阅doc/item_group.txt。

---------------------------------------

*getgroupitem <group_id>{,<identify>{,<char_id>}};
*getgroupitem <组编号>{,<鉴定>{,<角色编号>}};

Gives item(s) to the attached player based on item group contents.
This is not working like 'getrandgroupitem' which only give 1 item for specified
item group & sub_group.
根据物品组的目录给予关联角色物品。
和'getrandgroupitem'不同，这个命令只会给1个指定物品组或者子组的物品。

For item with type IT_WEAPON, IT_ARMOR, IT_PETARMOR, and IT_SHADOWGEAR will be given
as unidentified item (as defined by itemdb_isidentified in src/map/itemdb.cpp) except
if 'identify' is defined with value 1.
所有类型为IT_WEAPON(武器), IT_ARMOR(护甲), IT_PETARMOR(宠物装备), 和IT_SHADOWGEAR(影子装备)
的物品在获得后都是未鉴定的(在src/map/itemdb.cpp里由itemdb_isidentified定义)除非<鉴定>
参数的值设置为1。

More info, see doc/item_group.txt.
更多信息，请参阅doc/item_group.txt。

---------------------------------------

*enable_items;
*disable_items;

These commands toggle the ability to change equipment while interacting with
an NPC. To avoid possible exploits, the commands affect the particular script
instance only. Note that if a different script also calls enable_items, it
will override the last call (so you may want to call this command at the start
of your script without assuming it is still in effect).
这两个命令在玩家和NPC互动期间用来切换装备的可装备与否。为了避免可能的错误，
这些命令只影响特定的脚本实例。请注意，如果另一个脚本也调用enable_items，
它将覆盖最后一个调用（因此最好在脚本开始时调用此命令，而不是假定它仍然有效）。

The default setting, 'item_enabled_npc', is defined in 'conf/battle/items.conf'.
默认的设置，'item_enabled_npc'在'conf/battle/items.conf'里面进行定义。

---------------------------------------

*itemskill <skill id>,<skill level>{,<keep requirement>};
*itemskill "<skill name>",<skill level>{,<keep requirement>};
*itemskill <技能编号>,<技能等级>{,<保留需求>};
*itemskill "<技能名称>",<技能等级>{,<保留需求>};

This command is meant for item scripts to replicate single-use skills in usable
items. It will not work properly if there is a visible dialog window or menu or if the item is not type 'Delayconsume'.
If the skill is self or auto-targeting, it will be used immediately; otherwise a
target cursor is shown.
这个命令用于物品脚本，用来赋予可使用物品一个可以单次使用的技能。如果技能存在可见的对话框窗口或菜单
，或者如果物品不是'Delayconsume'(延迟消耗)类型，则它将无法正常工作。如果技能是自身使用或者自动选择目标，
那么会直接释放技能，其他情况下则会在目标选择后释放。

If <keep requirement> parameter is set to true, the skill's requirements will be checked.
By default, the requirements for item skills are not checked, and therefore the default value is false.
如果<保留需求>参数被设置为true，则技能的需求将被检查(译注：如暗之障壁需要蓝石)。
默认的，技能需求的物品不会被检查，就是说，默认值是false。

// When Anodyne is used, it will cast Endure (8), Level 1, as if the actual skill has been used from skill tree.
//当使用了曼特疗伤药，将会使用霸体(ID:8)1级技能，就如同正在使用技能树上的技能一样。
  - Id: 605
    AegisName: Anodyne
    Name: Anodyne
    Type: Delayconsume
    Buy: 2000
    Weight: 100
    Flags:
      BuyingStore: true
    Script: |
      itemskill "SM_ENDURE",1;

// When Sienna_Execrate_Scroll_1_5 is used, it will cast Sienna Execrate Level 5 and consume 2 Red_Gemstones.
//当使用了石化诅咒卷轴LV5，将会施放石化诅咒5级并消耗2个红色魔力矿石。
  - Id: 23194
    AegisName: Sienna_Execrate_Scroll_1_5
    Name: Level 5 Sienna Execrate
    Type: Delayconsume
    Buy: 10
    Weight: 10
    Script: |
      itemskill "WL_SIENNAEXECRATE",5,true;

---------------------------------------

*consumeitem <item id>{,<char_id>};
*consumeitem "<item name>"{,<char_id>};
*consumeitem <物品编号>{,<角色编号>};
*consumeitem "<物品名称>"{,<角色编号>};

This command will run the item script of the specified item on the invoking
character. The character does not need to possess the item, and the item will
not be deleted. While this command is intended for usable items, it will run
for any item type.
这个命令会在调用角色身上执行指定物品的物品脚本。角色不用拥有该物品，物品也不会
被消耗。虽然这个命令基本对应可使用的物品，但也可以执行其他类型物品的物品脚本。

This command does not currently work with the 'itemskill' script command.
这个命令目前不能用于使用了'itemskill'脚本命令的物品上。

---------------------------------------

*produce <item level>;
*produce <物品等级>;

This command will open a crafting window on the client connected to the invoking
character. The 'item level' is a number which determines what kind of a crafting
window will pop-up.
这个命令会在调用角色的客户端上打开一个制造窗口。<物品等级>是一个决定弹出何种制造
窗口的数字。

You can see the full list of such item levels in 'db/produce_db.txt' which determines
what can actually be produced. The window will not be empty only if the invoking
character can actually produce the items of that type and has the appropriate raw
materials in their inventory.
你可以在'db/produce_db.txt'查到决定当前可以制造物品的<物品等级>的完整列表。只有调用
角色的物品栏里持有相关制造物品的完整一套材料后，才会显示制造窗口。

The success rate to produce the item is the same as the success rate of the skill
associated with the item level. If there is no skill id, the success rate will be 50%.
成功率同制造该物品的技能相同。如果没有技能编号，则成功率为50%。

Valid item levels are:

 1   - Level 1 Weapons    //1级武器
 2   - Level 2 Weapons    //2级武器
 3   - Level 3 Weapons    //3级武器
 21  - Blacksmith's Stones and Metals     //铁匠的属性石和材料
 22  - Alchemist's Potions, Holy Water, Assassin Cross's Deadly Poison    //炼金术士的药剂，圣水，十字刺客的毒药瓶
 23  - Elemental Converters    //属性转换卷轴

---------------------------------------

*cooking <dish level>;
*cooking <料理等级>;

This command will open a produce window on the client connected to the invoking
character. The 'dish level' is the number which determines what kind of dish
level you can produce. You can see the full list of dishes that can be produced in
'db/produce_db.txt'.
这个命令会在调用角色的客户端上打开一个制造窗口。<料理等级>是一个决定弹出制造何种等级
料理窗口的数字。你可以在'db/produce_db.txt'里查到料理制作的完整列表。

The window will be shown empty if the invoking character does not have enough of
the required incredients to cook a dish.
只有调用角色的物品栏里持有制造相关料理的完整一套材料后，才会显示制造窗口。

Valid dish levels are:
有效料理等级为：

11 - Level 1 Dish      - 等级1料理
12 - Level 2 Dish      - 等级2料理
13 - Level 3 Dish      - 等级3料理
14 - Level 4 Dish      - 等级4料理
15 - Level 5 Dish      - 等级5料理
16 - Level 6 Dish      - 等级6料理
17 - Level 7 Dish      - 等级7料理
18 - Level 8 Dish      - 等级8料理
19 - Level 9 Dish      - 等级9料理
20 - Level 10 Dish     - 等级10料理

Although it's required to set a dish level, it doesn't matter if you set it to 1
and you want to cook a level 10 dish, as long as you got the required incredients
to cook the dish the command works.
虽然需要设置料理等级，但是如果你设置了1级也能烹饪10级料理，但是必须要带齐材料才能制作。

---------------------------------------

*makerune <% success bonus>{,<char_id>};
*makerune <% 成功率加成>{,<角色编号>};

This command will open a rune crafting window on the client connected to the
invoking character. Since this command is officially used in rune ores, a bonus
success rate must be specified (which adds to the base formula).
这个命令会在调用角色的客户端上打开一个符文制造窗口。<% 成功率加成>需要设置(用来
对基础公式进行加成。)

You can see the full list of runes that can be produced in 'db/produce_db.txt'.
The window will not be empty only if the invoking character can actually produce
a rune and has the appropriate raw materials in their inventory.
你可以在'db/produce_db.txt'里查到符文制作的完整列表。
只有调用角色的物品栏里持有制造相关符文的完整一套材料后，才会显示制造窗口。

---------------------------------------

*successremovecards <equipment slot>;
*successremovecards <装备位置>;

This command will remove all cards of the cards slots defined in db/item_db.yml
from the item found in the specified equipment slot of the invoking character,
create new card items and give them to the character.
If any cards were removed in this manner, it will also show a success effect.
这个命令可以移除调用角色指定装备位置的物品在db/item_db.yml数据库里定义的所有插孔里的卡片，
并将装备和卡片返还。如果移除成功，还会显示一个成功的效果。

---------------------------------------

*failedremovecards <equipment slot>,<type>;
*failedremovecards <装备位置>,<类型>;

This command will remove all cards from the item found in the specified
equipment slot of the invoking character. 'type' determines what happens to the
item and the cards:
这个命令可以移除调用角色指定装备位置的物品所有插孔里的卡片。<类型>决定物品和
卡片的处理方式。

 0 - will destroy both the item and the cards.    - 将会销毁物品和所有卡片。
 1 - will keep the item, but destroy the cards.   - 将会保留物品，销毁卡片。
 2 - will keep the cards, but destroy the item.   - 将会保留卡片，销毁物品。

Whatever the type is, it will also show a failure effect on screen.
不管类型如何设置，将会在屏幕上显示一个失败的效果。

---------------------------------------

*repair <broken item number>{,<char_id>};
*repair <损坏物品序号>{,<角色编号>};

This command repairs a broken piece of equipment, using the same list of broken
items as available through 'getbrokenid'.
这个命令修复一个损坏的装备，使用和'getbrokenid'一样的损坏物品列表变量。

---------------------------------------

*repairall {<char_id>};
*repairall {<角色编号>};

This command repairs all broken equipment in the attached player's inventory.
A repair effect will be shown if any items are repaired, else the command will
end silently.
这个命令会修复关联玩家物品栏里所有损坏的装备。如果有装备被修复，则会显示一个
修理动画效果，如果没有则不显示。

---------------------------------------

*successrefitem <equipment slot>{,<count>{,<char_id>}};
*successrefitem <装备位置>{,<数量>{,<角色编号>}};

This command will refine an item in the specified equipment slot of the invoking
character by +1, or a count if given. For a list of equipment slots see 'getequipid'.
This command will also display a 'refine success' effect on the character and put
appropriate messages into their chat window. It will also give the character fame
points if a weapon reached +10 this way, even though these will only take effect for
blacksmith who will later forge a weapon.
这个命令会将调用角色指定装备位置上的物品精炼+1，或者精炼给定的<数量>值。装备位置列表
参考'getequipid'。这个命令也会在角色身上显示一个精炼成功的动画效果并在信息栏显示相应
的精炼成功信息。还会给予角色武器精炼+10获得的声望点数，即使这个点数只对铁匠精炼武器有用。

---------------------------------------

*failedrefitem <equipment slot>{,<char_id>};
*failedrefitem <装备位置>{,<角色编号>};

This command will fail to refine an item in the specified equipment slot of the
invoking character. The item will be destroyed. This will also display a 'refine
failure' effect on the character and put appropriate messages into their chat
window.
这个命令会将调用角色指定装备位置的物品精炼失败。物品也会被破坏消失。还会在角色身上显示
'精炼失败'的动画效果并在信息栏显示相应的精炼失败信息。

---------------------------------------

*downrefitem <equipment slot>{,<count>{,<char_id>}};
*downrefitem <装备位置>{,<数量>{,<角色编号>}};

This command will downgrade an item in the specified equipment slot of the invoking
character by -1, or a count if given. For a list of equipment slots see 'getequipid'.
This command will also display a 'refine failure' effect on the character and put
appropriate messages into their chat window.
这个命令会将调用角色指定装备位置上的物品精炼-1，或者向下减少精炼给定的<数量>值。装备位置列表
参考'getequipid'。这个命令也会在角色身上显示一个精炼失败的动画效果并在信息栏显示相应
的精炼失败信息。

---------------------------------------

*unequip <equipment slot>{,<char_id>};
*unequip <装备位置>{,<角色编号>};

This command will unequip whatever is currently equipped in the invoking
character's specified equipment slot. For a full list of possible equipment
slots see 'getequipid'.
这个命令会卸除调用角色指定装备位置上的装备。相关装备位置的列表，参考'getequipid'。

If an item occupies several equipment slots, it will get unequipped from all of
them.
如果装备占用了多个装备位置，将同时卸除全部。

---------------------------------------

*delequip <equipment slot>{,<char_id>};
*delequip <装备位置>{,<角色编号>};

This command will destroy whatever is currently equipped in the invoking
character's specified equipment slot. For a full list of possible equipment
slots see 'getequipid'.
这个命令将会销毁调用角色指定装备位置上当前装备的物品。相关装备位置的列表，参考'getequipid'。

This command will return 1 if an item was deleted and 0 otherwise.
如果销毁成功返回1，失败返回0。

---------------------------------------

*breakequip <equipment slot>{,<char_id>};
*breakequip <装备位置>{,<角色编号>};

This command will break and unequip whatever is currently equipped in the
invoking character's specified equipment slot. For a full list of possible
equipment slots see 'getequipid'.
这个命令将会损坏调用角色指定装备位置上当前装备的物品并卸除。
相关装备位置的列表，参考'getequipid'。

This command will return 1 if an item was broken and 0 otherwise.
如果损坏成功返回1，失败返回0。

---------------------------------------

*clearitem {<char_id>};
*clearitem {<角色编号>};

This command will destroy all items the invoking character has in their
inventory (including equipped items). It will not affect anything else, like
storage or cart.
这个命令将会销毁调用角色物品栏里的所有物品(包括身上装备)。对其他如仓库和手推车
里的物品无效。

---------------------------------------

*equip <item id>{,<char_id>};
*autoequip <item id>,<option>;
*equip <物品编号>{,<角色编号>};
*autoequip <物品编号>,<选项>;

These commands are to equip a equipment on the attached character.
The equip function will equip the item ID given when the player has
this item in his/her inventory, while the autoequip function will
equip the given item ID when this is looted. The option parameter of
the autoequip is 1 or 0, 1 to turn it on, and 0 to turn it off.
这两个命令可以使关联角色穿上一个装备。如果玩家物品栏里有给定编号的装备的话
equip函数将会令其穿上，而autoequip则会令玩家在捡起给定编号的装备时直接穿上。
<选项>参数表示autoequip的开关状态，1为开启autoequip模式，0为关闭。

Examples:
例子：

//This will equip a 1104 (falchion) on the character if this is in the inventory.
//如果角色的物品栏里有1104(圆月刀)就装备上。
	equip 1104;

//The invoked character will now automatically equip a falchion when it's looted.
//调用角色如果捡起了1104(圆月刀)就直接装备上。
	autoequip 1104,1;

//The invoked character will no longer automatically equip a falchion.
//调用角色不在捡起后自动装备圆月刀。
	autoequip 1104,0;

---------------------------------------

*buyingstore <slots>;
*buyingstore <空位>;

Invokes buying store preparation window like the skill 'Open Buying Store',
without the item requirement. Amount of slots is limited by the server to
a maximum of 5 slots by default.
开启一个采购商店的设置窗口，如同使用技能'开设采购商店'一样，不需要物品需求。
空位的数量限制由服务器决定，默认最大数量是5.

Example:
	// Gives the player opportunity to buy 4 different kinds of items.
	//让玩家有机会购买4种不同的物品。
	buyingstore 4;

---------------------------------------

*searchstores <uses>,<effect>;
*searchstores <使用次数>,<效果>;

Invokes the store search window, which allows to search for both vending
and buying stores. Parameter uses indicates, how many searches can be
started, before the window has to be reopened. Effect value affects,
what happens, when a result item is double-clicked and can be one of the
following:
开启商店搜索窗口，可以搜索露天商店和采购商店。参数<使用次数>表示在重新打开窗口之前
可以启动多少次搜索。<效果>值影响双击结果项时发生的情况，该结果项可以是以下内容之一：

	0 = Shows the store's position on the mini-map and highlights the
	    shop sign with yellow color, when the store is on same map
	    as the invoking player.
	1 = Directly opens the shop, regardless of distance.
	0 = 显示商店在小地图上的位置并将进入调用玩家视野的商店设置为黄色高亮。
	1 = 无视距离打开商店。

Example:
例子：
	// Item Universal_Catalog_Gold (10 uses, effect: open shop)
	searchstores 10,1;

---------------------------------------

*enable_command;
*disable_command;

These commands toggle the ability to use atcommand while interacting with an NPC.
这些命令在与NPC交互时切换使用atcommand(GM指令)的允许与否。

The default setting, 'atcommand_disable_npc', is defined in 'conf/battle/gm.conf'.
默认设置，'atcommand_disable_npc'，在'conf/battle/gm.conf'里设置。

---------------------------------------
//
4,1.- End of item-related commands      //物品相关命令结束
//
---------------------------------------

*openstorage;

This will open character's Kafra storage window on the client connected to the
invoking character. It can be used from any kind of NPC or item script, not just
limited to Kafra Staff.
使调用的角色的客户端开启该角色的卡普拉仓库窗口。不仅仅可以用在卡普拉服务，还可以
在任意类型的NPC和物品脚本里使用。

The storage window opens regardless of whether there are open NPC dialogs or
not, but it is preferred to close the dialog before displaying the storage
window, to avoid any disruption when both windows overlap.
无论有没有设置开启的NPC对话都会开启仓库窗口，但最好在显示仓库窗口之前关闭对话框，
以避免两个窗口重叠时出现任何干扰。

    mes "Close this window to open your storage.";   //mes "关闭这个窗口后再打开仓库。";
    close2;
    openstorage;
    end;

---------------------------------------

*openstorage2 <storage_id>,<mode>{,<account_id>};
*openstorage2 <仓库id>,<模式>{,<账号id>};

Just like the 'openstorage' command, except this command can open additional storages
by the specified <storage_id>. For <storage_id>, please read the conf/inter_server.yml
for storage groups.
和'openstorage'命令基本类似，不同之处在于这个命令可以开启指定<仓库id>的附加仓库。
<仓库id>参考conf/inter_server.yml里的仓库组。

Values for <mode> are:
<模式>的值为：
	STOR_MODE_NONE : Player only can read the storage entries.     //玩家只能读取仓库条目。
	STOR_MODE_GET  : Player can get items from the storage.        //玩家可以从仓库里提取物品。
	STOR_MODE_PUT  : Player can put items in the storage.          //玩家可以往仓库里存放物品。

Example:
例子：
	if (vip_status(VIP_STATUS_ACTIVE)) {
		mes "I will open your Premium storage.";      //mes "我将开启你的保密仓库。";
		mes "Thank you for using our service.";       //mes "感谢使用我们的服务。";
		close2;
		openstorage2 1,STOR_MODE_GET|STOR_MODE_PUT;
	} else {
		mes "Sorry, your Premium status is expired.";  //mes "抱歉，你的保密权限已经到期。";
		mes "Storage will be opened but you can't put any item into it.";    //mes "仓库会开启但是不能放物品进去。";
		close2;
		openstorage2 1,STOR_MODE_GET;
	}
	end;

---------------------------------------

*openmail({<char_id>});
*openmail({<角色编号>});

This will open a character's Mail window on the client connected to the
invoking character.
使调用的角色的客户端开启一个邮箱窗口。

	mes "Close this window to open your mail inbox.";     //mes "关闭窗口并打开你的邮箱。";
	close2;
	openmail;
	end;

This command is not supported for PACKETVER 20150513 or newer.
封包版本 20150513 或更新版本不支持此命令。

---------------------------------------

*mail <destination id>,"<sender name>","<title>","<body>"{,<zeny>{,<item id array>,<item amount array>{,refine{,bound{,<item card0 array>{,<item card1 array>{,<item card2 array>{,<item card3 array>
		{,<random option id0 array>, <random option value0 array>, <random option paramter0 array>{,<random option id1 array>, <random option value1 array>, <random option paramter1 array>
		{,<random option id2 array>, <random option value2 array>, <random option paramter2 array>{,<random option id3 array>, <random option value3 array>, <random option paramter3 array>
		{,<random option id4 array>, <random option value4 array>, <random option paramter4 array>}}}}}}}}};
*mail <目的地id>,"<发送者名字>","<标题>","<内容>"{,<zeny>{,<物品编号数组>,<物品数量数组>{,精炼{,绑定{,<物品插卡0数组>{,<物品插卡1数组>{,<物品插卡2数组>{,<物品插卡3数组>
		{,<随机属性id0数组>, <随机属性值0数组>, <随机属性参数0数组>{,<随机属性id1数组>, <随机属性值1数组>, <随机属性参数1数组>
		{,<随机属性id2数组>, <随机属性值2数组>, <随机属性参数2数组>{,<随机属性id3数组>, <随机属性值3数组>, <随机属性参数3数组>
		{,<随机属性id4数组>, <随机属性值4数组>, <随机属性参数4数组>}}}}}}}}};

This command will send mail to the <destination id> which is a character ID.
A <sender name> can be specified but does not have to be from the direct creator
of the mail and is limited to NAME_LENGTH (24) characters. Mail <title> is limited
to MAIL_TITLE_LENGTH (40) characters. Mail <body> is limited to MAIL_BODY_LENGTH
(200) characters for PACKETVER < 20150513 or 500 characters for later clients.
这个命令会发送一个邮件到以角色编号表示的<目的地id>。<发送者名字>可以指定但是不必
来自邮件的直接创建者，并且名字的长度NAME_LENGTH限制为24个字符。邮件<标题>长度MAIL_TITLE_LENGTH
限制为40个字符。邮件<内容>长度MAIL_BODY_LENGTH限制为200个字符(20150513以前的客户端，以后的
客户端限制为500个字符)。

Optional <zeny> and item data can be added to the mail as well. PACKETVER < 20150513
is limited to 1 item while later clients are limited to MAIL_MAX_ITEM (5).
可选参数<zeny>和物品数据也可以被附加进邮件里。版本号PACKETVER小于20150513限制1件物品，
以后的版本最大数量MAIL_MAX_ITEM限制为5个。

The <item id array>, <item amount array>, <item card0 array>, <item card1 array>,
<item card2 array>, and <item card3 array> should all be integer arrays.
<物品编号数组>，<物品数量数组>，<物品插卡0数组>，<物品插卡1数组>，<物品插卡2数组>
<物品插卡3数组>都必须是整数型数组。

For random options there can be 5 arrays in pairs of 3 (ids, values, parameters) right after the cards.
All of these arrays shall be integer arrays as well.
随机属性数组可以有5组每组3个(id, 值, 参数)在卡片后面。所有数组也都必须是整数型数组。

Example of sending mail with zeny:
发送附带zeny的邮件：
	.@charid = getcharid(0);
	.@sender$ = "Poring";            //发送人：波利
	.@title$ = "Welcome";            //标题：欢迎
	.@body$ = "Hi! I'm a simple Poring from the Prontera fields! Welcome to Ragnarok!";   //内容：“嗨！我是普隆德拉区域的一只普通波利！欢迎来到RO的世界！”
	.@zeny = 5000;
	mail .@charid, .@sender$, .@title$, .@body$, .@zeny;

Example of sending mail with items:
发送一个附带物品的邮件：
	.@charid = getcharid(0);
	.@sender$ = "Angeling";    //发送人：天使波利
	.@title$ = "Welcome";      //标题：欢迎
	.@body$ = "Hi! I'm a simple Angeling from the Prontera fields! Welcome to Ragnarok!";  //内容：“嗨！我是普隆德拉区域的一只普通天使波利！欢迎来到RO的世界！”
	.@zeny = 0;
	setarray .@mailitem[0], 504, 505, 2220, 1214; // White Potion, Blue Potion, Hat, Dagger
	setarray .@mailamount[0], 10, 5, 1, 1; // 10 White Potions, 5 Blue Potions, 1 Hat, 1 Dagger
	setarray .@mailrefine[0], 0, 0, 3, 10; // +3 Hat, +10 Dagger
	setarray .@mailbound[0], 0, 0, Bound_Account, Bound_Char; // Account bounded Hat, Char bounded Dagger
	setarray .@mailcard0[0], 0, 0, 4198, 4092; // Attach Maya Purple Card to the Hat, Attach Skeleton Worker Card to Dagger
	setarray .@mailcard1[0], 0, 0, 0, 4092; // Attach Skeleton Worker Card to Dagger
	setarray .@mailcard2[0], 0, 0, 0, 4092; // Attach Skeleton Worker Card to Dagger
	mail .@charid, .@sender$, .@title$, .@body$, .@zeny, .@mailitem, .@mailamount, .@mailrefine, .@mailbound, .@mailcard0, .@mailcard1, .@mailcard2;
	
Example of sending mail with items and random options:
发送一个附带随机属性物品的邮件：
	.@charid = getcharid(0);
	.@sender$ = "Angeling";
	.@title$ = "Welcome";
	.@body$ = "Hi! I'm a simple Angeling from the Prontera fields! Welcome to Ragnarok!";
	.@zeny = 0;
	setarray .@mailitem[0], 504, 505, 2220, 1214; // White Potion, Blue Potion, Hat, Dagger
	setarray .@mailamount[0], 10, 5, 1, 1; // 10 White Potions, 5 Blue Potions, 1 Hat, 1 Dagger
	setarray .@mailrefine[0], 0, 0, 3, 10; // +3 Hat, +10 Dagger
	setarray .@mailbound[0], 0, 0, Bound_Account, Bound_Char; // Account bounded Hat, Char bounded Dagger
	setarray .@mailcard0[0], 0, 0, 4198, 4092; // Attach Maya Purple Card to the Hat, Attach Skeleton Worker Card to Dagger
	setarray .@mailcard1[0], 0, 0, 0, 4092; // Attach Skeleton Worker Card to Dagger
	setarray .@mailcard2[0], 0, 0, 0, 4092; // Attach Skeleton Worker Card to Dagger
	setarray .@mailcard3[0], 0, 0, 0, 0; // Empty last slot
	setarray .@mailrndopt_id0[0], 0, 0, 0, RDMOPT_VAR_MAXHPAMOUNT; // Enchant the Dagger with increased HP option
	setarray .@mailrndopt_val0[0], 0, 0, 0, 1000; // Enchant the Dagger with increased HP option by 1000 points
	setarray .@mailrndopt_prm0[0], 0, 0, 0, 0; // Enchant the Dagger with increased HP option - does not need any parameter
	mail .@charid, .@sender$, .@title$, .@body$, .@zeny, .@mailitem, .@mailamount, .@mailrefine, .@mailbound, .@mailcard0, .@mailcard1, .@mailcard2, .@mailcard3, .@mailrndopt_id0, .@mailrndopt_val0, .@mailrndopt_prm0;

---------------------------------------

*openauction({<char_id>});
*openauction({<角色编号>});

This will open the Auction window on the client connected to the invoking character.
使调用的角色客户端上开启一个拍卖窗口。

	mes "Close this window to open the Auction window.";   //mes "关闭窗口并打开拍卖窗口。";
	close2;
	openauction;
	end;

---------------------------------------
\\
4,2.- Guild-related commands
公会相关命令
\\
---------------------------------------

*guildopenstorage()

This function works the same as 'openstorage' but will open a guild storage
window instead for the guild storage of the guild the invoking character belongs
to.
此函数的作用与 "openstorage "相同，但会为调用角色所属公会的公会仓库打开一个公会仓库窗口。

Return values:
返回值:
 GSTORAGE_OPEN - Successfully opened.成功开启
 GSTORAGE_STORAGE_ALREADY_OPEN - Player storage is already open.玩家的仓库已经是开启状态
 GSTORAGE_ALREADY_OPEN - Guild storage is already open.工会仓库已经是开启状态
 GSTORAGE_NO_GUILD - Player is not in a guild.玩家未加入工会
 GSTORAGE_NO_STORAGE - Guild hasn't invested in the Guild Storage Expansion skill (only if OFFICIAL_GUILD_STORAGE is enabled).公会尚未投资公会存储扩展技能（仅当 OFFICIAL_GUILD_STORAGE 启用时）。
 GSTORAGE_NO_PERMISSION - Player doesn't have permission to use the guild storage.玩家没有使用公会仓库的权限。

---------------------------------------

*guildopenstorage_log({<char id>})
*guildopenstorage_log({<角色编号>})

Opens the guild storage log window for the attached character or the given character id.
打开关联角色或给定角色 ID 的公会存储日志窗口。

Possible return values:
可能的返回值:
GUILDSTORAGE_LOG_FINAL_SUCCESS	Window was opened successfully.窗口成功开启
GUILDSTORAGE_LOG_EMPTY			Window was not opened, because no entries exist.窗口未打开，因为不存在数据条目。
GUILDSTORAGE_LOG_FAILED			Some database error occurred.数据库发生错误。

---------------------------------------

*guild_has_permission(<permission>{,<char id>})
*guild_has_permission(<许可>{,<角色编号>})

Checks if the attached player or the player with the given character id has the given permission(s).
Permission can be a bitmask and allows to use multiple values at the same time.
Returns true if the player has all of the given permissions or false if the player does at least
miss one of the given permissions or is not in a guild at all
检查关联玩家或给定角色编号的玩家是否拥有给定权限。
权限可以是位掩码，允许同时使用多个值。
如果玩家拥有所有给定权限，则返回 true；
如果玩家至少缺少一个给定权限或根本没有加入公会，则返回 false

Available permissions are:
可用的权限包括:
GUILD_PERM_INVITE	If a player is allowed to invite other players.如果允许玩家邀请其他玩家。
GUILD_PERM_EXPEL	If a player is allowed to expel other guild members.如果允许玩家开除其他公会成员。
GUILD_PERM_STORAGE	If a player is allowed to access the guild storage.如果允许玩家访问公会仓库。
GUILD_PERM_ALL		A combination of all permissions above.上述所有权限的组合。

---------------------------------------

*guildchangegm(<guild id>,<new master's name>)
*guildchangegm(<工会编号>,<新主人的名字>)

This function will change the Guild Master of a guild. The ID is the guild's
id, and the new guild master's name must be passed.
此功能将更改一个公会的公会会长。
ID 是公会的 ID，必须输入新公会会长的名字。

Returns 1 on success, 0 otherwise.
成功则返回1，其他情况返回0

---------------------------------------

*guildgetexp <amount>;
*guildgetexp <数量>;

This will give the specified amount of guild experience points to the guild the
invoking character belongs to. It will silently fail if they do not belong to
any guild.
这将为关联角色所属的公会增加指定数量的公会经验值。
如果不属于任何公会，则会失败(无提示)。

---------------------------------------

*guildskill <skill id>,<level>
*guildskill "<skill name>",<level>
*guildskill <技能编号>,<等级>
*guildskill "<技能名称>",<等级>

This command will bump up the specified guild skill by the specified number of
levels. This refers to the invoking character and will only work if the invoking
character is a member of a guild AND its guild master, otherwise no failure
message will be given and no error will occur, but nothing will happen - same
about the guild skill trying to exceed the possible maximum. The full list of
guild skills is available in 'db/(pre-)re/skill_db.yml', these are all the GD_ skills at
the end.
这条命令会将指定的公会技能提升指定的等级。这是指调用角色，只有当调用角色是公会成员及其公会会长时才会起作用，
否则不会出现失败信息，也不会出错，但不会发生任何事情--公会技能如果超过最大值时也是如此。
公会技能的完整列表可在 "db/(pre-)re/skill_db.yml "中找到，这些都是置于最后的 GD_ skills(工会技能)。

// This would give your character's guild one level of Approval (GD_APPROVAL ID
// 10000). Notice that if you try to add two levels of Approval, or add
// Approval when the guild already has it, it will only have one level of
// Approval afterwards.
	guildskill 10000,1,0;
	
这将使您角色的正式公会认证等级提升1级（GD_APPROVAL正式工会认证的技能编号是10000）。	
请注意，如果您尝试提升2级正式公会认证等级，或在公会已经拥有正式工会认证1级的情况下再提升等级，
那么结果也是仅有1级的正式工会认证等级。

You might want to make a quest for getting a certain guild skill, make it hard
enough that all the guild needs to help or something. Doing this for the Glory
of the Guild skill, which allows your guild to use an emblem, is a good idea for
a fun quest.
您可能需要为获得某个公会技能制定一个任务，让它变得足够难，以至于需要所有公会的人都来帮忙之类的。
公会的荣耀技能可以让您的公会使用图标，该指令可以用来设计一个实现这个技能的有趣任务。

---------------------------------------
//
4,2 End of guild-related commands.
公会相关命令结束
//
---------------------------------------

*resetlvl <action type>{,<char_id>};
*resetlvl <操作类型>{,<角色编号>};

This is a character reset command, meant mostly for rebirth script supporting
Advanced jobs, which will reset the invoking character's stats and level
depending on the action type given. Valid action types are:
这是一个角色重置命令，主要用于高阶职业的转生脚本，
它将根据给定的操作类型重置调用角色的属性和等级。
有效的操作类型包括


 1 - Base level 1, Job level 1, 0 skill points, 0 base exp, 0 job exp, wipes the
     status effects (only the ones settable by 'setoption'), sets all stats to 1.
     If the new job is 'Novice High', give 100 status points, give First Aid and
     Play Dead skills.
 2 - Base level 1, Job level 1, 0 skill points, 0 base exp, 0 job exp.
     Skills and attribute values are not altered.
 3 - Base level 1, base exp 0. Nothing else is changed.
 4 - Job level 1, job exp 0. Nothing else is changed.
 
 1 - 基础等级1,职业等级1,技能点数0,基础经验值0,职业经验值0, 
     会清除状态效果(仅 "setoption "可设置的状态效果), 将所有素质点数设置为1。
     如果新职业是'超级初心者', 将给与100素质点数, 给与紧急治疗和装死技能。
 2 - 基础等级1,职业等级1,技能点数0,基础经验值0,职业经验值0, 
     技能和属性值不会改变。
 3 - 基础等级1, 基础经验值0。其他没有任何变化。
 4 - 职业等级1, 职业经验值0。其他没有任何变化。
 

In all cases everything the character has on will be unequipped.
所有情况下，角色身上的所有装备都将卸除。

Even though it doesn't return a value, it is used as a function in the official
rebirth scripts. Ask AppleGirl why.
尽管它不返回值，但在官方转生脚本中，它被用作一个函数。
问问 AppleGirl 为什么。

---------------------------------------

*resetstatus({<char_id>});
*resetstatus({<角色编号>});

This is a character reset command, which will reset the stats on the invoking
character and give back all the stat points used to raise them previously.
Nothing will happen to any other numbers about the character.
这是一个角色重置命令，它将重置调用角色的素质点，并返还之前用来提升素质的所有素质点数。
调用角色的其他数值不会发生任何变化。

Used in reset NPC's (duh!)
用于重置NPC(噗!)

---------------------------------------

*resetskill({<char_id>});
*resetskill({<角色编号>});

This command takes off all the skill points on the invoking character, so they
only have Basic Skill blanked out (lvl 0) left, and returns the points for them
to spend again. Nothing else will change but the skills. Quest skills will also
reset if 'quest_skill_reset' option is set to Yes in 'battle_athena.conf'. If
the 'quest_skill_learn' option is set in there, the points in the quest skills
will also count towards the total.
该命令会重置调用角色的所有技能，使其只剩下基本技能，其余空白（0 级），
然后返回技能点数供其再次加点。除了技能加点，其他数值都不会改变。
如果在 "battle_athena.conf "中将 "quest_skill_reset "选项设置为是，任务技能也会重置。
如果在其中设置了 "quest_skill_learn"选项，任务技能的点数也将计入总点数。


Used in reset NPC's (duh!)
用于重置NPC(噗!)

---------------------------------------

*resetfeel({<char_id>});
*resetfeel({<角色编号>});

This command will reset the Star Gladiator's designated maps on the invoking character.
Only works on Star Gladiator and Star Emperor classes.
该命令将重置调用角色(拳圣)相关技能定义的地图。
仅用于拳圣太阳、月亮、星星技能相关。


---------------------------------------

*resethate({<char_id>});
*resethate({<角色编号>});

This command will reset the Star Gladiator's designated monsters on the invoking character.
Only works on Star Gladiator and Star Emperor classes.
该命令将重置调用角色(拳圣)相关技能定义的魔物。
仅用于拳圣太阳、月亮、星星技能相关。

---------------------------------------

*sc_start <effect type>,<ticks>,<value 1>{,<rate>,<flag>{,<GID>}};
*sc_start2 <effect type>,<ticks>,<value 1>,<value 2>{,<rate>,<flag>{,<GID>}};
*sc_start4 <effect type>,<ticks>,<value 1>,<value 2>,<value 3>,<value 4>{,<rate>,<flag>{,<GID>}};
*sc_end <effect type>{,<GID>};
*sc_end_class {<char_id>{,<job_id>}};

*sc_start <效果类型>,<持续时间>,<变量1>{,<几率>,<标识>{,<GID>}};
*sc_start2 <效果类型>,<持续时间>,<数值 1>,<数值 2>{,<几率>,<标识>{,<GID>}};
*sc_start4 <效果类型>,<持续时间>,<数值 1>,<数值 2>,<数值 3>,<数值 4>{,<几率>,<标识>{,<GID>}};
*sc_end <效果类型>{,<GID>};
*sc_end_class {<角色编号>{,<职业编号>}};

These commands will bestow a status effect on a character.
这些命令会改变角色附加的状态效果。

The <effect type> determines which status is invoked. This can be either a number
or constant, with the common statuses (mostly negative) found in 'src/map/script_constants.hpp'
with the 'SC_' prefix. A full list is located in 'src/map/status.hpp', though
they are not currently documented.
< 效果类型> 决定调用哪种状态。这可以是一个数字或常量，常用状态（大多为负面状态）
可在 "src/map/script_constants.hpp "中找到，并带有 "SC_"前缀。
完整的列表位于 "src/map/status.hpp "中，不过目前还没有记录。

The duration of the status is given in <ticks>, or milleseconds.
Use INFINITE_TICK for infinite duration.
状态持续时间以 <持续时间> ，毫秒为单位。
使用 INFINITE_TICK 表示持续时间无限。

Certain status changes take an additional parameter <value 1>, which typically
modifies player stats by the given number or percentage. This differs for each
status, and is sometimes zero.
某些状态更改需要一个附加参数 <数值 1>，通常会按给定的数字或百分比修改玩家的状态。
每种状态都不同，有时为零。

Optional value <rate> is the chance that the status will be invoked (100 = 1%).
This is used primarily in item scripts. When used in an NPC script, a flag MUST
be defined for the rate to work.
可选值 <几率> 是状态被调用的几率（100 = 1%）。主要用于物品脚本。
在 NPC 脚本中使用时，必须定义一个标识才能使几率生效。

Optional value <flag> is how the status change start will be handled (a bitmask).
可选值 <标识> 表示状态变更的处理方式（采用位掩码）。
 SCSTART_NOAVOID   : Status change cannot be avoided.  状态变化无法回避。
 SCSTART_NOTICKDEF : Tick cannot be reduced by stats (default).  持续时间不会被素质加点影响（默认值）。
 SCSTART_LOADED    : sc_data loaded, so no value will be altered.  加载 sc_data，因此不会更改任何值。
 SCSTART_NORATEDEF : Rate cannot be reduced.  不会降低命中几率
 SCSTART_NOICON    : Status icon won't be sent to client  状态图标不会发送给客户端

If a <GID> is given, the status change will be invoked on the specified character
instead of the one attached to the script. This can only be defined after setting
a rate and flag.
如果给出 <GID>，则状态更改将在指定的角色上调用，而不是脚本所关联的角色。
这只能在设置几率和标识后定义。

'sc_start2' and 'sc_start4' allow extra parameters to be passed, and are used only
for effects that require them. The meaning of the extra values vary depending on the
effect type. For more infos, read status_change.txt containing a list of all Status Changes
and theirs val1, val2, val3, and val4 usage in source.
sc_start2 "和 "sc_start4 "允许传递额外参数，仅用于需要这些参数的效果。额外值的含义因效果类型而异。
如需了解更多信息，请阅读 status_change.txt，其中包含源代码中所有状态更改及其 val1、val2、val3 和 val4 的用法。

'sc_end' will remove a specified status effect. If SC_ALL (-1) is given, it will
perform a complete removal of all statuses (although permanent ones will re-apply).
sc_end "将删除指定的状态效果。如果给出 SC_ALL (-1)，则会完全删除所有状态（尽管永久状态会重新附加）。

'sc_end_class' works like 'sc_end' but will remove all status effects from any learned
skill on the invoking character. If <job_id> is provided it will end the effect for that job.
sc_end_class "的作用类似于 "sc_end"，但会移除调用角色所学技能的所有状态效果。
如果附加了<职业编号>参数，则会终止该职业的效果。

Examples:
例子:
	// This will poison the invoking character for 10 minutes at 50% chance.
	//这将使调用者中毒 10 分钟，几率为 50%。
	sc_start SC_POISON,600000,0,5000;

	// This will bestow the effect of Level 10 Blessing.
	//这将赋予 10 级天赐效果。
	sc_start SC_BLESSING,240000,10;

	// Adjust element resistance by percentage. Sample with Resist_Fire item script:
	// val1: Water resistance
	// val2: Earth resistance
	// val3: Fire resistance
	// val4: Wind resistance
	// 按百分比调整元素抗性。使用"火属性抵抗药水"物品脚本进行示例：
	// 变量1: 水属性抗性
	// 变量2: 地属性抗性
	// 变量3: 火属性抗性
	// 变量4: 风属性抗性
	sc_start4 SC_ARMOR_ELEMENT,1200000,-15,0,20,0;

	// This will end the Freezing status for the invoking character.
	//这将结束调用角色的冰冻状态。
	sc_end SC_FREEZE;
	
	// This will end the effect of any learned skill for the invoking character.
	//这将终止调用角色所学技能的效果。
	sc_end_class;
	
	// This will end the effect of any learned skill for the character with the <char_id> 150000.
	// val1: <char_id>
	// 这将终止<角色编号> 150000 角色所学技能的效果。
	// 变量1: <角色编号>
	sc_end_class(150000);
	
	// This will end the effect of any Arch Bishop skill for the invoking character.
	// val1: <char_id>
	// val2: <job_id> of Arch Bishop
	// 这将终止调用角色的大主教技能效果。
	// 变量1: <角色编号>
	// 变量2: <职业id> 大主教
	sc_end_class(getcharid(0),Job_Arch_Bishop);

Note: to use SC_NOCHAT you should alter Manner
注意：要使用 SC_NOCHAT，应更改Manner值
	set Manner, -5;	// Will mute a user for 5 minutes   将使用者禁言 5 分钟
	set Manner, 0;	// Will unmute a user   将取消使用者户禁言状态
	set Manner, 5;	// Will unmute a user and prevent the next use of 'Manner'   将取消使用者户禁言状态，并阻止下一次使用 "Manner"。

---------------------------------------

*getstatus(<effect type>{,<type>{,<char_id>}})
*getstatus(<效果类型>{,<类型>{,<角色编号>}})

Retrieve information about a specific status effect when called. Depending on <type>
specified the function will return different information.
在调用时读取特定状态效果的信息。
根据指定的 <类型>，函数将返回不同的信息。

Possible <type> values:
允许的 <类型> 值：
	- 0 or undefined: whether the status is active    0或未定义：状态是否附加
	- 1: the val1 of the status                       1：状态的 变量1
	- 2: the val2 of the status                       2：状态的 变量2
	- 3: the val3 of the status                       3：状态的 变量3
	- 4: the val4 of the status                       4：状态的 变量4
	- 5: the amount of time in milliseconds that the status has remaining   5：状态的剩余时间（毫秒）。

If <type> is not defined or is set to 0, then the script function will either
return 1 if the status is active, or 0 if the status is not active. If the status
is not active when any of the <type> fields are provided, this script function
will always return 0.
如果未定义 <类型> 或将其设置为 0，那么脚本函数将在状态附加时返回 1，或在状态未附加时返回 0。
如果在提供任何 <类型> 字段时状态都未附加，则此脚本函数将始终返回 0。

---------------------------------------

*skilleffect <skill id>,<number>;
*skilleffect "<skill name>",<number>;
*skilleffect <技能编号>,<数字>;
*skilleffect "<技能名称>",<数字>;

This command displays visual and aural effects of given skill on currently
attached character. The number parameter is for skill whose visual effect
involves displaying of a number (healing or damaging). Note, that this command
will not actually use the skill, it is intended for scripts, which simulate
skill usage by the NPC, such as buffs, by setting appropriate status and
displaying the skill's effect.
该命令显示当前关联角色的特定技能的视觉和听觉效果。
数字参数用于显示技能的数字（治疗或伤害）视觉效果。

	mes "Be blessed!";
	// Heal of 2000 HP     加血2000HP
	heal 2000,0;
	skilleffect 28,2000;     //显示加血动画，数字2000
	// Blessing Level 10    天赐10级
	sc_start SC_BLESSING,240000,10;
	skilleffect 34,0;
	// Increase AGI Level 5      加速5级
	sc_start SC_INCREASEAGI,140000,5;
	skilleffect 29,0;        //显示加速动画，不显示数字

This will heal the character with 2000 HP, buff it with Blessing Lv 10 and
Increase AGI Lv 5, and display appropriate effects.
这将为角色加血2000并追加天赐10级效果和5级加速效果，
并且显示相应的特效动画。

---------------------------------------

*npcskilleffect <skill id>,<number>,<x>,<y>;
*npcskilleffect "<skill name>",<number>,<x>,<y>;
*npcskilleffect <技能编号>,<数字>,<x坐标>,<y坐标>;
*npcskilleffect "<技能名称>",<数字>,<x坐标>,<y坐标>;

This command behaves identically to 'skilleffect', however, ground type skill
effects will be centered at the map coordinates given on the same map as the
attached character and all other skill types will be centered on the attached
character.

该命令的用法与 "skilleffect "相同，但地面类型的技能效果将以所给的地图坐标为中心，
并与所关联的角色位于同一张地图上，而所有其他类型的技能效果将以所关联的角色为中心。

---------------------------------------

*specialeffect <effect number>{,<send_target>{,"<NPC Name>"}};
*specialeffect <特效编号>{,<发送目标>{,"<NPC名称>"}};

This command will display special effect with the given number, centered on the
specified NPCs coordinates, if any. For a full list of special effect numbers
known see 'doc/effect_list.txt'. Some effect numbers are known not to work in
some client releases. (Notably, rain is absent from any client executables
released after April 2005.)
此命令将以指定的 NPC 坐标（如果有）为中心，用给定的编号显示特效。
有关已知特效编号的完整列表，请参阅 "doc/effect_list.txt"。
某些效果编号在某些客户端版本中无法使用。

<NPC name> parameter will display <effect number> on another NPC. If the NPC
specified does not exist, the command will do nothing. When specifying an NPC,
<send_target> must be specified when specifying an <NPC Name>, specifying AREA
will retain the default behavior of the command.
如果指定<NPC名称>参数，则将在指定的NPC身上显示对应的<效果编号>。
如果指定的 NPC 不存在，命令将不起作用。指定 NPC 时，
必须在指定 <NPC 名称> 时指定 <发送目标>，指定AREA常量将保留命令的默认作用。

	// this will make the NPC "John Doe#1"        这将使 NPC "John Doe#1 "
	// show the effect "EF_HIT1" specified by     显示 Jane Doe 指定的效果"EF_HIT1"。
	// Jane Doe. I wonder what John did...        我想知道John做了什么...
	mes "[Jane Doe]";
	mes "Well, I never!";
	specialeffect EF_HIT1,AREA,"John Doe#1";
	close;

---------------------------------------

*specialeffect2 <effect number>{,<send_target>{,"<Player Name>"}};
*specialeffect2 <特效编号>{,<发送目标>{,"<玩家名称>"}};

This command behaves identically to 'specialeffect', but the effect will be
centered on the invoking character's sprite.
该命令的作用与 "specialeffect "相同，但显示效果将以调用角色的图像为中心。

<Player name> parameter will display <effect number> on another Player than the
one currently attached to the script. Like with specialeffect, when specifying
a player, <send_target> must be supplied, specifying AREA will retain the default
behavior of the command.
<玩家名称>参数将在另一个玩家身上显示<效果编号>，而不是当前关联脚本的玩家。
与 specialeffect 一样，在指定玩家时，必须指定 <发送目标> ，
指定 AREA 常量将保留命令的默认作用。

---------------------------------------

*removespecialeffect <effect number>{,<send_target>{,"<NPC Name>"}};
*removespecialeffect <效果编号>{,<发送目标>{,"<NPC名称>"}};

Work for 2018-10-02+   2018-10-02+的客户端才能运行
This command behaves parameter same as 'specialeffect', but use for remove effect with <effect number>
from invoking NPC.
此命令的参数与 "specialeffect"相同，但用于从调用的 NPC 中移除带有<效果编号>的效果。

---------------------------------------

*removespecialeffect2 <effect number>{,<send_target>{,"<Player Name>"}};

Work for 2018-10-02+   2018-10-02+的客户端才能运行
This command behaves parameter same as 'specialeffect2', but use for remove effect with <effect number>
from invoking character.
该命令的参数与 "specialeffect2"相同，但用于从调用角色中移除带有<效果编号>的效果。

---------------------------------------

*statusup <stat>{,<char_id>};
*statusup <素质点>{,<角色编号>};

This command will change a specified stat of the invoking character up by one
permanently. Stats are to be given as number, but you can use these constants to
replace them:
这条命令会改变角色的指定素质点令其永久性上升。
素质点将以数字形式给出，但您可以使用以下常量来代替：

bStr -  Strength
bVit -  Vitality
bInt -  Intelligence
bAgi -  Agility
bDex -  Dexterity
bLuk -  Luck

---------------------------------------

*statusup2 <stat>,<amount>{,<char_id>};
*statusup2 <素质点>,<数值>{,<角色编号>};

This command will change a specified stat of the invoking character by the
specified amount permanently. The amount can be negative. See 'statusup'.
此命令将永久改变关联角色的指定素质点，将变量改为指定值。
数值可以是负数。参见 "statusup"。

	// This will decrease a character's Vit forever.   将会永远降低一个角色的Vit
	statusup2 bVit,-1;

---------------------------------------

*traitstatusup <stat>{,<char_id>};
*traitstatusup <素质属性>{,<角色编号>};

This command will change a specified trait stat of the invoking character up by one
permanently. Trait stats are to be given as number, but you can use these constants to
replace them:
这条命令会将调用角色的指定素质属性永久上调一个。
素质属性将以数字形式给出，但您可以使用这些常量来代替它们：

bPow -  Power
bSta -  Stamina
bWis -  Wisdom
bSpl -  Spell
bCon -  Concentration
bCrt -  Creative

---------------------------------------

*traitstatusup2 <stat>,<amount>{,<char_id>};
*traitstatusup2 <素质属性>,<数量>{,<角色编号>};

This command will change a specified trait stat of the invoking character by the
specified amount permanently. The amount can be negative. See 'statusup'.
该命令将永久改变调用角色的指定属性，改变数量为指定值。数值可以是负数。请参阅 "statusup"。

	// This will decrease a character's Sta forever.     这将永远降低角色的 Sta 值。
	traitstatusup2 bSta,-1;

---------------------------------------

*bonus <bonus type>,<val1>;
*bonus2 <bonus type>,<val1>,<val2>;
*bonus3 <bonus type>,<val1>,<val2>,<val3>;
*bonus4 <bonus type>,<val1>,<val2>,<val3>,<val4>;
*bonus5 <bonus type>,<val1>,<val2>,<val3>,<val4>,<val5>;
*bonus <加成类型>,<变量1>;
*bonus2 <加成类型>,<变量1>,<变量2>;
*bonus3 <加成类型>,<变量1>,<变量2>,<变量3>;
*bonus4 <加成类型>,<变量1>,<变量2>,<变量3>,<变量4>;
*bonus5 <加成类型>,<变量1>,<变量2>,<变量3>,<变量4>,<变量5>;

These commands are meant to be used in item scripts. They will probably work
outside item scripts, but the bonus will not persist for long. They, as
expected, refer only to an invoking character.
这些命令用于物品脚本。虽然可能会在物品脚本之外发挥作用，但加成不会持续太久。
预计，只作用于调用的角色。

You can find the full list of possible bonuses and which command to use for each
kind in 'doc/item_bonus.txt'.
您可以在 "doc/item_bonus.txt "中找到可用加成的完整列表，以及每种加成对应的命令。

---------------------------------------

*autobonus <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*autobonus2 <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*autobonus3 <bonus script>,<rate>,<duration>,<skill id>,{<other script>};
*autobonus3 <bonus script>,<rate>,<duration>,"<skill name>",{<other script>};
*autobonus <加成脚本>,<几率>,<持续时间>{,<标识>,{<其他脚本>}};
*autobonus2 <加成脚本>,<几率>,<持续时间>{,<标识>,{<其他脚本>}};
*autobonus3 <加成脚本>,<几率>,<持续时间>,<技能编号>,{<其他脚本>};
*autobonus3 <加成脚本>,<几率>,<持续时间>,"<技能名称>",{<其他脚本>};

These commands are meant to be used in item scripts. They will probably work
outside item scripts, but the bonus will not persist for long. They, as
expected, refer only to an invoking character.
这些命令用于物品脚本。虽然可能会在物品脚本之外发挥作用，但加成不会持续太久。
预计，只作用于调用的角色。

What these commands do is 'attach' a script to the player which will get
executed on attack (or when attacked in the case of autobonus2).
这些命令的作用是将一个脚本 "附加 "到玩家身上，该脚本将在玩家受到攻击时执行
（或在autobonus2的情况下，在玩家受到攻击时执行）。

Rate is the trigger rate of the script (1000 = 100%).
几率是脚本的触发几率(1000 = 100%)。

Duration is the time in milliseconds that the bonus will last for since the script has triggered.
持续时间是指脚本触发后加成持续的时间（以毫秒为单位）。

Skill ID/skill name the skill which will be used as trigger to start the bonus. (autobonus3)
"技能编号/技能名称"参数是用来触发加成的技能。（autobonus3）

The optional argument 'flag' is used to classify the type of attack where the script
can trigger (it shares the same flags as the bAutoSpell bonus script):
可选参数 "标识"用于分类脚本可触发的攻击类型（它与加成脚本 bAutoSpell 的标识相同，
可触发的攻击类型（与加成脚本 bAutoSpell 对应的标识一致）：

Range criteria:  距离判定
	BF_SHORT:  Trigger on melee attack    BF_SHORT: 近战攻击时触发
	BF_LONG:   Trigger on ranged attack   BF_LONG:  远程攻击时触发
	Default:   BF_SHORT+BF_LONG           Default： 默认近战+远程攻击时触发
Attack type criteria:  攻击类型判定
	BF_WEAPON: Trigger on weapon skills    BF_WEAPON: 武器技能攻击时触发
	BF_MAGIC:  Trigger on magic skills     BF_MAGIC:  魔法技能攻击时触发
	BF_MISC:   Trigger on misc skills      BF_MISC:   其他技能攻击时触发
	Default:   BF_WEAPON                   Default:   默认武器技能攻击时触发
Skill criteria:   技能判定
	BF_NORMAL: Trigger on normal attacks                                     BF_NORMAL: 普通攻击时触发
	BF_SKILL:  Trigger on skills                                             BF_SKILL:  技能攻击时触发
	default:   If the attack type is BF_WEAPON (only) BF_NORMAL is used,     default:   默认如果攻击类型为使用BF_WEAPON(仅当)  BF_NORMAL，
		   otherwise BF_SKILL+BF_NORMAL is used.                                        否则为使用BF_SKILL+BF_NORMAL。

The difference between the optional argument 'other script' and the 'bonus script' is that,
the former one triggers only when attacking(or attacked) and the latter one runs on
status calculation as well, which makes sure, within the duration, the "bonus" that get
lost on status calculation is restored. So, 'bonus script' is technically supposed to accept
"bonus" command only. And we usually use 'other script' to show visual effects.
可选参数 "其他脚本 "与 "加成脚本 "的区别在于，前者仅在攻击（或被攻击）时触发，而后者在状态计算时也会运行，
这就确保了在持续时间内，在状态计算时丢失的"加成"会得到恢复。
因此，从技术上讲，"加成脚本"应该只接受
"bonus" 命令。而我们通常使用 "其他脚本"来显示视觉效果。

In all cases, when the script triggers, the attached player will be the one
who holds the bonus. There is currently no way of knowing within this script
who was the other character (the attacker in autobonus2, or the target in
autobonus and autobonus3).
在所有情况下，当脚本触发时，关联玩家将独自获得加成。
目前该脚本无法获知谁是另一个角色（autobonus2 中的攻击者，或 autobonus 和 autobonus3 中的目标）。

//Grants a 1% chance of starting the state "all stats +10" for 10 seconds when
//using weapon or misc attacks (both melee and ranged skills) and shows a special
//effect when the bonus is active.
//使用武器或其他攻击（包括近战和远程技能）时，有 1%的几率启动 "所有素质点 +10 "状态，
//持续 10 秒，并在加成激活时显示特殊效果。
	autobonus "{ bonus bAllStats,10; }",10,10000,BF_WEAPON|BF_MISC,"{ specialeffect2 EF_FIRESPLASHHIT; }";

---------------------------------------

*bonus_script "<script code>",<duration>{,<flag>{,<type>{,<status_icon>{,<char_id>}}}};
*bonus_script "<脚本代码>",<持续时间>{,<标识>{,<类型>{,<状态图标>{,<角色编号>}}}};

This command will attach a script to a player for a given duration, in seconds.
After that time, the script will automatically expire. The same bonus cannot be
stacked. By default, this bonus will be stored on `bonus_script` table when player
logs out.
这条命令会在指定的时间（以秒为单位）内将脚本附加到玩家身上。
之后，脚本将自动失效。
同一加成不可叠加。默认情况下，当玩家离线时，该加成将存储在`bonus_script`表中。

Flags (bitmask):  标识(掩码)：
	1   : Remove when dead.                                                           1   : 死亡时移除。
	2   : Removable by Dispell.                                                       2   : 可通过魔法效果解除技能移除。
	4   : Removable by Clearance.                                                     4   : 可通过净化技能移除。
	8   : Remove when player logs out.                                                8   : 玩家离线时移除。
	16  : Removeable by Banishing Buster.                                             16  : 可通过强制驱逐技能移除
	32  : Removable by Refresh.                                                       32  : 可通过Refresh技能移除.
	64  : Removable by Lux Anima.                                                     64  : 可通过Lux Anima技能移除.
	128 : Remove when Madogear is activated or deactivated.                           128 : 激活或停用 魔导机械 时移除。
	256 : Remove when receive damage.                                                 256 : 受攻击伤害时移除.
	512 : Script is permanent, cannot be cleared by bonus_script_clear.               512 : 永久性的脚本，无法通过 bonus_script_clear 移除。
	1024: Force to replace duplicated script by expanding the duration.               1024: 通过延长持续时间，强制替换重复的脚本。
	2048: Force to add duplicated script. This flag cannot be stacked with 1024,      2048: 强制添加重复脚本。此标识不能与 1024 标识叠加使用，
	      if both are defined, 1024 will be checked first and ignore this flag.             如果同时定义了这两个标识，将首先检查 1024 标识，而忽略此标识。

Types:  类型：
	This will be used to decide negative or positive buff for 'debuff_on_logout'.
	这将用于确定 "离线时的负面加成" 为负面加成或正面加成。
	0: Ignore the buff type and won't be removed if the flag is not &8 (Default)   0:忽略加成类型，如果标记不是 &8 则不会移除（默认值）
	1: Buff                                                                        1:正面加成
	2: Debuff                                                                      2:负面加成

Status_icon: See "Status Icon" section in 'src/map/script_constants.hpp'. Default is SI_BLANK (-1).
状态图标： 请参阅 "src/map/script_constants.hpp "中的 "Status Icon"部分。默认为 SI_BLANK (-1)。

Example:  例子：
  - Id: 512
    AegisName: Apple
    Name: Apple
    Type: Healing
    Buy: 15
    Weight: 20
    Flags:
      BuyingStore: true
    Script: |
      bonus_script "{ bonus bStr,5; }",60;

---------------------------------------

*bonus_script_clear {<flag>,{<char_id>}};
*bonus_script_clear {<标识>,{<角色编号>}};

Removes attached bonus_script from player. If no 'char_id' given, it will removes
from the invoker.
从玩家身上移除附加的脚本加成。如果没有给出 "角色编号"，则从调用者中移除。

If 'flag' is 1, means will clears all scripts even it's Permanent effect. By default,
it just removes non-permanent script.
如果 "标识"为 1，表示将移除所有脚本，即使是永久效果。默认情况下，它只会移除非永久性脚本。

---------------------------------------

*plagiarizeskill <skill_id>,<level>;
*plagiarizeskill <技能编号>,<等级>;

Enable the player to plagiarize specific skills that are copyable.
Return 1 on success, 0 otherwise.
允许玩家抄袭可复制的特定技能。
成功时返回 1，否则返回 0。

Note:
注意：
 - Plagiarism only able to copy skill while SC_PRESERVE is not active and skill is copyable by Plagiarism.     抄袭只能在 SC_PRESERVE 未激活且 "抄袭"可复制技能时复制技能。
 - Reproduce can copy skill if SC__REPRODUCE is active and the skill is copyable by Reproduce.                 如果 SC__REPRODUCE 处于激活状态，且复制可以复制技能，则复制可以复制技能。

---------------------------------------

*plagiarizeskillreset <flag>;
*plagiarizeskillreset <标志>;

Remove a plagiarized skill from the player.         删除玩家抄袭的技能。
Return 1 on success, 0 otherwise.                   成功时返回 1，否则返回 0。

Flag constants:
标志常量：
	1 - Use for Plagiarism Skill       用于抄袭技能
	2 - Use for Reproduce Skill        用于复制技能

---------------------------------------

*skill <skill id>,<level>{,<flag>};
*skill "<skill name>",<level>{,<flag>};
*addtoskill <skill id>,<level>{,<flag>};
*addtoskill "<skill name>",<level>{,<flag>};
*skill <技能编号>,<等级>{,<标识>};
*skill "<技能名称>",<等级>{,<标识>};
*addtoskill <技能编号>,<等级>{,<标识>};
*addtoskill "<技能名称>",<等级>{,<标识>};

These commands will give the invoking character a specified skill. This is also
used for item scripts.
这些命令将赋予调用角色指定的技能。这也是用于物品脚本。

Level is obvious. Skill id is the ID number of the skill in question as per
'db/(pre-)re/skill_db.yml'. It is not known for certain whether this can be used to give
a character a monster's skill, but you're welcome to try with the numbers given
in 'db/(pre-)re/mob_skill_db.txt'.
<等级>用于指定提升等级的数值，技能编号是 "db/(pre-)re/skill_db.yml "中相关技能的编号。
目前还不确定是否可以用它来为角色赋予怪物的技能，
但欢迎使用 "db/(pre-)re/mob_skill_db.txt "中给出的编号进行尝试。

Flag is 0 if the skill is given permanently (will get written with the character
data) or 1 if it is temporary (will be lost eventually, this is meant for card
item scripts usage.).  The flag parameter is optional, and defaults to 1 in
'skill' and to 2 in 'addtoskill'.
如果该技能是永久性的（会与角色数据一起写入），则标识为 0；
如果是临时性的（可移除，这是为卡片物品脚本使用而设置的），则标识为 1。
标识参数是可选的，在 "skill"中默认为 1，在 "addtoskill"中默认为 2。

Flag 2 means that the level parameter is to be interpreted as a stackable
additional bonus to the skill level. If the character did not have that skill
previously, they will now at 0+the level given.
标识 2 表示将等级参数定义为技能等级的可叠加额外加成。
如果角色之前没有该技能，则当前的技能等级为 0+。

Flag 3 is the same as flag 1 in that it saves to the database.  However, these skills
are ignored when any action is taken that adjusts the skill tree (reset/job change).
标识 3 与标识 1 相同，都会保存到数据库中。 
不过，在执行任何调整技能树的操作（重置/更改任务）时，这些技能将被忽略。

Flag constants:   标识常量:
	0 - SKILL_PERM
	1 - SKILL_TEMP
	2 - SKILL_TEMPLEVEL
	3 - SKILL_PERM_GRANT

// This will permanently give the character Stone Throw (TF_THROWSTONE,152), at
// level 1.
//这将永久赋予角色投掷石头技能（TF_THROWSTONE,152），等级为 1。
    skill 152,1,0;

---------------------------------------

*nude {<char_id>};
*nude {<角色编号>};

This command will unequip anything equipped on the invoking character.
该命令将卸除调用角色身上的所有装备。

It is not required to do this when changing jobs since 'jobchange' will unequip
everything not equippable by the new job class anyway.
变更职业时不需要使用该命令，因为 "jobchange"会卸除所有新职业类别无法装备的物品。

---------------------------------------

*sit {"<character name>"};
*stand {"<character name>"};
*sit {"<角色名称>"};
*stand {"<角色名称>"};

These commands will make a character sit or stand.
If no character is specified, the command will run for the invoking character.
这些命令可以让角色坐下或站起。
如果没有指定角色，命令将作用于调用的角色。

Additionnally Sitting constant is true when the character is sitting, false otherwise.
此外，Sitting 常量在角色坐着时为 true，否则为 false。

---------------------------------------

*disguise <Monster ID>{,<char_id>};
*undisguise {<char_id>};
*disguise <魔物编号>{,<角色编号>};
*undisguise {<角色编号>};

This command disguises the current player with a monster sprite.
The disguise lasts until 'undisguise' is issued or the player logs out.
该命令会将当前玩家变更为怪物图档。
变更会持续到使用 "undisguise "命令或玩家离线为止。

Example:   例子：

disguise 1002; // Disguise character as a Poring.    玩家变为波利的样子
next;
undisguise; // Return to normal character sprite.    将玩家变为原样

---------------------------------------

*transform <monster ID>,<duration>{,<sc type>,<val1>,<val2>,<val3>,<val4>};
*transform "<monster name>",<duration>{,<sc type>,<val1>,<val2>,<val3>,<val4>};
*active_transform <monster ID>,<duration>{,<sc type>,<val1>,<val2>,<val3>,<val4>};
*active_transform "<monster name>",<duration>{,<sc type>,<val1>,<val2>,<val3>,<val4>};
*transform <魔物编号>,<持续时间>{,<状态类型>,<变量1>,<变量2>,<变量3>,<变量4>};
*transform "<魔物名称>",<持续时间>{,<状态类型>,<<变量1>,<变量2>,<变量3>,<变量4>};
*active_transform <魔物编号>,<持续时间>{,<状态类型>,<<变量1>,<变量2>,<变量3>,<变量4>};
*active_transform "<魔物名称>",<持续时间>{,<状态类型>,<<变量1>,<变量2>,<变量3>,<变量4>};

This command will turn a player into a monster for a given duration and can grant
a SC attribute effect while transformed. Note that players cannot be transformed
during War of Emperium or if already disguised.
Can only be removed when you die or the duration ends.
该指令会在一定时间内将玩家转变成魔物，并在变身后赋予 SC 状态效果。
请注意，在工会战期间或已经有转变的情况下，玩家不会变身。
只有当你死亡或持续时间结束时才能移除。

'transform' and 'active_transform' can stack on each other but using 'transform' or
'active_transform' twice will not stack (it will cancel the previous bonus for the new).
'active_transform' will take priority over transform for its duration.
transform "和 "active_transform "可以相互叠加，但使用两次 "transform "或 "active_transform "
不会叠加（会用新的状态取消之前的状态）。
"active_transform "将在其持续时间内优先于 "transform"。

---------------------------------------
\\
4,3 Marriage-related commands     与结婚相关的命令
\\
---------------------------------------

*marriage("<spouse name>");
*marriage("<配偶名称>");

This function will marry two characters, the invoking character and the one
referred to by name given, together, setting them up as each other's marriage
partner. No second function call has to be issued (in current SVN at least) to
make sure the marriage works both ways. The function returns 1 upon success, or
0 if the marriage could not be completed, either because the other character
wasn't found or because one of the two characters is already married.
该函数将使两个角色（调用者和配偶名称对应的角色）结婚，使他们成为对方的结婚对象。
无需调用第二个函数（至少在当前的版本中），以确保结婚双向生效。
如果成功，函数返回 1；如果由于找不到另一个角色或两个角色中的一个已经结婚而无法完成婚姻，
则函数返回 0。


This will do nothing else for the marriage except setting up the spouse ID for
both of these characters. No rings will be given and no effects will be shown.
除了为这两个角色设置配偶编码外，这对结婚没有任何其他作用。
不会赠送戒指，也不会显示任何效果。


---------------------------------------

*wedding;

This command will call up wedding effects - the music and confetti - centered on
the invoking character. Example can be found in the wedding script.
该命令将以调用角色为中心，调用婚礼特效--音乐和彩纸。示例可在婚礼脚本中找到。

---------------------------------------

*divorce({<char_id>})
*divorce({<角色编号>})

This function will "un-marry" the invoking character from whoever they were
married to. Both will no longer be each other's marriage partner, (at least in
current SVN, which prevents the cases of multi-spouse problems). It will return
1 upon success or 0 if the character was not married at all.
该命令将使调用者与已婚对象 "解除婚姻关系"。两人将不再是对方的婚姻伴侣
（至少在当前的版本中，这可以避免出现多配偶问题）。
如果成功，则返回 1；如果角色没有结婚，则返回 0。

This function will also destroy both wedding rings and send a message to both
players, telling them they are now divorced.
这条命令还会删除两个结婚戒指，并向双方发送一条信息，告诉他们现在已经离婚了。

---------------------------------------

*adopt("<parent_name>","<baby_name>");
*adopt(<parent_id>,<baby_id>);
*adopt("<父母名字>","<宝宝名字>");
*adopt(<父母编号>,<宝宝编号>);

This function will send the client adoption request to the specified baby
character. The parent value can be either parent. Both parents and the baby
need to be online in order for adoption to work.
这条命令将向指定的宝宝角色的客户端发送收养请求。
父母和宝宝都必须在线，领养才能成功。


Return values:  返回值：
 ADOPT_ALLOWED - Sent message to Baby to accept or deny.  向宝宝发送信息，选择接受或拒绝。
 ADOPT_ALREADY_ADOPTED - Character is already adopted.  角色已被领养。
 ADOPT_MARRIED_AND_PARTY - Parents need to be married and in a party with the baby.  父母必须已婚，并与宝宝在同一组队里。
 ADOPT_EQUIP_RINGS - Parents need wedding rings equipped.  父母必须都佩戴结婚戒指。
 ADOPT_NOT_NOVICE - Baby is not a Novice.  宝宝不是初心者。
 ADOPT_CHARACTER_NOT_FOUND - A parent or Baby was not found.   父母之一或者宝宝未找到。
 ADOPT_MORE_CHILDREN - You cannot adopt more than 1 child. (client message)  无法领养超过1个宝宝。(客户端信息)
 ADOPT_LEVEL_70 - Parents need to be at least level 70 in order to adopt someone. (client message)  父母必须至少70级才能领养。(客户端信息)
 ADOPT_MARRIED - You cannot adopt a married person. (client message)  无法领养已婚的角色。(客户端信息)

---------------------------------------
//
4,3.- End of marriage-related commands    与结婚相关的命令结束
//
---------------------------------------

*pcfollow <id>,<target id>;
*pcstopfollow <id>;
*pcfollow <账号>,<目标编号>;
*pcstopfollow <账号>;

Makes a character follow or stop following someone. This command does the same
as the @follow command. The main difference is that @follow can use character
names, and this commands needs the account ID for the target.
使角色跟随或停止跟随某人。该命令的功能与 @follow 命令相同。
主要区别在于 @follow 可以使用角色名，而该命令需要目标的账号。

Examples:  例子：
	// This will make Aaron follow Bullah, when both of these characters are online.
	//这样，当这两个角色都在线时，Aaron就会跟随Bullah。
	pcfollow getCharID(3,"Aaron"),getCharID(3,"Bullah");

	// Makes Aaron stop following whoever he is following.
	//让Aaron停止追随他所追随的人。
	pcstopfollow getCharID(3,"Aaron");

---------------------------------------

*pcblockmove <id>,<option>;
*unitblockmove <id>,<option>;
*pcblockmove <账号>,<选项>;
*unitblockmove <账号>,<选项>;

Prevents the given GID from moving when the option is 1, and enables the ID to
move again when the option is 0. This command will run for the attached unit
if the given GID is zero.
当选项为 1 时，阻止给定的 GID 移动；当选项为 0 时，使<账号>再次移动。
如果给定的 GID 为0，该命令将作用于其所关联的单位。

Examples:  例子：
	// Prevents the current char from moving away.  防止当前角色移动。
	pcblockmove getcharid(3),1;

	// Enables the current char to move again.   使当前角色可以再次移动。
	pcblockmove getcharid(3),0;

---------------------------------------

*pcblockskill <id>,<option>;
*unitblockskill <id>,<option>;
*pcblockskill <账号>,<选项>;
*unitblockskill <账号>,<选项>;

Prevents the given GID from casting skills when the option is 1, and enables
the ID to cast skills again when the option is 0. This command will run for
the attached unit if the given GID is zero.
当选项为 1 时，阻止给定的 GID 施放技能；当选项为 0 时，使该<账号>可以再次施放技能。
如果给定的 GID 为0，该命令将作用于其所关联的单位。

Examples:
	// Prevents the current char from casting skills.  阻止当前角色施放技能。
	pcblockskill getcharid(3),1;

	// Enables the current char to cast skills again.  使当前角色可以再次施放技能。
	pcblockskill getcharid(3),0;

---------------------------------------

*setpcblock <type>,<state>{,<account ID>};
*getpcblock {<account ID>};
*setpcblock <类型>,<状态>{,<账号编号>};
*getpcblock {<账号编号>};

'setpcblock' command prevents/allows the player from doing the given <type> of action according
to the <state> during the player session (note: @reloadscript removes all <type> except PCBLOCK_IMMUNE).
The <type> values are bit-masks, multiples of <type> can be added to change the player action.
"setpcblock"命令可阻止/允许玩家在会话期间根据 <状态> 执行给定的操作<类型>
（注：@reloadscript 会移除除 PCBLOCK_IMMUNE 以外的所有 <类型>）。
<类型>值是位掩码，可以添加<类型>的复合值来改变玩家的操作。

The action is blocked when the <state> is true, while false allows the action again.
当<状态>为 true 时，操作会被阻止，而 false 则允许再次执行操作。

'getpcblock' command return the bit-mask value of the currently
enabled block flags.
"getpcblock"命令返回当前启用的<类型>的位掩码值。

Available <type>:   可用的<类型>包括：
	PCBLOCK_MOVE				Prevent the player from moving.                                        阻止玩家移动。
	PCBLOCK_ATTACK				Prevent the player from attacking.                                     阻止玩家攻击。
	PCBLOCK_SKILL				Prevent the player from using skills/itemskills.                       阻止玩家使用技能/物品技能。
	PCBLOCK_USEITEM				Prevent the player from using usable items.                            阻止玩家使用可用物品。
	PCBLOCK_CHAT				Prevent the player from sending global/guild/party/whisper messages.   阻止玩家发送全局/公会/组队/悄悄话信息。
	PCBLOCK_IMMUNE				Prevent the player from being hit by monsters.                         阻止玩家被怪物攻击。
	PCBLOCK_SITSTAND			Prevent the player from sitting/standing.                              阻止玩家坐下/站立。
	PCBLOCK_COMMANDS			Prevent the player from using atcommands/charcommands.                 防止玩家使用 atcommands/charcommands 命令。
	PCBLOCK_NPCCLICK			Prevent the player from clicking/touching any NPC/shop/warp.           阻止玩家点击/触摸任何 NPC/商店/传送点。
	PCBLOCK_EMOTION				Prevent the player from using emotions.                                阻止玩家使用表情符号。
	PCBLOCK_NPC				Simulate NPC interaction. Useful for NPC with no mes window. Sum of PCBLOCK_MOVE|PCBLOCK_SKILL|PCBLOCK_USEITEM|PCBLOCK_COMMANDS|PCBLOCK_NPCCLICK.
	                        模拟 NPC 互动。适用于没有对话窗口的 NPC。PCBLOCK_MOVE|PCBLOCK_SKILL|PCBLOCK_USEITEM|PCBLOCK_COMMANDS|PCBLOCK_NPCCLICK 的总和。
	PCBLOCK_ALL				Sum of all the flags.                                                      上面所有标识的总和。

Examples:   例子：

// Make the attached player invulnerable to monster (same as @monsterignore)
// 使关联的玩家不受怪物攻击（与 @monsterignore 相同）
	setpcblock PCBLOCK_IMMUNE, true;

// Prevents the attached player from attacking and using skills
// 阻止玩家玩家攻击和使用技能
	setpcblock PCBLOCK_ATTACK|PCBLOCK_SKILL, true;

// Re-enables attack, skills and item use
// 重新允许攻击、技能和物品的使用
	setpcblock PCBLOCK_ATTACK|PCBLOCK_SKILL|PCBLOCK_USEITEM, false;

// getpcblock related checks
// getpcblock 相关检查
	if (getpcblock() & PCBLOCK_IMMUNE)
		mes "You are invulnerable!";

	if (getpcblock() & (PCBLOCK_MOVE|PCBLOCK_SITSTAND))
		mes "You can't walk or sit.";

	if ((getpcblock() & (PCBLOCK_ATTACK|PCBLOCK_SKILL)) == 0)
		mes "You can attack and use skills.";

	if (getpcblock() & PCBLOCK_CHAT)
		mes "You can't chat.";

---------------------------------------

macro_detector({<account ID>});
macro_detector({"<character name>"});
macro_detector({<账户编号>});
macro_detector({"<角色名称>"});

This command will display the captcha UI challenge onto the invoking character or the given <account ID>/<character name>.
此命令将向调用角色或给定的< 账户编号>/< 角色名称> 显示验证码UI。

Example:
例子：
	// Use 'getareaunits' to gather an area of players to test.    使用"getareaunits"收集玩家测试区域。
	// Build an int array of the account IDs.                      创建一个包含账户编码的整数数组。
	.@num = getareaunits(BL_PC, "prontera", 150, 150, 160, 160, .@array[0]);

	mes "The number of Players in Prontera in between 150x150 and 160x160 is " + .@num + " .";
	mes "Players to challenge:";
	freeloop(1); // If the list is too big
	for(.@i = 0; .@i < getarraysize(.@array); .@i++) {
		mes (.@i + 1) + " " + convertpcinfo(.@array[.@i], CPC_NAME);
		macro_detector .@array[.@i];
	}
	freeloop(0);
	end;

---------------------------------------

==================================
|5.- Mob / NPC -related commands.|    - 与魔物/NPC 相关的命令。
==================================
---------------------------------------

*monster     "<map name>",<x>,<y>,"<name to show>",<mob id>,<amount>{,"<event label>",<size>,<ai>};
*areamonster "<map name>",<x1>,<y1>,<x2>,<y2>,"<name to show>",<mob id>,<amount>{,"<event label>",<size>,<ai>};
*monster     "<地图名称>",<坐标x>,<坐标y>,"<显示名称>",<魔物编号>,<数量>{,"<事件标签>",<尺寸>,<ai>};
*areamonster "<地图名称>",<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>,"<显示名称>",<魔物编号>,<数量>{,"<事件标签>",<尺寸>,<ai>};

This command will spawn a monster on the specified coordinates on the specified
map. If the script is invoked by a character, a special map name, "this", will
be recognized to mean the name of the map the invoking character is located at.
This command works fine in the item scripts.
此命令将在指定地图上的指定坐标处生成一只魔物。
如果脚本是由一个角色调用的，那么一个特殊的地图名称 "this"将被识别为调用角色所在地图的名称。
该命令在物品脚本中也能正常执行。

The same command arguments mean the same things as described above in the
beginning of this document when talking about permanent monster spawns. Monsters
spawned in this manner will not respawn upon being killed.
这些命令参数的含义与本文开头所述的生成永久性魔物的方式相同。
以这种方式生成的魔物在被杀死后不会重生。

Unlike the permanent monster spawns, if the mob id is -1, a random monster will
be picked from the entire database according to the rules configured in the
server for dead branches. This will work for all other kinds of non-permanent
monster spawns.
与生成永久性魔物的方式不同，如果魔物编号为-1，则会根据服务器中对应数据库配置的规则，
从整个数据库中随机挑选一个魔物。这也适用于所有其他类型的非永久性魔物生成。

The only very special thing about this command is an event label, which is an
optional parameter. This label is written like '<NPC object name>::<label name>'
and upon the monster being killed, it will execute the script inside of the
specified NPC object starting from the label given. The RID of the player
attached at this execution will be the RID of the killing character.
The variable 'killedrid' is set to the Class (mob ID) of the monster killed.
The variable 'killedgid' is set to the ID (unique mob game ID) of the monster killed.
该命令唯一特别之处在于事件标签，这是一个可选参数。
该标签的写法类似于"<NPC对象名称>::<标签名称>"，怪物被杀死后，将会跳转到本脚本内标签位置处开始执行。
在执行此操作时，玩家关联的 RID 将是被杀角色的 RID。
变量 "killedrid"被设置为被击杀怪物的类别（怪物编号）。
变量 "killedgid "会被设置为被击杀怪物的编号（魔物在游戏中的唯一编号）。

<size> can be:   <尺寸> 可以是：
	Size_Small	(0)		(default)     (0)小型	(默认)
	Size_Medium	(1)                   (1)中型
	Size_Large	(2)                   (2)大型

<ai> can be:    <ai> 可以是：
	AI_NONE		(0)		(default)                 (0)		(默认)
	AI_ATTACK	(1)		(attack/friendly)         (1)		(攻击/被动)
	AI_SPHERE	(2)		(Alchemist skill)         (2)		(炼金技能)
	AI_FLORA	(3)		(Alchemist skill)         (3)		(炼金技能)
	AI_ZANZOU	(4)		(Kagerou/Oboro skill)     (4)		(影狼/胧技能)
	AI_LEGION	(5)		(Sera skill)              (5)		(赛拉[人工生命体]技能)
	AI_FAW		(6)		(Mechanic skill)          (6)		(机匠技能)

    monster "place",60,100,"Poring",1002,1,"NPCNAME::OnLabel";

The coordinates of 0,0 will spawn the monster on a random place on the map.
坐标 0,0 将在地图上的随机位置生成魔物。

The 'areamonster' command works much like the 'monster' command and is not
significantly different, but spawns the monsters within a square defined by
x1/y1-x2/y2.
"areamonster"命令的执行方式与 "monster"命令类似，没有明显区别，
但会在坐标 x1/y1-x2/y2 所定义的方格内生成怪物。

Returned value is an array with the game ID of the spawned monster(s) depending
on the amount spawned. Array is stored in $@mobid[].
返回值是一个数组，其中包含所生成魔物的游戏编号（取决于生成数量）。数组存储在 $@mobid[]。

Simple monster killing script:  简单的杀怪脚本：

		<Normal NPC object definition. Let's assume you called him NPCNAME.>    普通NPC对象定义。假设你将其命名为NPCNAME。
		mes "[Summon Man]";                                                     mes "[召唤者]";
		mes "Want to start the Poring hunt?";                                   mes "要开始狩猎波利吗?";
		next;                                                                   next;
		if (select("Yes.:No.") == 2) {                                          if (select("是:否") == 2) {
			mes "[Summon Man]";                                                 	mes "[召唤者]";
			mes "Come back later.";                                             	mes "稍后再来。";
			close;                                                              	close;
		}                                                                       }

		// Summon 10 Porings.   召唤10只波利
		// Using coordinates 0,0 will spawn them in a random location.    使用坐标 0,0 会在随机位置生成它们。
		monster "prontera",0,0,"Quest Poring",1002,10,"NPCNAME::OnPoringKilled";               monster "prontera",0,0,"任务波利",1002,10,"NPCNAME::OnPoringKilled";

		mes "[Summon Man]";                                                                    mes "[召唤者]";
		mes "Now go and kill all the Porings I summoned.";                                     mes "现在去消灭所有我召唤出来的波利。";
		close;                                                                                 close;

	OnPoringKilled:                                                                            OnPoringKilled:
		$PoringKilled++;                                                                       	$PoringKilled++;
		if ($PoringKilled >= 10) {                                                             	if ($PoringKilled >= 10) {
			announce "Summon Man: Well done. All the Porings are dead!",3;                     		announce "召唤者: 干得好。所有波利都消灭了!",3;
			$PoringKilled = 0;                                                                 		$PoringKilled = 0;
		}                                                                                      	}
		end;                                                                                   	end;

For more good examples see just about any official 2-1 or 2-2 job quest script.
更多示例，请参阅任何官方 2-1 或 2-2 转职任务脚本。

---------------------------------------

*areamobuseskill "<map name>",<x>,<y>,<range>,<mob id>,<skill id>,<skill level>,<cast time>,<cancelable>,<emotion>,<target type>;
*areamobuseskill "<map name>",<x>,<y>,<range>,<mob id>,"<skill name>",<skill level>,<cast time>,<cancelable>,<emotion>,<target type>;
*areamobuseskill "<地图名称>",<坐标x>,<坐标y>,<范围>,<魔物编码>,<技能编码>,<技能等级>,<咏唱时间>,<能否取消>,<表情符号>,<目标类型>;
*areamobuseskill "<地图名称>",<坐标x>,<坐标y>,<范围>,<魔物编码>,"<技能名称>",<技能等级>,<咏唱时间>,<能否取消>,<表情符号>,<目标类型>;


This command will make all monsters of the specified mob ID in the specified
area use the specified skill. Map name, x, and y define the center of the area,
which extending <range> cells in each direction (ex: a range of 3 would create
a 7x7 square). The skill can be specified by skill ID or name. <cast time> is in
milliseconds (1000 = 1 second), and the rest should be self-explanatory.
此命令将使指定区域内所有指定魔物编码的魔物使用指定技能。
地图名称，坐标x 和 坐标y 定义了区域的中心，并向每个方向扩展了 <范围> 格数（例如：范围为 3 将创建一个 7x7 的正方形）。
可通过技能编号或名称指定技能。<咏唱时间> 的单位是毫秒（1000 = 1 秒），其余部分不言自明。

<target type> can be:      <目标类型>可以是：
	0 = self                             0 = 自身
	1 = the mob's current target         1 = 魔物当前的目标
	2 = the mob's master                 2 = 魔物的控制者
	3 = random target                    3 = 随机目标

Example:   例子：

	// spawn 1 Shining Plant in the 5x5 area centered on (155,188)     在以 (155,188) 为中心的 5x5 区域中生成 1 颗光芒草
	areamonster "prontera",153,186,157,190,"Shining Plant",1083,1;
	// make the plant cast level 10 Cold Bolt on a random target       让植物对随机目标施放 10 级冰箭术
	areamobuseskill "prontera",155,188,2,1083,"MG_COLDBOLT",10,3000,1,ET_KEK,3;

---------------------------------------

*killmonster "<map name>","<event label>"{,<type>};
*killmonster "<地图名称>","<事件标签>"{,<类型>};

This command will kill all monsters that were spawned with 'monster' or
'addmonster' and have a specified event label attached to them. Commonly used to
get rid of remaining quest monsters once the quest is complete.
该命令将杀死所有使用 "monster"或 "addmonster"生成的魔物，这些魔物都与指定的事件标签关联。
常用于在任务完成后消灭剩余的任务相关魔物。


If the label is given as "All", all monsters which have their respawn times set
to -1 (like all the monsters summoned with 'monster' or 'areamonster' script
command, and all monsters summoned with GM commands, but no other ones - that
is, all non-permanent monsters) on the specified map will be killed regardless
of the event label value.
如果标注为 "All"，则指定地图上所有重生时间设置为-1 的魔物
（如所有使用 "monster "或 "areamonster "脚本命令召唤的魔物，
以及所有使用 GM 命令召唤的魔物，但没有其他命令，即所有非永久性魔物）
都会被杀死，与事件标签无关。

As of r12876 killmonster now supports an optional argument type. Using 1 for type
will make the command fire "OnMyMobDead" events from any monsters that do die
as a result of this command.
从 r12876 版本开始，killmonster 支持可选参数类型。
如果在类型中使用 1，则该命令会触发任何因该命令而死亡的怪物的 "OnMyMobDead"事件。

---------------------------------------

*killmonsterall "<map name>"{,<type>};
*killmonsterall "<地图名称>"{,<类型>};

This command will kill all monsters on a specified map name, regardless of how
they were spawned or what they are. As of r12873, The behavior has changed slightly.
In light of a label behavior fix for mob spawning commands that will now allow the label to
trigger when there is no player, killmonsterall has also been modified to support this.
此命令将杀死指定地图名称上的所有魔物，无论它们是如何生成的，也无论它们是什么。
从 r12873 开始，该命令已略有改变。鉴于对魔物生成命令的标签执行进行了修复，
现在可以在没有玩家的情况下触发标签，因此 killmonsterall 也进行了修改以支持此功能。

Using this the normal/old way means labels don't trigger when a player didn't
attack/kill a monster. This is because it breaks compatibility with older scripts if
forced to use the new method. However, if you wish to use the new label type with this
command, simply use 1 for type. Any other number won't be recognized.
按正常/老方法使用，意味着当玩家没有攻击/杀死魔物时，标签不会触发。
这是因为如果强制使用新方式，就会破坏与旧脚本的兼容性。
但是，如果您希望在该命令中使用新标签类型，只需在类型中使用 1。
任何其他数值都无法识别。

---------------------------------------

*strmobinfo(<type>,<monster id>);
*strmobinfo(<类型>,<魔物编码>);

This function will return information about a monster record in the database, as
per 'db/(pre-)re/mob_db.txt'. Type is the kind of information returned. Valid types are:
It will return 0 if there is no such monster (or the type value is invalid),
or an empty string if you requested the monster's name.
该函数将按照 "db/(pre-)re/mob_db.txt "返回数据库中有关魔物数据的信息。
<类型>是返回信息的种类。有效类型为：如果没有这样的魔物（或类型值无效），
它将返回 0；如果您请求的是魔物名称，则返回空字符串。

 1 - 'english name' field in the database, a string.            1 - 数据库中的 "english name"字段，一个字符串。
 2 - 'japanese name' field in the database, a string.           2 - 数据库中的 "japanese name"字段，一个字符串。
     All other returned values are numbers:                         所有其他返回值均为数字：
 3 - Level.                                                     3 - 等级.
 4 - Maximum HP.                                                4 - 最大HP.
 5 - Maximum SP.                                                5 - 最大SP.
 6 - Experience reward.                                         6 - 获得的经验值.
 7 - Job experience reward.                                     7 - 获得的职业经验值.

---------------------------------------

*mobcount("<map name>","<event label>")
*mobcount("<地图名称>","<事件标签>")

This function will count all the monsters on the specified map that have a given
event label and return the number or 0 if it can't find any. Naturally, only
monsters spawned with 'monster' and 'areamonster' script commands can have non-empty
event label.
该函数将统计指定地图上所有带有给定事件标签的魔物，如果找不到则返回 0。
当然，只有使用 "monster "和 "areamonster "脚本命令生成的魔物才有非空事件标签。

If you pass this function an empty string for the event label, it will return
the total count of monster without event label, including permanently spawning monsters.
With the dynamic mobs system enabled, where mobs are not kept
in memory for maps with no actual people playing on them, this will return a 0
for any such map.
如果给该函数传递一个空字符串作为事件标签，它将返回没有事件标签的魔物总数，包括永久生成的魔物。
在启用动态魔物系统后，对于没有实际玩家的地图，魔物不会保留在内存中，因此对于任何此类地图，此值都将返回 0。

If the event label is given as "all", all monsters will be counted, regardless of
having any event label attached.
如果事件标签为 "all"，则所有魔物都会被计算在内，无论是否附加任何事件标签。

If the map name is given as "this", the map the invoking character is on will
be used. If the map is not found, or the invoker is not a character while the map
is "this", it will return -1.
如果地图名称为 "this"，则将使用调用角色所在的地图。如果找不到地图，
或者调用者不是角色，而地图是 "this"，则会返回-1。

---------------------------------------

*clone "<map name>",<x>,<y>,"<event>",<char id>{,<master_id>{,<mode>{,<flag>,<duration>}}}
*clone "<地图名称>",<坐标x>,<坐标y>,"<事件>",<角色编号>{,<控制者编码>{,<模式>{,<标识>,<持续时间>}}}

This command creates a monster which is a copy of another player. The first
four arguments serve the same purpose as in the monster script command, The
<char id> is the character id of the player to clone (player must be online).
If <master id> is given, the clone will be a 'slave/minion' of it. Master_id
must be a character id of another online player.
该命令会创建一个魔物，它是另一个玩家的副本。<角色编号> 是要复制的玩家的角色编号（玩家必须在线）。
如果给出了<控制者编码>，复制体将成为其 "下属/随从"。<控制者编码>必须是其他在线玩家的角色编号。

The mode can be specified to determine the behavior of the clone. Its
values are the same as the ones used for the mode field in the mob_db. The
default mode is aggressive, assists, can move, can attack.
可以指定模式来决定复制体的行为。其值与 mob_db 中模式字段所用的值相同。
默认模式为攻击、助攻、可移动、可攻击。

Flag can be either zero or one currently. If zero, the clone is a normal
monster that'll target players, if one, it is considered a summoned monster,
and as such, it'll target other monsters. Defaults to zero.
标识目前可以是 0 或 1。如果为 0，则复制体是普通魔物，会以玩家为攻击目标；
如果为 1，则被视为召唤魔物，因此会以其他魔物为攻击目标。默认值为 0。

The duration specifies how long the clone will live before it is auto-removed.
Specified in seconds, defaults to no limit (zero).
持续时间指定复制体在被自动删除前的存在时间。
以秒为单位，默认为无限制（0）。

Returned value is the monster ID of the spawned clone. If command fails,
returned value is zero.
返回值是生成的复制体的魔物编码。如果命令执行失败，返回值为 0。

---------------------------------------

*summon "monster name",<monster id>{,<Time Out>{,"event label"}};
*summon "魔物名称",<魔物编码>{,<超时>{,"时间标签"}};

This command will summon a monster. (see also 'monster') Unlike monsters spawned
with other commands, this one will set up the monster to fight to protect the
invoking character. Monster name and mob id obey the same rules as the one given
at the beginning of this document for permanent monster spawns with the
exceptions mentioned when describing 'monster' command.
该命令将召唤一只魔物。（另见 "monster"）与其他命令生成的魔物不同，该命令会让魔物为保护调用者而战斗。
怪物名称和怪物编码遵循的规则与本文档开头给出的永久性魔物生成规则相同，
但在解释 "monster"命令时会提到一些例外情况。

The effect for the skill 'Call Homunculus' will be displayed centered on the
invoking character.
技能 "召唤生命体"的效果将以调用角色为中心显示。

Timeout is the time in milliseconds the summon lives, and is set default
to 60000 (1 minute). Note that also the value 0 will set the timer to default,
and it is not possible to create a spawn that lasts forever.
If an event label is given, upon the monster being killed, the event label will
run as if by 'donpcevent'.
超时是召唤物的存在时间（以毫秒为单位），默认设置为 60000（1 分钟）。
请注意，值 0 也会将计时器设置为默认值，而且不可能创建一个永远存在的召唤物。
如果给定了事件标签，魔物被杀死后，事件标签将像 "donpcevent "一样执行。

Returned value is the game ID of the spawned monster.
返回值是生成魔物的游戏编号。

// Will summon a dead branch-style monster to fight for the character.
//会召唤一个枯树枝魔物为角色战斗。
summon "--ja--",-1;

---------------------------------------

*addmonsterdrop <monster id>,<item id>,<rate>;
*addmonsterdrop "<monster name>",<item id>,<rate>;
*delmonsterdrop <monster id>,<item id>;
*delmonsterdrop "<monster name>",<item id>;
*addmonsterdrop <魔物编码>,<物品编码>,<几率>;
*addmonsterdrop "<魔物名称>",<物品编码>,<几率>;
*delmonsterdrop <魔物编码>,<物品编码>;
*delmonsterdrop "<魔物名称>",<物品编码>;

These commands will temporarily add or delete a monster drop, which will be reset
when the mob database reloads or the server shuts down. They return 1 upon success.
这些命令将临时添加或删除一个魔物的掉落物品，并在重新加载怪物数据库或服务器关闭时重置。
成功后返回 1。

If the monster already drops the specified item, its drop rate will be updated with
the given rate (100 = 1%).
如果魔物已经掉落指定物品，其掉落率将按给定的比率（100 = 1%）更新。

If <steal protected> is true the item will be protected from TF_STEAL (default false).
<random option group id> binds the item with the given random option group Id (default 0).
The Id must be valid, like defined in db/[pre-]re/item_randomopt_group.yml
如果 <steal protected> 为 true，则对象将受到 TF_STEAL (偷窃技能)保护（默认为 false）。
<随机属性选项值> 将项目与给定的随机选项组编号（默认为 0）绑定。
编号必须有效，如在 db/[pre-]re/item_randomopt_group.yml 中定义的那样


Examples:  例子：
	// Makes Owl Baron drop Honey at an 80% rate.
	//让鹗枭男爵掉落蜂蜜，几率80%
	addmonsterdrop 1295,518,8000;

	// Deletes Executioner's Mitten from Rybio.
	//删除瑞比欧掉落的行刑者手套项目
	delmonsterdrop 1201,7017;

---------------------------------------

*mob_setidleevent <GID>,<event>;
*mob_setidleevent <GID>,<事件>;

This command will attach an event label to the monster with the given <GID> which will execute
when the <GID> is idle.
该命令将为带有给定 <GID> 的魔物附加一个事件标签，当 <GID> 空闲时执行该标签。

Example:
例子：
	monster "prontera",0,0,"Quest Poring",1002,1;
	mob_setidleevent $@mobid[0], "NPC NAME::OnIdle";
	end;

OnIdle:
	mobchat getattachedrid(),0,0x00FF00,"I'm IDLE!";
	end;

---------------------------------------

*disablenpc "<NPC object name>";
*enablenpc "<NPC object name>";
*disablenpc "<NPC对象名称>";
*enablenpc "<NPC对象名称>";

These two commands will disable and enable, respectively, an NPC object
specified by name. The disabled NPC will disappear from sight and will no longer
be triggerable in the normal way. It is not clear whether it will still be
accessible through 'donpcevent' and other triggering commands, but it probably
will be. You can disable even warp NPCs if you know their object names, which is
an easy way to make a map only accessible through walking half the time. Then
you 'enablenpc' them back.
这两条命令将分别禁用和启用一个由名称指定的 NPC 对象。被禁用的 NPC 将从视线中消失，
不再能以正常方式触发。目前还不清楚是否还能通过 "donpcevent "和其他触发命令访问该地图，
但很有可能可以。如果知道对象名称，您甚至可以禁用传送点 NPC，
这样就可以容易地让地图在一定时间内只能通过步行进入。然后再用 "enablenpc "命令改回。

You can also use these commands to create the illusion of an NPC switching
between several locations, which is often better than actually moving the NPC -
create one NPC object with a visible and a hidden part to their name, make a few
copies, and then disable all except one.
您还可以使用这些命令来制造 NPC 在多个地点之间切换的假象，
这往往比实际移动 NPC 效果更好。创建一个 NPC 对象，
在其名称中包含可见和隐藏部分，复制几个副本，
然后禁用除其中一个以外的所有副本。

---------------------------------------

*hideonnpc "<NPC object name>";
*hideoffnpc "<NPC object name>";
*hideonnpc "<NPC对象名称>";
*hideoffnpc "<NPC对象名称>";

These commands will make the NPC object specified display as hidden/visible,
even though not actually disabled per se. Hidden as in thief Hide skill, but
unfortunately, not detectable by Ruwach or Sight.
这些命令将使指定的 NPC 对象显示为隐藏/可见，即使其本身实际上并未禁用。
与盗贼的隐藏技能一样，但不幸的是，无法被光猎或火狩探测到。

As they are now, these commands are pointless, it is suggested to use
'disablenpc'/'enablenpc', because these two commands actually unload the NPC
sprite location and other accompanying data from memory when it is not used.
However, you can use these for some quest ideas (such as cloaking NPCs talking
while hidden then revealing.... you can wonder around =P
因为这两条命令实际上是在不使用时从内存中卸载 NPC 图像位置和其他附带数据。
不过，您可以将其用于一些任务创意（例如隐身 NPC，
让其在隐藏时说话，然后解谜....，您就可以四处探索了=P

---------------------------------------

*unloadnpc "<NPC object name>";
*unloadnpc "<NPC对象名称>";

This command will fully unload a NPC object and all of it's duplicates.
此命令将完全卸载一个 NPC 对象及其所有副本。

---------------------------------------

*duplicate "<NPC name>","<map>",<x>,<y>{,"<Duplicate NPC name>"{,<sprite>{,<dir>{,<xs>{,<xy>}}}}};
*duplicate "<NPC名称>","<地图>",<坐标x>,<坐标y>{,"<复制后的NPC名称>"{,<外形>{,<朝向>{,<xs>{,<xy>}}}}};

This command will duplicate the NPC with the given <NPC name> on <map> at <x>/<y>.
If <Duplicate NPC name>, <sprite>, <dir>, <xs> or <ys> is not provided the value of the original NPC will be used.
The Unique name of the new duplicated NPC is returned on success. An empty string is returned on failure.
此命令将在 <坐标x>/<坐标y> 处的 <地图> 上以给定的 <NPC名称> 复制 NPC。
如果没有提供 <复制 NPC 名称>、<外形>、<朝向>、<xs> 或 <ys>，则将使用原始 NPC 的值。
成功时将返回新复制 NPC 的唯一名称。失败时将返回空字符串。

NOTE:
注意：
	Duplicates will always have the same NPC variables as the original NPC.
	Editing a NPC variable in a duplicate or the original NPC will change it for the others.
	复制的 NPC 变量始终与原始 NPC 相同。
	在副本或原始 NPC 中编辑 NPC 变量会改变其他 NPC 的变量。

---------------------------------------
 
*duplicate_dynamic("<NPC name>"{,<character ID>});
*duplicate_dynamic("<NPC名称>"{,<角色编号>});

This command will duplicate the NPC with the given <NPC name> near the attached player or the player with the given <character ID>.
The Unique name of the new duplicated NPC is returned on success. An empty string is returned on failure.
此命令将在关联玩家或所给<角色编号>的玩家附近复制带有给定<NPC名称>的NPC。
成功时将返回新复制 NPC 的唯一名称。失败时将返回空字符串。


NOTE:
注意：
	Duplicates will always have the same NPC variables as the original NPC.
	Editing a NPC variable in a duplicate or the original NPC will change it for the others.
	复制的 NPC 变量始终与原始 NPC 相同。
	在副本或原始 NPC 中编辑 NPC 变量会改变其他 NPC 的变量。

---------------------------------------
 
*cloakonnpc "<NPC object name>"{,<character ID>};
*cloakoffnpc "<NPC object name>"{,<character ID>};
*cloakonnpc "<NPC对象名称>"{,<角色编号>};
*cloakoffnpc "<NPC对象名称>"{,<角色编号>};

These commands will make the NPC object specified display as cloaked/uncloaked,
even though not actually disabled.
The player can interact with a NPC cloaked (via NPC click, monster event..)
but the NPC trigger area is disabled.
这些命令将使指定的 NPC 对象显示为隐形/不隐形，即使实际上并未禁用。
玩家可以与隐身的 NPC 进行交互（通过 NPC 点击、魔物事件......），但 NPC 触发区域会被禁用。

If <character ID> is given then the NPC will only display to the specified
player until he/she leaves the map, logs out, or the npc option is changed.
If no <character ID> is specified it will display to the area.
如果给出了<角色编号>，那么 NPC 将只显示给指定的玩家，直到他/她离开地图、离线或更改了npc选项。
如果未指定<角色编号>，则将在区域显示。

---------------------------------------

*isnpccloaked "<NPC object name>"{,<character ID>};
*isnpccloaked "<NPC对象名称>"{,<角色编号>};

Returns true if the NPC has been cloaked to the attached player or given
<character ID>, false otherwise. This works in association with cloakonnpc
when it is targetting a specific character.
如果NPC已向关联玩家或给定的<角色编号>显示隐藏，则返回 true，否则返回 false。
在针对特定角色时，该命令会与 cloakonnpc 配合使用。

---------------------------------------

*cloakonnpcself {"<NPC object name>"};
*cloakoffnpcself {"<NPC object name>"};

Same command as above, but an attached player is required. The NPC will only display to the attached player.
与上述命令相同，但需要关联玩家。NPC 只会显示给关联的玩家。

---------------------------------------

*doevent "<NPC object name>::<event label>";
*doevent "<NPC对象名称>::<事件标签>";

This command will start a new execution thread in a specified NPC object at the
specified label. The execution of the script running this command will not stop,
and the event called by the 'doevent' command will not run until the invoking
script has terminated. No parameters may be passed with a doevent call.
该命令会跳转至指定NPC对象的指定标签处开始执行。运行此命令的脚本不会停止执行，
"doevent"命令调用的事件也不会运行，直到调用脚本结束。调用doevent时不传递任何参数。

The script of the NPC object invoked in this manner will run as if it's been
invoked by the RID that was active in the script that issued a 'doevent'. As
such, the command will not work if an RID is not attached.
以这种方式触发的NPC对象脚本在运行时，就好像是由发出"doevent"的脚本中的RID触发一样。
因此，如果没有关联的RID，该命令将不起作用。


	place,100,100,1%TAB%script%TAB%NPC%TAB%53,{
		mes "This is what you will see when you click me";
		close;
	OnLabel:
		mes "This is what you will see if the doevent is activated";
		close;
	}

	....

	doevent "NPC::OnLabel";//跳转到上面的OnLabel处执行[译者注]

---------------------------------------

*donpcevent "<NPC object name>::<event label>";
*donpcevent "<NPC对象名称>::<事件标签>";

This command invokes the event label code within an another NPC or NPCs. It
starts a separate instance of execution, and the invoking NPC will resume
execution its immediately.
该命令调用另一个或多个NPC中的事件标签处的代码。
它会启动一个单独的执行实例，而调用的NPC会立即恢复执行。

If the supplied event label has the form "NpcName::OnLabel", then only given
NPC's event label will be invoked (much like 'goto' into another NPC). If the
form is "::OnLabel" (NPC name omitted), the event code of all NPCs with given
label will be invoked, one after another. In both cases the invoked script
will run without an attached RID, whether or not the invoking script was
attached to a player. The event label name is required to start with "On".
如果提供的事件标签形式为 "NpcName::OnLabel"，则只会调用给定NPC的事件标签（就像"进入"另一个NPC一样）。
如果形式为"::OnLabel"（省略NPC名称），则会逐个调用带有给定标签的所有NPC的事件代码。
在这两种情况下，无论调用的脚本是否关联到玩家，被调用的脚本都将在没有关联RID的情况下运行。
事件标签名称必须以 "On"开头。


This command can be used to make other NPCs act, as if they were responding to
the invoking NPC's actions, such as using an emotion or talking.
该命令可用于使其他NPC动作，就像他们对调用NPC的行动做出反应一样，例如使用表情符号或说话。

	place,100,100,1%TAB%script%TAB%NPC1%TAB%53,{           place,100,100,1%TAB%script%TAB%NPC1%TAB%53,{
		mes "NPC2 copies my actions!";                     	mes "NPC2 模仿我的行动!";
		close2;                                            	close2;
		donpcevent "NPC2::OnEmote";                        	donpcevent "NPC2::OnEmote";
		end;                                               	end;
	OnEmote:                                               OnEmote:
		emotion rand(1,30);                                	emotion rand(1,30);
		end;                                               	end;
	}                                                      }
                                                           
	place,102,100,1%TAB%script%TAB%NPC2%TAB%53,{           place,102,100,1%TAB%script%TAB%NPC2%TAB%53,{
		mes "NPC1 copies my actions!";                     	mes "NPC1 模仿我的行动!";
		close2;                                            	close2;
		donpcevent "NPC1::OnEmote";                        	donpcevent "NPC1::OnEmote";
		end;                                               	end;
	OnEmote:                                               OnEmote:
		emotion rand(1,30);                                	emotion rand(1,30);
		end;                                               	end;
	}                                                      }

Whichever of the both NPCs is talked to, both will show a random emotion at the
same time.
无论与这两个NPC中的哪一个交谈，他们都会同时发出一个随机的表情符号。

As of r16564, command now returns 1 or 0 on success and failure.
A debug message also shows on the console when no events are triggered.
从 r16564 开始，该命令会在成功和失败时返回 1 或 0。
如果没有触发事件，控制台还会显示调试信息。

---------------------------------------

*cmdothernpc "<npc name>","<command>";
*cmdothernpc "<npc名称>","<命令>";

This is simply "donpcevent <npc name>::OnCommand<command>".
It is an approximation of official server script language's 'cmdothernpc'.
这类似"donpcevent <npc name>::OnCommand<command>"。
它近似于官方服务器脚本语言的 "cmdothernpc"。

Returns true if the command was executed on the other NPC successfully, false if not.
如果命令已在另一个NPC上成功执行，则返回true，否则返回false。

---------------------------------------

*npctalk "<message>"{,"<NPC name>",<flag>{,<color>}};
*npctalk "<信息>"{,"<NPC名称>",<标识>{,<颜色>}};

This command will display a message as if the NPC object running it was a player
talking - that is, above their head and in the chat window.
The display name of the NPC won't get appended in front of the message.
If the <NPC name> option is given and not empty, then that NPC will display the message,
else the attached NPC will display the message,
the color format is in RGB (0xRRGGBB). The color is White by default.
该命令将显示一条信息，就好像运行该命令的NPC对象是一个正在说话的玩家一样，
即在他们的头顶和聊天窗口中显示。NPC的显示名称不会附加在信息前面。
如果<NPC名称>选项为空，则该NPC将显示信息，否则指定名称的NPC将显示信息，
颜色格式为 RGB (0xRRGGBB)。默认颜色为白色。

Target for <flag>:  <标识>对应的目标：
- bc_all  : Broadcast message is sent server-wide (only in the chat window).   播发的信息发送到整个服务器（只在聊天窗口中显示）。
- bc_map  : Message is sent to everyone in the same map as the source of the npc.    信息会发送给与npc所在同一地图上的所有人。
- bc_area : Message is sent to players in the vicinity of the source (default value).     信息会发送给信息源附近(可视范围[译注])的玩家（默认值）。
- bc_self : Message is sent only to player attached.       信息只发送给关联的玩家。

	// This will make everyone in the area see the NPC greet the character   如下，该区域内的所有人都会看到NPC向刚刚触发NPC的角色打招呼。
	// who just invoked it.
	npctalk "Hello " + strcharinfo(0) + ", how are you?";                    npctalk "你好" + strcharinfo(0) + ", 还好吗?";

---------------------------------------

*chatmes "<message>"{,"<NPC name>"};
*chatmes "<message>"{,"<NPC名称>"};

This command will display a message in the waitingroom (chat) of the NPC.
If the <NPC name> option is given, then that NPC will display the message, else
the attached NPC will display the message.
If the NPC is not in a waitingroom, nothing happens.
此命令将在NPC的等候室（聊天室）中显示一条信息。
如果给出了<NPC名称>选项，则该NPC将显示该信息，否则关联的NPC将显示该信息。
如果NPC不在聊天室，则不会发生任何事情。

	// Everyone in the waitingroom will see this message:     等候室里的每个人都会看到这条信息：
	chatmes "Waiting 5 minutes until the next match will start";                 //chatmes "等待5分钟，直到下一场比赛开始";

---------------------------------------

*setnpcdisplay("<npc name>", "<display name>", <class id>, <size>)
*setnpcdisplay("<npc name>", "<display name>", <class id>)
*setnpcdisplay("<npc name>", "<display name>")
*setnpcdisplay("<npc name>", <class id>)
*setnpcdisplay("<npc名称>", "<显示名称>", <类型编号>, <尺寸>)
*setnpcdisplay("<npc名称>", "<显示名称>", <类型编号>)
*setnpcdisplay("<npc名称>", "<显示名称>")
*setnpcdisplay("<npc名称>", <类型编号>)

Changes the display name and/or display class of the target NPC.
Returns 0 is successful, 1 if the NPC does not exist.
Size is 0 = normal 1 = small 2 = big.
更改目标NPC的显示名称和/或显示类型。
如果成功则返回0，如果NPC不存在则返回1。
尺寸 0 = 普通 1 = 小型 2 = 大型。

---------------------------------------
\\
5,1.- Time-related commands       计时相关命令
\\
---------------------------------------

*addtimer <ticks>,"NPC::OnLabel";
*deltimer "NPC::OnLabel";
*addtimercount <ticks>,"NPC::OnLabel";
*addtimer <时间戳>,"NPC::OnLabel";
*deltimer "NPC::OnLabel";
*addtimercount <时间戳>,"NPC::OnLabel";

These commands will create, destroy, and delay a countdown timer - 'addtimer' to
create, 'deltimer' to destroy and 'addtimercount' to delay it by the specified
number of ticks. For all three cases, the event label given is the identifier of
that timer. The timer runs on the character object that is attached to the script,
and can have multiple instances. When the label is run, it is run as if the player that
the timer runs on has clicked the NPC.
这些命令将创建、销毁和延迟一个倒计时计时器--
"addtimer "用于创建，"deltimer "用于销毁，"addtimercount "用于将其延迟指定的时间戳。
在所有三种情况下，给出的事件标签都是该计时器的标识符。
定时器在脚本关联的角色对象上运行，可以有多个副本。
当触发的标签运行时，就好像计时器运行的玩家触发了NPC。

When this timer runs out, a new execution thread will start in the specified NPC
object at the specified label.
计时器计时结束后，一个新的执行线程将在指定标签处的指定NPC对象中启动。

The ticks are given in 1/1000ths of a second.
时间戳以 1/1000 秒为单位。

One more thing. These timers are stored as part of player data. If the player
logs out, all of these get immediately deleted, without executing the script.
If this behavior is undesirable, use some other timer mechanism (like 'sleep').
还有一件事。这些计时器是作为玩家数据的一部分存储的。
如果玩家离线，所有这些都会立即清除，而不会执行脚本。
如果不希望出现这种执行方式，可使用其他计时器机制（如 "sleep"）。

Example:  例子：
<NPC Header> {
	dispbottom "Starting a 5 second timer...";     //开始一个5秒的计时器
	addtimer 5000, strnpcinfo(3) + "::On5secs";
	end;
On5secs:
	dispbottom "5 seconds have passed!";        //5秒已经过
	end;
}

---------------------------------------

*initnpctimer{ "<NPC name>" {, <Attach Flag>} } |                   *initnpctimer{ "<NPC名称>" {, <关联标识>} } |
             { "<NPC name>" | <Attach Flag> };                                   { "<NPC名称>" | <关联标识> };
*stopnpctimer{ "<NPC name>" {, <Detach Flag>}  } |                  *stopnpctimer{ "<NPC名称>" {, <取消关联标识>}  } |
             { "<NPC name>" | <Detach Flag> };                                   { "<NPC名称>" | <取消关联标识> };
*startnpctimer{ "<NPC name>" {, <Attach Flag>} } |                  *startnpctimer{ "<NPC名称>" {, <关联标识>} } |
              { "<NPC name>" | <Attach Flag> };                                   { "<NPC名称>" | <关联标识> };
*setnpctimer <tick>{,"<NPC name>"};                                 *setnpctimer <时间戳>{,"<NPC名称>"};
*getnpctimer(<type of information>{,"<NPC name>"})                  *getnpctimer(<信息类型>{,"<NPC名称>"})
*attachnpctimer {"<character name>"};                               *attachnpctimer {"<角色名称>"};
*detachnpctimer {"<NPC name>"};                                     *detachnpctimer {"<NPC名称>"};

This set of commands and functions will create and manage an NPC-based timer.
The NPC name may be omitted, in which case the calling NPC is used as target.
这组命令和函数将创建并管理一个基于NPC的计时器。
NPC 名称可以省略，在这种情况下，调用的NPC将被用作目标。

Contrary to addtimer/deltimer commands which let you have many different timers
referencing different labels in the same NPC, each with their own countdown,
'initnpctimer' can only have one per NPC object. But it can trigger many labels
and let you know how many were triggered already and how many still remain.
与 addtimer/deltimer 命令不同的是，"initnpctimer "只能为每个NPC对象设置一个计时器。
但它可以触发许多标签，让你知道有多少标签已经触发，还有多少标签尚未触发。

This timer is counting up from 0 in ticks of 1/1000ths of a second each. Upon
creating this timer, the execution will not stop, but will happily continue
onward. The timer will then invoke new execution threads at labels
"OnTimer<time>:" in the NPC object it is attached to.
该计时器从0开始向上计数，每个时间戳为 1/1000 秒。
创建该计时器后，脚本执行不会停止，而是会继续愉快地进行。
然后，定时器将在其所关联的NPC对象中的标识 "OnTimer<time>: "处调用新的执行线程。

To create the timer, use the 'initnpctimer', which will start it running.
'stopnpctimer' will pause the timer, without clearing the current tick, while
'startnpctimer' will let the paused timer continue.
要创建定时器，请使用 "initnpctimer"，它将启动定时器运行。
"stopnpctimer"将暂停计时器，但不清除当前时间戳，
而"startnpctimer"则让暂停的计时器继续运行。

By default timers do not have a RID attached, which lets them continue even
if the player that started them logs off. To attach a RID to a timer, you can
either use the optional "attach flag" when using 'initnpctimer/startnpctimer',
or do it manually by using 'attachnpctimer'. Likewise, the optional flag of
stopnpctimer lets you detach any RID after stopping the timer, and by using
'detachnpctimer' you can detach a RID at any time.
默认情况下，计时器不关联RID，因此即使启动计时器的玩家离线，计时器也能继续运行。
要将RID关联到定时器上，可以在使用 "initnpctimer/startnpctimer "时使用可选的 "关联标识"，
或者手动使用 "attachnpctimer"。同样，使用 stopnpctimer 的可选标识，
可以在停止计时器后取消关联任何RID，而使用 "detachnpctimer "则可以随时取消关联RID。

Normally there is only a single timer per NPC, but as an exception, as long as
you attach a player to the timer, you can have multiple timers running at once,
because these will get stored on the players instead of the NPC.
NOTE: You need to attach the RID before the timer _before_ you start it to
get a player-attached timer. Otherwise it'll stay a NPC timer (no effect).
通常情况下，每个NPC只有一个计时器，但作为例外，
只要在计时器上关联一个玩家，就可以同时运行多个计时器，
因为这些计时器会存储在玩家身上，而不是NPC身上。
注意：您需要在启动计时器之前将RID关联到计时器上，以获得玩家关联的计时器。
否则，它将一直是一个NPC定时器（无效果）。

If the player that is attached to the npctimer logs out, the "OnTimerQuit:"
event label of that NPC will be triggered, so you can do the appropriate
cleanup (the player is still attached when this event is triggered).
如果关联到npctimer的玩家离线，该NPC的 "OnTimerQuit: "事件标签将被触发，
这样你就可以进行适当的清理（触发该事件时玩家仍处于关联状态）。

The 'setnpctimer' command will explicitly set the timer to a given tick.
'getnpctimer' provides timer information. Its parameter defines what type:
"setnpctimer"命令将明确把计时器设置为给定的时间戳。
"getnpctimer"提供定时器信息。其参数定义了定时器的类型：

 0 - Will return the current tick count of the timer.        将返回计时器当前的时间戳计数。
 1 - Will return 1 if there are remaining "OnTimer<ticks>:" labels in the    如果指定的NPC中还有剩余的 "OnTimer<时间戳>: "标签等待执行，则返回 1。
     specified NPC waiting for execution.
 2 - Will return the number of times the timer has triggered and will trigger    将返回计时器触发的次数，并在指定的NPC中触发 "OnTimer<时间戳>: "标签。
     an "OnTimer<tick>:"  label in the specified NPC.

Example 1:        例1：

	<NPC Header> {
	// We need to use attachnpctimer because the mes command below needs RID attach
	//我们需要使用 attachnpctimer，因为下面的 mes 命令需要 RID 关联
		attachnpctimer;
		initnpctimer;
		npctalk "I cant talk right now, give me 10 seconds";   //"我目前无法谈话，给我10秒钟"
		end;
	OnTimer5000:
		npctalk "Ok 5 seconds more";                           //"OK还有5秒"
		end;
	OnTimer6000:
		npctalk "4";                                           //"4"
		end;
	OnTimer7000:
		npctalk "3";                                           //"3"
		end;
	OnTimer8000:
		npctalk "2";                                           //"2"
		end;
	OnTimer9000:
		npctalk "1";                                           //"1"
		end;
	OnTimer10000:
		stopnpctimer;
		mes "[Man]";
		mes "Ok we can talk now";                              //"OK我现在可以交谈了"
		detachnpctimer;
		// and remember attachnpctimer and detachnpctimer can only use while the NPC timer is not running !
		//记住，attachnpctimer 和 detachnpctimer 只能在NPC定时器不运行时使用！
	}

Example 2:     例2：

	OnTimer15000:
		npctalk "Another 15 seconds have passed.";      //"额外的15秒时间已经过去。"

		// You have to use 'initnpctimer' instead of 'setnpctimer 0'.                                      您必须使用 "initnpctimer"，而不是 "setnpctimer 0"。
		// This is equal to 'setnpctimer 0' + 'startnpctimer'.                                             这等于'setnpctimer 0' + 'startnpctimer'。
		// Alternatively, you can also insert another 'OnTimer15001' label so that the timer won't stop.   或者，您也可以插入另一个 "OnTimer15000 "标签，这样定时器就不会停止。
		initnpctimer;
		end;

	// This OnInit label will run when the script is loaded, so that the timer     该 OnInit 标签将在加载脚本时运行，
	// is initialized immediately as the server starts. It is dropped back to 0    以便在服务器启动时立即初始化计时器。
	// every time the NPC says something, so it will cycle continuously.           每当 NPC 说一句话，计时器就会回到 0，因此计时器会不断循环。
	OnInit:
		initnpctimer;
		end;

Example 3:     例3：

	mes "[Man]";
	mes "I have been waiting " + (getnpctimer(0)/1000) + " seconds for you.";     //mes "我已经等了你" + (getnpctimer(0)/1000) + " 秒。";
	// We divide the timer returned by 1000 to convert milliseconds to seconds.
	//我们将返回的计时器除以1000，将毫秒转换为秒。
	close;

Example 4:     例4：

	mes "[Man]";
	mes "Ok, I will let you have 30 more seconds...";                            //mes "好吧，我再给你 30 秒钟......";
	close2;
	setnpctimer (getnpctimer(0)-30000);
	// Notice the 'close2'. If there were a 'next' there the timer would be   请注意 "close2"。如果这里有 "next"，
	// changed only after the player pressed the 'next' button.               那么只有在玩家按下"继续"按钮后，计时器才会改变。
	end;

---------------------------------------

*sleep {<milliseconds>};
*sleep2 {<milliseconds>};
*awake "<NPC name>";
*sleep {<毫秒>};
*sleep2 {<毫秒>};
*awake "<NPC名称>";

These commands are used to control the pause of a NPC.
sleep and sleep2 will pause the script for the given amount of milliseconds.
Awake is used to cancel a sleep. When awake is called on a NPC it will run as
if the sleep timer ran out, and thus making the script continue. Sleep and sleep2
basically do the same, but the main difference is that sleep will not keep the rid,
while sleep2 does. Also sleep2 will stop the script if there is no unit attached.
这些命令用于控制NPC的暂停。
sleep 和 sleep2 会让脚本暂停给定的毫秒数。
awake用于取消sleep。在 NPC上调用"awake"时，它会像sleep计时器计时结束一样运行，从而使脚本继续执行。
Sleep 和 sleep2 的作用基本相同，但主要区别在于，sleep 不会关联 rid，而 sleep2 会。
如果没有关联对象，sleep2 也会停止脚本。

Examples:       例子：
	sleep 10000; //pause the script for 10 seconds and ditch the RID (so no player is attached anymore)  暂停脚本10秒钟，并删除RID（这样就不会再关联玩家了）
	sleep2 5000; //pause the script for 5 seconds, and continue with the RID attached.    暂停脚本 5 秒钟，然后继续关联 RID。
	awake "NPC"; //Cancels any running sleep timers on the NPC 'NPC'.      取消 NPC "NPC"上任何正在运行的sleep计时器。

---------------------------------------

*progressbar "<color>",<seconds>;
*progressbar "<颜色>",<秒数>;

This command works almost like sleep2, but displays a progress bar
above the head of the currently attached character (like cast bar).
Once the given amount of seconds passes, the script resumes. If the
character moves while the progress bar progresses, it is aborted and
the script ends. The color format is in RGB (RRGGBB). The color is
currently ignored by the client and appears always green.
该命令的工作原理与 sleep2 差不多，但会在当前关联角色的头部上方显示一个进度条（类似于咏唱条）。
一旦给定的秒数过去，脚本将继续运行。如果角色在进度条推进时移动，就会中止，脚本结束。
颜色格式为 RGB (RRGGBB)。该颜色目前被客户端忽略，始终显示为绿色。

NOTE:     注意：
Ragexe clients are known to randomly crash if a message window is still open.
If possible make sure to close all message windows before triggering the progressbar command.
据了解，如果消息窗口仍打开，Ragexe 客户端会随机崩溃。
如果可能，确保在触发进度条命令前关闭所有消息窗口。

---------------------------------------

*progressbar_npc "<color>",<seconds>{,<"NPC Name">};
*progressbar_npc "<颜色>",<秒数>{,<"NPC名称">};

This command works like progressbar, but displays a progress bar
above the head of the currently attached (or given) NPC. Once the
given amount of seconds passes, the script resumes. The color format
is in RGB (RRGGBB). The color is currently ignored by the client and
appears always green.
该命令的作用与进度条类似，但会在当前关联（或给定）的NPC头部上方显示一个进度条。
一旦给定的秒数过去，脚本将继续运行。颜色格式为 RGB (RRGGBB)。该颜色目前被客户端忽略，始终显示为绿色。

---------------------------------------
//
5,1.- End of time-related commands     计时器相关命令结束
//
---------------------------------------

*announce "<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>{,<char_id>}}}}}};
*announce "<文本>",<标识>{,<字体颜色>{,<字体类型>{,<字体尺寸>{,<字体对齐>{,<字体Y坐标>{,<角色编号>}}}}}};

This command will broadcast a message to all or most players, similar to
@kami/@kamib GM commands.
该命令将向所有或大多数玩家播送一条信息，类似于 @kami/@kamib 的 GM 命令。

	announce "This will be shown to everyone at all in yellow.",0;
	//announce "这将以黄色字体显示给所有人。",0;

The region the broadcast is heard in (target), source of the broadcast
and the color the message will come up as is determined by the flags.
播送的区域（目标）、播送源和信息显示的颜色由标识决定。

The flag values are coded as constants in 'src/map/script_constants.hpp' to make them easier to use.
标识值在 "src/map/script_constants.hpp "中被编写为常量，以便于使用。

Target flags:      目标标识：
- bc_all: Broadcast message is sent server-wide (default).    播送信息发送到整个服务器（默认）。
- bc_map: Message is sent to everyone in the same map as the source of the broadcast (see below).   信息会发送给与播送源在同一地图上的所有人（见下文）。
- bc_area: Message is sent to players in the vicinity of the source.    向播送源附近的玩家(可视范围[译者注])发送信息。
- bc_self: Message is sent only to current player , if the source flag is bc_pc it also can      信息只发送给当前玩家，如果播送源标识为 bc_pc，
			be used to send the Message to the character id if it's provided.                    则也可用于将信息发送给指定的角色编号。
You cannot use more than one target flag.
不能使用多个目标标识。

Source flags:        来源标识：
- bc_pc: Broadcast source is the attached player or the character id if it's provided (default).    播送源是所关联玩家或角色编号（如果提供）（默认）。
- bc_npc: Broadcast source is the NPC, not the player attached to the script       播送源是 NPC，而不是关联脚本的玩家
  (useful when a player is not attached or the message should be sent to those     （当玩家没有关联脚本或信息应发送给NPC附近的玩家时很有用）。
  nearby the NPC).
You cannot use more than one source flag.
不能使用多个来源标识。

Special flags:      特殊标识：
- bc_yellow: Broadcast will be displayed in yellow color (default).     播送信息将显示为黄色字体（默认）。
- bc_blue: Broadcast will be displayed in blue color.                   播送信息将以蓝色字体显示。
- bc_woe: Indicates that this broadcast is 'WoE Information' that can be disabled client-side.   表示此播送信息为 "攻城战信息"，可在客户端禁用。
Due to the way client handles broadcasts, it is impossible to set both bc_blue and bc_woe.
由于客户端处理播送信息的方式，无法同时设置 bc_blue 和 bc_woe。

The optional parameters allow usage of broadcasts in custom colors, font-weights, sizes etc.
If any of the optional parameters is used, special flag is ignored.
Optional parameters may not work well (or at all) depending on a game client used.
可选参数允许使用自定义颜色、字号、尺寸等播送信息。
如果使用了任何可选参数，特殊标记将被忽略。
可选参数可能无法正常工作（或根本无法工作），这取决于所使用的游戏客户端。

The color parameter is a single number which can be in hexadecimal notation.
颜色参数是一个数字，可以是十六进制符号。

For example:      举例：
    announce "This will be shown to everyone at all in green.",bc_all,0x00FF00;      //announce "这将以绿色字体的信息显示给所有人",bc_all,0x00FF00；
Will display a global announce in green. The color format is in RGB (0xRRGGBB).
将以绿色字体显示全局公告。颜色格式为 RGB (0xRRGGBB)。

In official scripts only two font-weights (types) are used:
在正式脚本中，只使用两种字号（类型）：

 - normal (FW_NORMAL = 400, default),  默认值
 - bold (FW_BOLD = 700).

Default font size is 12.
默认字体大小为 12。

Using this for private messages to players is probably not that good an idea,
but it can be used instead in NPCs to "preview" an announce.
将其用于向玩家发送私人信息可能不是一个好主意，但可以将其用于 NPC 来 "预览"公告。

	// This will be a private message to the player using the NPC that made the     这将让公告NPC发送给玩家私信
	// announcement
	announce "This is my message just for you",bc_blue|bc_self;            //announce "这是我专为您准备的信息",bc_blue|bc_self；

	// This will be shown on everyones screen that is in sight of the NPC.          这将让所有在NPC视野内的玩家收到信息。
	announce "This is my message just for you people here",bc_npc|bc_area;    //announce "这是我给你们的留言",bc_npc|bc_area；

	// This will be a private message to the player with character id 150000    这将是发给角色编号为 150000 的玩家的私人信息
	announce "This is my message just for char id 150000",bc_self,0xFFF618,FW_NORMAL,12,0,0,150000;   
	//announce "这是我向角色编号150000玩家发送的信息",bc_self,0xFFF618,FW_NORMAL,12,0,0,150000；

---------------------------------------

*mapannounce "<map name>","<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}}};
*mapannounce "<地图名称>","<文本>",<标识>{,<字体颜色>{,<字体类型>{,<字体尺寸>{,<字体对齐>{,<字体Y坐标>}}}}}};

This command will work like 'announce' but will only broadcast to characters
currently residing on the specified map. The flag and optional parameters
parameters are the same as in 'announce', but target and source flags are ignored.
该命令的作用与 "announce"类似，但只向当前停留在指定地图上的角色播送。
标识和可选参数与 "announce "中的相同，但目标和源标志识会被忽略。

---------------------------------------

*areaannounce "<map name>",<x1>,<y1>,<x2>,<y2>,"<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}}};
*areaannounce "<地图名称>",<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>,"<文本>",<标识>{,<字体颜色>{,<字体类型>{,<字体尺寸>{,<字体对齐>{,<字体Y坐标>}}}}}};

This command works like 'announce' but will only broadcast to characters
residing in the specified x1/y1-x2/y2 rectangle on the map given. The flags and
optional parameters are the same as in 'announce', but target and source flags are ignored.
该命令与 "announce"的工作原理类似，但只向指定地图上给定坐标 x1/y1-x2/y2 矩形内的角色播送。
标识和可选参数与 "announce "中的相同，但目标和源标识会被忽略。

	areaannounce "prt_church",0,0,350,350,"God's in his heaven, all right with the world",0;
	//areaannounce "prt_church",0,0,350,350,"上帝在天堂，世界一切安好",0;

---------------------------------------

*callshop "<name>",<option>;
*callshop "<名称>",<选项>;

These are a series of commands used to create dynamic shops.
The 'callshop' function calls an invisible shop (view -1) as if the player clicked on it.
这是一个用于创建动态商店的命令。"callshop"函数会调用一个不可见的商店（外观值 -1），就像玩家点击了它一样。

The options are:    可选项有：
	0 = The normal window (buy, sell and cancel)    普通窗口(买入，卖出和取消)
	1 = The buy window                              买入窗口
	2 = The sell window                             卖出窗口

Note: The <option> parameter only works on the 'shop' type NPC.
注意：<选项>参数只适用于"shop"类型的 NPC。

A shop called with this command will trigger the labels "OnBuyItem" and "OnSellItem"
(as long as an npcshop* command is executed from that NPC, see note below). These
labels, if used, will replace how the shop handles the buying and selling of items,
allowing for the creation of dynamic shops.
使用该命令调用的商店将触发 "OnBuyItem "和 "OnSellItem "标签（只要该 NPC 执行了 npcshop* 命令，见下文注释）。
如果使用这些标签，将取代商店处理物品买卖的方式，从而创建动态商店。

The label "OnBuyItem" sets the following arrays:     标签 "OnBuyItem "填入了以下数组：
	@bought_nameid   - item ID bought    可买的物品编号
	@bought_quantity - amount bought     可买的数量

The label "OnSellItem" sets the following arrays:    标签 "OnSellItem "填入了以下数组：
	@sold_nameid        - item ID sold                                   售卖的物品编号
	@sold_quantity      - amount sold                                    售卖的数量
	@sold_refine        - refine count                                   售卖的精炼值
	@sold_attribute     - if the item is broken (1) or not (0)           售卖的物品是否是损坏的，损坏(1)否则(0)
	@sold_identify      - if the item is identified (1) or not (0)       售卖的物品是否是已鉴定的，已鉴定(1)否则(0)
	@sold_enchantgrade  - enchantgrade                                   附魔
	@sold_card1         - card slot 1                                    卡片槽1
	@sold_card2         - card slot 2                                    卡片槽2
	@sold_card3         - card slot 3                                    卡片槽3
	@sold_card4         - card slot 4                                    卡片槽4
	@sold_option_id1    - random option ID 1                             随机属性编号1
	@sold_option_val1   - random option value 1                          随机属性数值1
	@sold_option_param1 - random option param 1                          随机属性参数1
	@sold_option_id2    - random option ID 2                             随机属性编号2
	@sold_option_val2   - random option value 2                          随机属性数值2
	@sold_option_param2 - random option param 2                          随机属性参数2
	@sold_option_id3    - random option ID 3                             随机属性编号3
	@sold_option_val3   - random option value 3                          随机属性数值3
	@sold_option_param3 - random option param 3                          随机属性参数3
	@sold_option_id4    - random option ID 4                             随机属性编号4
	@sold_option_val4   - random option value 4                          随机属性数值4
	@sold_option_param4 - random option param 4                          随机属性参数4
	@sold_option_id5    - random option ID 5                             随机属性编号5
	@sold_option_val5   - random option value 5                          随机属性数值5
	@sold_option_param5 - random option param 5                          随机属性参数5

Note: These labels will only be triggered if an npcshop* command is executed because these
commands set a special data on the shop NPC, named master_nd in the source. The above labels
are triggered in the NPC whose master_nd is given in the shop.
注意：这些标签只有在执行 npcshop* 命令时才会触发，因为这些命令会在商店 NPC（源代码中名为 master_nd）上设置一个特殊数据。
上述标签会在商店中给出 master_nd 的NPC中触发。

A full example of a dynamic shop can be found in doc/sample/npc_dynamic_shop.txt.
动态商店的完整示例可在 doc/sample/npc_dynamic_shop.txt 中找到。

---------------------------------------

*npcshopitem "<name>",<item id>,<price>{,<item id>,<price>{,<item id>,<price>{,...}}};
*npcshopitem "<name>",<item id>,<price>,<stock>{,<item id>,<price>,<stock>{,<item id>,<price>,<stock>{,...}}};
*npcshopitem "<名称>",<物品编号>,<价格>{,<物品编号>,<价格>{,<物品编号>,<价格>{,...}}};
*npcshopitem "<名称>",<物品编号>,<价格>,<存量>{,<物品编号>,<价格>,<存量>{,<物品编号>,<价格>,<存量>{,...}}};

This command lets you override the contents of an existing NPC shop or cashshop. The
current sell list will be wiped, and only the items specified with the price
specified will be for sale.
该命令可让您覆盖现有 NPC 商店或现金商店的内容。
当前的出售列表将被清除，只有指定价格的物品才会出售。

The function returns 1 if shop was updated successfully, or 0 if not found.
如果商店更新成功，函数返回 1；如果未找到商店，函数返回 0。

NOTES:  注意：
 - That you cannot use -1 to specify default selling price!      不能使用 -1 指定默认售价！
 - If attached shop type is market shop, need an extra param after price, it's <qty>
   and make sure don't add duplication item!
   如果所附商店类型是市场商店，则需要在价格后增加一个参数，即 <数量>，并确保不添加重复的项目！

---------------------------------------

*npcshopadditem "<name>",<item id>,<price>{,<item id>,<price>{,<item id>,<price>{,...}}};
*npcshopadditem "<名称>",<物品编号>,<价格>{,<物品编号>,<价格>{,<物品编号>,<价格>{,...}}};

This command will add more items at the end of the selling list for the
specified NPC shop or cashshop. If you specify an item already for sell, that item will
appear twice on the sell list.
此命令将在指定的 NPC 商店或现金商店的销售清单末尾添加更多物品。
如果您指定了一个已出售的物品，该物品将在出售列表中出现两次。

The function returns 1 if shop was updated successfully, or 0 if not found.
如果商店更新成功，函数返回 1；如果未找到商店，函数返回 0。

NOTES:     注意：
 - That you cannot use -1 to specify default selling price!         不能使用 -1 指定默认售价！
 - If attached shop type is market shop, need an extra param after price, it's <qty>
   and make sure don't add duplication item!
   如果所附商店类型是市场商店，则需要在价格后增加一个参数，即 <数量>，并确保不添加重复的项目！

---------------------------------------

*npcshopdelitem "<name>",<item id>{,<item id>{,<item id>{,...}}};
*npcshopdelitem "<名称>",<物品编号>{,<物品编号>{,<物品编号>{,...}}};

This command will remove items from the specified NPC shop or cashshop.
If the item to remove exists more than once on the shop, all instances will be
removed.
此命令将删除指定 NPC 商店或现金商店中的物品。
如果要删除的物品在商店中存在不止一次，则会删除所有项目。

Note that the function returns 1 even if no items were removed. The return
value is only to confirm that the shop was indeed found.
请注意，即使没有删除任何项目，函数也会返回 1。
返回值仅用于确认是否确实找到了店铺。

---------------------------------------

*npcshopattach "<name>"{,<flag>};
*npcshopattach "<名称>"{,<标识>};

This command will attach the current script to the given NPC shop.
When a script is attached to a shop, the events "OnBuyItem" and "OnSellItem"
of your script will be executed whenever a player buys/sells from the shop.
Additionally, the arrays @bought_nameid[], @bought_quantity[] or @sold_nameid[]
and @sold_quantity[] will be filled up with the items and quantities
bought/sold.
此命令会将当前脚本关联到指定的 NPC 商店。当脚本关联到商店后，每当玩家从商店购买或出售物品时，
脚本中的 "OnBuyItem "和 "OnSellItem "事件就会被执行。此外，数组 @bought_nameid[]、
@bought_quantity[] 或 @sold_nameid[] 和 @sold_quantity[] 将被填入买入/卖出的项目和数量。

The optional parameter specifies whether to attach ("1") or detach ("0") from
the shop (the default is to attach). Note that detaching will detach any NPC
attached to the shop, even if it's from another script, while attaching will
override any other script that may be already attached.
可选参数用于指定用于关联商店（"1"）还是用于取消关联商店（"0"）（默认为关联）。
请注意，取消关联将取消关联到商店的任何 NPC，即使它来自其他脚本；
而关联将覆盖可能已关联的任何其他脚本。

The function returns 0 if the shop was not found, 1 otherwise.
如果找不到商店，函数返回 0，否则返回 1。

NOTES:     注意：
 - If attached shop type is market shop, will be default to call the 'buy' window. 
   如果关联商店类型为市场商店，则默认调用 "买入" 窗口。

---------------------------------------

*npcshopupdate "<name>",<item_id>,<price>{,<stock>}
*npcshopupdate "<名称>",<物品编号>,<价格>{,<存量>}

Update an entry from shop. If price is 0 means don't change the price, maybe used for
marketshop to update the stock quantity. Except marketshop type, 'stock' value means
nothing.
令商店更新条目。如果价格为 0 表示不改变价格，可能用于市场商店更新库存数量。
除了市场商店类型，"库存"数值没有意义。

---------------------------------------

*waitingroom "<chatroom name>",<limit>{,"<event label>"{,<trigger>{,<required zeny>{,<min lvl>{,<max lvl>}}}}};
*waitingroom "<聊天室名称>",<限制>{,"<事件标签>"{,<触发>{,<需求zeny>{,<最低等级>{,<最高等级>}}}}};

This command will create a chat room, owned by the NPC object running this
script and displayed above the NPC sprite.
The maximum length of a chat room name is 60 letters.
此命令将创建一个聊天室，属于运行此脚本的 NPC 对象，并显示在 NPC 形象的上方。
聊天室名称的最大长度为 60 个字母。

The limit is the maximum number of people allowed to enter the chat room.
The attached NPC is included in this count. If the optional event and trigger
parameters are given, the event label ("<NPC object name>::<label name>")
will be invoked as if with a 'doevent' upon the number of people in the chat
room reaching the given triggering amount.
<限制>是允许进入聊天室的最大人数。关联的 NPC 也在计算之列。
如果给出了可选的事件和触发器参数，当聊天室人数达到给定的触发量时，
事件标签（"<NPC对象名>::<标签名>"）就会像 "doevent"一样被调用。

// The NPC will just show a box above its head that says "Hello World", clicking      NPC只会在头顶上显示一个写有 "Hello World"（你好，世界）
// it will do nothing, since the limit is zero.                                       的方框，点击它不会有任何作用，因为限制为0。
    waitingroom "Hello World",0;

// The NPC will have a box above its head, it will say "Disco - Waiting Room"          NPC 头顶上会有一个方框，上面写着 "Disco - Waiting Room"，
// and will have 8 waiting slots. Clicking this will enter the chat room, where        并有 8 个等候空位。点击后将进入聊天室，玩家可以在聊天室中等待，
// the player will be able to wait until 7 players accumulate. Once this happens,      直到累积到 7 名玩家。一旦达成条件，
// it will cause the NPC "Bouncer" run the label "OnStart".                            NPC "Bouncer "就会运行 "OnStart "标签。

    waitingroom "Disco - Waiting Room",8,"Bouncer::OnStart",7;

// The NPC will have a box above its head, it will say "Party - Waiting Room"         该 NPC 头顶会有一个方框，上面写着 "Party - Waiting Room"，
// and will have 8 waiting slots. Clicking this will allow a player who has           并有 8 个等待名额。点击后，拥有 5000 zeny 和 50~99 级的玩家就可以进入聊天室，
// 5000 zeny and lvl 50~99 to enter the chat room, where the player will be           在聊天室中等待直到累积到 7 名玩家。一旦达成条件，
// able to wait until 7 players accumulate. Once this happens, it will cause          NPC "Bouncer "就会运行 "OnStart "标签。
// the NPC "Bouncer" run the label "OnStart".

	waitingroom "Party - Waiting Room",8,"Bouncer::OnStart",7,5000,50,99;

Creating a waiting room does not stop the execution of the script and it will
continue to the next line.
创建等候室不会停止脚本的执行，它会继续执行下一行。

For more examples see the 2-1 and 2-2 job quest scripts which make extensive use
of waiting rooms.
更多示例请参阅 2-1 和 2-2 任务脚本(2转转职脚本[译者注])，其中大量使用了等候室。

---------------------------------------

*delwaitingroom {"<NPC object name"};
*delwaitingroom {"<NPC对象名称"};

This command will delete a waiting room. If no parameter is given, it will
delete a waiting room attached to the NPC object running this command, if it is,
it will delete a waiting room owned by another NPC object. This is the only way
to get rid of a waiting room, nothing else will cause it to disappear.
这条命令将删除一个等候室。如果没有给定参数，它将删除运行此命令的 NPC 对象所属的等候室；
如果给定了参数，它将删除给定 NPC 对象所属的等候室。

It's not clear what happens to a waiting room if the NPC is disabled with
'disablenpc', by the way.
顺便说一下，如果使用 "disablenpc"禁用了 NPC，那么等候室会发生什么情况还不清楚。

---------------------------------------

*enablewaitingroomevent {"<NPC object name>"};             *enablewaitingroomevent {"<NPC对象名称>"};
*disablewaitingroomevent {"<NPC object name>"};            *disablewaitingroomevent {"<NPC对象名称>"};
*enablearena;
*disablearena;

This will enable and disable triggering the waiting room event (see
'waitingroom') respectively. Optionally giving an NPC object name will do that
for a specified NPC object. The chat room will not disappear when triggering is
disabled and enabled in this manner and players will not be kicked out of it.
Enabling a chat room event will also cause it to immediately check whether the
number of users in it exceeded the trigger amount and trigger the event
accordingly.
这将分别启用和禁用触发等候室事件（见 "waitingroom"）。如果选择给出一个 NPC 对象名称，
则指定的 NPC 对象也会执行。以这种方式禁用和启用触发时，聊天室不会消失，玩家也不会被踢出聊天室。
启用聊天室事件后，它还会立即检查聊天室中的用户数量是否超过触发量，并相应地触发事件。

Normally, whenever a waiting room was created to make sure that only one
character is, for example, trying to pass a job quest trial, and no other
characters are present in the room to mess up the script.
通常情况下，创建等待室是为了确保只有一个角色在进行转职任务等，而房间里没有其他角色来干扰脚本。

The 'enablearena'/'disablearena' commands are just aliases with no parameter.
These are supposedly left here for compatibility with official server scripts,
but no rAthena script uses these at the moment.
enablearena'/'disablearena' 命令只是没有参数的别名。
这些脚本据说是为了与官方服务器脚本兼容而留下的，但目前没有任何 rAthena 脚本使用这些脚本。

---------------------------------------

*getwaitingroomstate(<information type>{,"<NPC object name>"})
*getwaitingroomstate(<信息类型>{,"<NPC对象名称>"})

This function will return information about the waiting room state for the
attached waiting room or for a waiting room attached to the specified NPC if
any.
此函数将返回关联的等候室或指定 NPC 关联的等候室（如果有）的等候室状态信息。

The valid information types are:
有效的信息类型有：

 0  - Number of users currently chatting.                                             目前正在聊天的用户数量。
 1  - Maximum number of users allowed.                                                允许的最大用户数。
 2  - Will return 1 if the waiting room has a trigger set.                            如果等候室设置了触发器，则返回 1，否则 0。
      0 otherwise.
 3  - Will return 1 if the waiting room is currently disabled.                        如果等候室当前禁用，则返回 1，否则 0。
      0 otherwise.
 4  - The Title of the waiting room (string)                                          等候室标题（字符串）
 5  - Password of the waiting room, if any. Pointless, since there is no way to       等候室密码（如果有）。没有意义，因为现在还无法为等候室设置密码。
      set a password on a waiting room right now.
 16 - Event name of the waiting room (string)                                         等候室事件名称（字符串）
 32 - Whether or not the waiting room is full.                                        等候室是否满员。
 33 - Whether the amount of users in the waiting room is higher than the trigger      等候室的用户数量是否高于触发数。
      number.

---------------------------------------

*warpwaitingpc "<map name>",<x>,<y>{,<number of people>};
*warpwaitingpc "<地图名称>",<坐标x>,<坐标y>{,<人数>};

This command will warp the amount of characters equal to the trigger number of
the waiting room chat attached to the NPC object running this command to the
specified map and coordinates, kicking them out of the chat. Those waiting the
longest will get warped first. It can also do a random warp on the same map
("Random" instead of map name) and warp to the save point ("SavePoint").
此命令会将与运行此命令的 NPC 对象关联的等候室聊天触发次数相等的角色悉数传送到指定的地图和坐标上，
并将他们踢出聊天室。等待时间最长的人会先被传送。它还可以在同一张地图上进行随机传送
（用 "Random"代替地图名称），也能传送到保存点（"SavePoint"）。

The list of characters to warp is taken from the list of the chat room members.
Those not in the chat room will not be considered even if they are talking to
the NPC in question. If the number of people is given, exactly this much people
will be warped.
要传送的角色列表来自聊天室成员名单。不在聊天室的人即使正在与相关 NPC 交谈，也不会被考虑在内。
如果给出了人数，就会传送相应的人数。

This command can also keep track of who just got warped. It does this by setting
special variables:
该命令还可以记录谁刚刚被传送了。可以通过设置特殊变量来实现：

$@warpwaitingpc[] is an array containing the account_id numbers of the
                  characters who were just warped.
$@warpwaitingpcnum contains the number of the character it just warped.
$@warpwaitingpc[]是一个数组，包含了刚刚被传送的角色的账号ID。
$@warpwaitingpcnum 包含刚刚传送的角色的数量。

See also 'getpartymember' for advice on what to do with those variables.
有关如何使用这些变量的建议，另请参阅 "getpartymember"。

The obvious way of using this effectively would be to set up a waiting room for
two characters to be warped onto a random PVP map for a one-on-one duel, for
example.
有效利用这一功能的显而易见的方法是设置一个等待室，让两个角色被传送到随机的 PVP 地图上进行一对一的决斗。

---------------------------------------

*waitingroomkick "<NPC object name>" , "<character name>";
*waitingroomkick "<NPC对象名称>" , "<角色名称>";

This command kicks the given character from the waiting room attached to the given NPC.
此命令将指定角色从指定 NPC 的等候室中踢出。

---------------------------------------

*getwaitingroomusers "<NPC object name>";
*getwaitingroomusers "<NPC对象名称>";

This command get all the characters in the waiting room of the given NPC and stores
their gids in the array .@waitingroom_users[]. Also, stores the number of characters
in the variable .@waitingroom_usercount.
这条命令会获取指定 NPC 等候室中的所有角色，并将他们的 gid 保存在数组 .@waitingroom_users[] 中。
同时，将角色数量存储在变量 .@waitingroom_usercount 中。

---------------------------------------

*kickwaitingroomall {"<NPC object name>"};
*kickwaitingroomall {"<NPC对象名称>"};

This command kicks everybody out of a specified waiting room chat.
此命令会将所有人踢出指定的等候室聊天室。

---------------------------------------

*setmapflagnosave "<map name>","<alternate map name>",<x>,<y>;
*setmapflagnosave "<地图名称>","<备用地图名称>",<坐标x>,<坐标y>;

This command sets the 'nosave' flag for the specified map and also gives an
alternate respawn-upon-relogin point.
该命令设置指定地图的 "nosave"标志，并给出重新登录时的另一个出现点。

It does not make a map impossible to make a save point on as you would normally
think, 'savepoint' will still work. It will, however, make the specified map
kick the reconnecting players off to the alternate map given to the coordinates
specified.
并非是在无法设置储存点的地图上设置存储点，"savepoint"仍然有效。
不过，它会让指定地图下线后重新上线的玩家出现在指定坐标的其他地图上。

---------------------------------------

*setmapflag "<map name>",<flag>{,<zone>{,<type>}};
*setmapflag "<地图名称>",<标记>{,<范围>{,<类型>}};

This command marks a specified map with the given map flag, which will alter the
behavior of the map. A full list of mapflags is located in 'src/map/script_constants.hpp' with
the 'mf_' prefix, and documentation can be found in 'doc/mapflags.txt'.
该命令用给定的地图设置地图标记，这将改变地图的属性。
mapflags 的完整列表位于以 "mf_"为前缀的 "src/map/script_constants.hpp "中，
文档可在 "doc/mapflags.txt "中找到。

The map flags alter the behavior of the map regarding teleporting (mf_nomemo,
mf_noteleport, mf_nowarp, mf_nogo), storing location when disconnected
(mf_nosave), dead branch usage (mf_nobranch), penalties upon death
(mf_nopenalty, mf_nozenypenalty), PVP behavior (mf_pvp, mf_pvp_noparty,
mf_pvp_noguild), WoE behavior (mf_gvg,mf_gvg_noparty), ability to use
skills or open up trade deals (mf_notrade, mf_novending, mf_noskill, mf_noicewall),
current weather effects (mf_snow, mf_fog, mf_sakura, mf_leaves, mf_rain, mf_clouds,
mf_fireworks) and whether night will be in effect on this map (mf_nightenabled).
地图标记会改变地图的以下属性：传送（mf_nomemo、mf_noteleport、mf_nowarp、mf_nogo）、
断开连接时的位置存储（mf_nosave）、枯树枝的使用（mf_nobranch）、死亡惩罚（mf_nopenalty、mf_nozenypenalty）、
PVP设置（mf_pvp、mf_pvp_noparty、mf_pvp_noguild）、 工会战设置（mf_gvg,mf_gvg_noparty）、
使用技能或开启交易，露天商店，冰枪（mf_notrade, mf_novending, mf_noskill, mf_noicewall）、
当前天气效果（mf_snow, mf_fog, mf_sakura, mf_leaves,mf_rain,mf_clouds,mf_fireworks）
以及黑夜是否会在该地图上生效（mf_nightenabled）。

The optional parameter <zone> is used to set the zone for 'restricted' mapflags,
GM level bypass for 'nocommand', base/job experience for 'bexp'/'jexp', and
flag for 'battleground'.
可选参数 <范围>用于设置 "restricted"受限地图标记的范围、"nocommand":GM 命令可用级别范围、
"bexp"/"jexp ":基础/职业经验获得范围，以及 "battleground"的标记范围。

For 'skill_damage' mapflag:         对于'skill_damage'地图标记：
	- Setting the flag here will adjust the global (all skills) damage on the map.   在此设置标记将调整地图上的全局（所有技能）伤害。
	- <zone> is the -100 to 100000 damage adjustment value of the skills.            <范围> 是技能的 -100 至 100000 伤害调整值。
	- See 'getmapflag' for the different <type> values.                              有关不同的 <范围> 值，请参阅 "getmapflag"。
For 'skill_duration' mapflag:       对于'skill_duration'地图标记：
	- <zone> is the skill ID to adjust.                                     <范围> 是要调整的技能编号。
	- <type> is the percentage of adjustment from 0 to 100000.              <类型> 是调整百分比，从 0 到 100000。

---------------------------------------

*removemapflag "<map name>",<flag>{,<zone>};
*removemapflag "<地图名称>",<标记>{,<范围>};

This command removes a mapflag from a specified map.
See 'setmapflag' for a list of mapflags.
这条命令将删除指定地图上的 mapflag。
有关 mapflag 的列表，请参阅 "setmapflag"。

The optional parameter 'zone' is used to remove the zone from restricted mapflags.
可选参数 "zone "用于从受限的 mapflags 中移除受限范围。

---------------------------------------

*getmapflag("<map name>",<flag>{,<type>})
*getmapflag("<地图名称>",<标记>{,<类型>})


This command checks the status of a given mapflag and returns the mapflag's state.
0 means OFF, and 1 means ON. See 'setmapflag' for a list of mapflags.
该命令检查给定 mapflag 的状态，并返回 mapflag 的状态。
0 表示关闭，1 表示打开。有关 mapflag 的列表，请参阅 "setmapflag"。

For MF_RESTRICTED, the zone value of the map is returned.
对于 MF_RESTRICTED，将返回地图的范围值。

The optional parameter 'type' is used in the 'skill_damage' mapflag:   
可选参数 "类型"用于"skill_damage"地图标记：

 SKILLDMG_MAX: if mapflag is set (default)         是否设置了mapflag（默认）
 SKILLDMG_PC: damage against players               对玩家的伤害
 SKILLDMG_MOB: damage against mobs                 对魔物的伤害
 SKILLDMG_BOSS: damage against bosses              对boss魔物的伤害
 SKILLDMG_OTHER: damage against other              对其他的伤害
 SKILLDMG_CASTER: caster type                      咏唱者类型

---------------------------------------

*setbattleflag "<battle flag>",<value>{,<reload>};
*getbattleflag("<battle flag>")
*setbattleflag "<战斗标记>",<值>{,<重载>};
*getbattleflag("<战斗标记>")


Sets or gets the value of the given battle flag.
Battle flags are the flags found in the battle / *.conf files and is also used in Lupus' variable rates script.
If the reload value is given then the server will attempt to reload monster data
to properly apply the new rates. This applies to EXP/Drop type configs. The server
will only attempt to reload specific configs.
设置或获取给定战斗标记的值。战斗标志是battle/*.conf 文件中的标志，也用于 Lupus 的可变速率脚本。
如果给定了重新加载值，服务器将尝试重新加载怪物数据，以正确应用新倍率。
这也适用于 EXP/Drop 类型的配置。服务器只会尝试重新加载特定配置。
(就是改变战斗配置文件battle/*.conf里的各种设置。[译者注])

Examples:      例子：

// Will set the base experience rate to 20x (2000%) - Monster data will continue to use previous rates at server start
// 将基础经验倍率设置为 20 倍（2000%）--怪物数据将在服务器重新启动时继续使用以前的经验倍率
	setBattleFlag "base_exp_rate",2000;

// Will set the base experience rate to 20x (2000%) - Monster data will be reloaded to new value
// 将基础经验率设置为 20 倍（2000%） - 怪物数据将重新载入新值
	setBattleFlag "base_exp_rate",2000,true;

// Will return the value of the base experience rate (when used after the above example, it would print 2000).
// 将返回基本经验值（在上述示例后使用时，将显示 2000）。
	mes getBattleFlag("base_exp_rate");

---------------------------------------

*warpportal <source x>,<source y>,"<map name>",<target x>,<target y>;
*warpportal <源坐标x>,<源坐标y>,"<地图名称>",<目标坐标x>,<目标坐标y>;

Creates a warp portal identical to the Acolyte "Warp Portal" skill.
The source coordinates specify the portal's location on the map of the invoking NPC.
The target map and coordinates determine the destination of the portal.
创建与服侍 "传送之阵" 技能相同的传送点。源坐标指定传送门出现在调用NPC地图上的位置。
目标地图名称和目标坐标决定传送的目的地。

Examples:     例子：

// Will create a warp portal on the NPC's map at 150,150 leading to prontera, coords 150,180.
//将在NPC所在地图的 150,150 坐标上创建一个传送，通往普隆德拉地图坐标150,180。

	warpportal 150,150,"prontera",150,180;

---------------------------------------

*mapwarp "<from map>","<to map>",<x>,<y>{,<type>,<ID>};
*mapwarp "<出发地图>","<目的地图>",<坐标x>,<坐标y>{,<类型>,<编码>};

This command will collect all characters located on the From map and warp them
wholesale to the same point on the To map, or randomly distribute them there if
the coordinates are zero. "Random" is understood as a special To map name and
will mean randomly shuffling everyone on the same map.
该命令将统计所有位于"出发地图 "上的角色，并将他们传送到"目的地图 "上的同一地点，
如果坐标为零，则将它们随机传送到该地图。"Random"被解释为一种特殊的目的地图名称，
意味着在同一张地图上重新进行随机排布。

Optionally, a type and ID can be specified. Available types are:
可选择指定类型和编码。可用的类型有

 0 - Everyone      所有人
 1 - Guild         工会成员
 2 - Party         组队成员

Example:    例子：

// Will warp all members of guild with ID 63 on map prontera to map alberta.
//将地图普隆德拉上编码为63的所有公会成员传送到地图埃尔贝塔。
	mapwarp "prontera","alberta",150,150,1,63;

---------------------------------------
\\
5,2.- Guild-related commands     工会相关命令
\\
---------------------------------------

*maprespawnguildid "<map name>",<guild id>,<flag>;
*maprespawnguildid "<地图名称>",<工会编号>,<标志>;

This command goes through the specified map and for each player and monster
found there does stuff.
该命令会遍历指定地图，并对发现的每个玩家和魔物进行处理。

Flag is a bit-mask (add up numbers to get effects you want)
标志是一个位掩码（将数字相加即可获得所需的效果）
 1 - warp all guild members to their save points.       将所有公会成员传送到他们的保存点。
 2 - warp all non-guild members (including guildless players) to their save points.         将所有非公会成员（包括无公会玩家）传送到他们的保存点。
 4 - remove all monsters which are not guardian or Emperium.       清除所有非守护者或工会的魔物。

Flag 7 will, therefore, mean 'wipe all mobs but guardians and the Emperium and
kick all characters out', which is what the official scripts do upon castle
surrender. Upon start of WoE, the scripts do 2 (warp all intruders out).
因此，标志 7 将意味着 "清除除守护者和工会里的所有小怪，并将所有角色踢出"，
这也是官方脚本在城堡投降时的做法。工会战启动时，脚本会执行 2（将所有入侵者传送出去）。

For examples, check the WoE scripts in the distribution.
有关示例，请查看发行版中的 工会战 脚本。

---------------------------------------

*agitstart;
*agitend;
*agitstart2;
*agitend2;
*agitstart3;
*agitend3;

These commands will start and end War of Emperium FE, War of Emperium SE,
or War of Emperium TE.
这些命令将启动和结束  FE工会战 、SE工会战或 TE工会战。

This is a bit more complex than it sounds, since the commands themselves won't
actually do anything interesting, except causing all 'OnAgitStart:' and
'OnAgitEnd:', 'OnAgitStart2:' and 'OnAgitEnd2:', or 'OnAgitStart3:' and
'OnAgitEnd3:' in the case of latter two commands, events to run everywhere,
respectively. They are used as  simple triggers to run a lot of complex scripts
all across the server, and they, in turn, are triggered by clock with an
'OnClock<time>:' time-triggering label.
这比听起来要复杂一些，因为命令本身实际上不会做任何有趣的事情，
只是会导致所有 "OnAgitStart: "和 "OnAgitEnd:"、"OnAgitStart2: "和 "OnAgitEnd2:"，
或 "OnAgitStart3: "和 "OnAgitEnd3:"（后两个命令）事件分别在各处运行。
它们被用作简单的触发器，在整个服务器上运行大量复杂的脚本，反过来，
它们又被带有 "OnClock<时间戳>: "时间触发标签的时钟触发。

---------------------------------------

*gvgon "<map name>";
*gvgoff "<map name>";
*gvgon "<地图名称>";
*gvgoff "<地图名称>";

These commands will turn GVG mode for the specified maps on and off, setting up
appropriate map flags. In GVG mode, maps behave as if during the time of WoE,
even though WoE itself may or may not actually be in effect.
这些命令将打开或关闭指定地图的 GVG 模式，并设置相应的地图标记。
在 GVG 模式下，尽管 WoE 本身实际上可能有效，也可能无效，
但地图的属性就如同在 WoE 期间一样。

---------------------------------------

*gvgon3 "<map name>";
*gvgoff3 "<map name>";
*gvgon3 "<地图名称>";
*gvgoff3 "<地图名称>";

Theses commands behave identically to gvgon/gvgoff, but apply GVG_TE mapflag.
这些命令的作用与 gvgon/gvgoff 相同，但应用了 GVG_TE 的地图标签。

---------------------------------------

*flagemblem <guild id>;
*flagemblem <工会编码>;

This command only works when run by the NPC objects which have sprite id 722,
which is a 3D guild flag sprite. If it isn't, the data will change, but nothing
will be seen by anyone. If it is invoked in that manner, the emblem of the
specified guild will appear on the flag, though, if any players are watching it
at this moment, they will not see the emblem change until they move out of sight
of the flag and return.
该命令只有在外观编码为722的NPC对象里运行才有效，即3D公会旗帜图形。
如果不是，数据发生改变后任何人都看不到效果。如果以这种方式调用，指定公会的图标就会出现在旗帜上，
不过，如果此时有任何玩家正在观看，在他们离开旗帜的视野并返回之前，是不会看到图标变化的。

This is commonly used in official guildwar scripts with a function call which
returns a guild id:
这通常用于官方公会战脚本中的函数调用，该函数会返回一个公会编码：
// This will change the emblem on the flag to that of the guild that owns     这将把旗帜上的图标更改为拥有"公会城堡"的公会的图标
// "guildcastle"

    flagemblem GetCastleData("guildcastle",1);

---------------------------------------

*guardian "<map name>",<x>,<y>,"<name to show>",<mob id>{,"<event label>"{,<guardian index>}};
*guardian "<地图名称>",<坐标x>,<坐标y>,"<显示清明>",<魔物编码>{,"<事件标签>"{,<守护者索引>}};

This command is roughly equivalent to 'monster', but is meant to be used with
castle guardian monsters and will only work with them. It will set the guardian
characteristics up according to the castle's investment values and otherwise
set the things up that only castle guardians need.
该命令用法和"monster"相同，但只适用于城堡守护者魔物。
它会根据城堡的投资度设置守护者的强度，并设置城堡守护者才需要的其他属性。

Since trunk r12524:
Returns the id of the mob or 0 if an error occurred.
When 'guardian index' isn't supplied it produces a temporary guardian.
Temporary guardians are not saved with the castle and can't be accessed by guardianinfo.
从版本trunk r12524 起：
返回魔物的编号，如果发生错误，则返回 0。
如果没有提供 "守护者索引"，则会生成一个临时守护者。
临时守护者不会与城堡信息一起保存，也无法通过guardianinfo进行访问。

---------------------------------------

*guardianinfo("<map name>", <guardian number>, <type>);
*guardianinfo("<地图名称>", <守护者编号>, <类型>);

This function will return various info about the specified guardian, or -1
if it fails for some reason. It is primarily used in the castle manager NPC.
该函数将返回有关指定守护者的各种信息，如果因故失败，则返回-1。
它主要用于城堡管理员NPC。

Map name and guardian number (value between 0 and 7) define the target.
Type indicates what information to return:
地图名称和守护者编号（值介于 0 和 7 之间）定义了目标。
类型表示要返回的信息：
 0 - visibility (whether the guardian is installed or not)     可见性（是否设置了监护人）
 1 - max. hp                                                   最大hp
 2 - current hp                                                当前hp

---------------------------------------

*getguildalliance(<guild id1>, <guild id2>);
*getguildalliance(<工会编号1>, <工会编号2>);

This command will return the relation between 2 guilds.
此命令将返回两个工会之间的关系。

NOTE: This should be used in collaboration with 'requestguildinfo' as the
map-server needs to request for information from the char-server.
注意：应与 "requestguildinfo"（请求工会信息）配合使用，因为地图服务器需要向角色服务器请求信息。

Return values:
返回值：
	-2 - Guild ID1 does not exist                                   工会编号1的工会不存在
	-1 - Guild ID2 does not exist                                   工会编号2的工会不存在
	 0 - Both guilds have no relation OR guild ID aren't given      两个工会没有关系，或者没有提供公会 ID
	 1 - Both guilds are allies                                     两个工会都是盟友
	 2 - Both guilds are antagonists                                两个工会都是对手

---------------------------------------
//
5,2.- End of guild-related commands     与公会有关的命令结束
//
---------------------------------------

*npcspeed <speed value>;
*npcwalkto <x>,<y>;
*npcstop;
*npcspeed <速度值>;
*npcwalkto <坐标x>,<坐标y>;
*npcstop;

These commands will make the NPC object in question move around the map. As they
currently are, they are a bit buggy and are not useful for much more than making
an NPC move randomly around the map.
这些命令将使相关的 NPC 对象在地图上移动。就目前的情况而言，它们存在一些漏洞，
而且除了让 NPC 在地图上随机移动之外，并无其他作用。

'npcspeed' will set the NPCs walking speed to a specified value. As in the
@speed GM command, 200 is the slowest possible speed while 0 is the fastest
possible (instant motion). 100 is the default character walking speed.
"npcspeed"会将 NPC 的行走速度设置为指定值。在 @speed GM 命令中，200 是最慢的速度，
而 0 则是最快的速度（瞬间移动）。100 是默认的角色行走速度。

'npcwalkto' will start the NPC sprite moving towards the specified coordinates
on the same map it is currently on. The script proceeds immediately after the
NPC begins moving.
”npcwalkto"将使 NPC 形象开始向其当前所在地图上的指定坐标移动。
NPC 开始移动后，脚本立即开始。

'npcstop' will stop the motion.
"npcstop"会停止运动。

While in transit, the NPC will be clickable, but invoking it will cause it to
stop moving, which will make its coordinates different from what the client
computed based on the speed and motion coordinates. The effect is rather
unnerving.
在移动过程中，NPC 可以点击，但调用它将导致其停止移动，
这将使其坐标与客户端根据速度和运动坐标计算出的坐标不同。
这种效果相当令人不安。

Only a few NPC sprites have walking animations, and those that do, do not get
the animation invoked when moving the NPC, due to the problem in the NPC walking
code, which looks a bit silly. You might have better success by defining a job-
sprite based sprite id in 'db/mob_avail.txt' with this.
由于 NPC 步行代码中的问题，只有少数 NPC 形象有步行动画，
而那些有步行动画的 NPC 在移动时不会调用动画，这看起来有点傻。
在 "db/mob_avail.txt "中定义基于角色形象的形象 ID，可能会取得更好的效果。

---------------------------------------

*movenpc "<NPC name>",<x>,<y>{,<dir>};
*movenpc "<NPC名称>",<坐标x>,<坐标y>{,<方向>};

This command looks like the NPCWalkToxy function,but is a little different.
这条命令看起来像 NPCWalkToxy 函数，但又有些不同。

While NPCWalkToXY just makes the NPC 'walk' to the coordinates given (which
sometimes gives problems if the path isn't a straight line without objects),
this command just moves the NPC. It basically warps out and in on the current
and given spot. Direction can be used to change the NPC's facing direction.
NPCWalkToXY 只是让 NPC "走 "到给定的坐标（如果路径不是一条没有物体的直线，有时会出现问题），
而这条命令只是移动 NPC。它基本上是在当前和给定的位置上传送或跳跃。方向可以用来改变 NPC 的朝向。

Example:
例子：

// This will move Bugga from it's old coordinates to the new coordinates at 100,20 (if those coordinates are legit).
//这将把 Bugga 从它的旧坐标移动到 100,20 处的新坐标（如果这些坐标是合法的）。
	moveNPC "Bugga",100,20;

---------------------------------------

=====================
|6.- Other commands.|    其他命令
=====================
---------------------------------------

*debugmes "<message>";
*debugmes "<信息>";

This command will send a debug message to the server console (map-server window). It
will not be displayed anywhere else.
该命令将向服务器控制台（map-server 窗口）发送调试信息。它不会显示在其他任何地方。

    // Displays "NAME has clicked me!" in the map-server window.
	//在地图服务器窗口中显示 "名字 has clicked me!"。
    debugmes strcharinfo(0) + " has clicked me!";

---------------------------------------

*errormes "<message>";
*errormes "<信息>";

This command will send an error message to the server console (map-server window). It
will not be displayed anywhere else.
该命令将向服务器控制台（map-server 窗口）发送错误信息。它不会显示在其他任何地方。

    // Displays "NAME has clicked me!" in the map-server window.
	//在地图服务器窗口中显示 "名字 has clicked me!"。
    errormes strcharinfo(0) + " has clicked me!";

---------------------------------------

*logmes "<message>";
*logmes "<信息>";

This command will write the message given to the map server NPC log file, as
specified in 'conf/log_athena.conf'. In the TXT version of the server, the log
file is 'log/npclog.log' by default. In the SQL version, if SQL logging is
enabled, the message will go to the 'npclog' table, otherwise, it will go to the
same log file.
此命令将把信息写入 "conf/log_athena.conf "中指定的地图服务器 NPC 日志文件。
在 TXT 版本的服务器中，日志文件默认为 "log/npclog.log"。
在 SQL 版本中，如果启用了 SQL 日志，信息将进入 "npclog "表，否则将进入同一日志文件。

If logs are not enabled, nothing will happen.
如果未启用日志功能，则什么也不会发生。

---------------------------------------

*globalmes "<message>"{,"<NPC name>"};
*globalmes "<信息>"{,"<NPC名称>"};

This command will send a message to the chat window of all currently connected
characters.
此命令将向当前在线的所有角色的聊天窗口发送一条信息。

If NPC name is specified, the message will be sent as if the sender would be
the NPC with the said name.
The display name of the NPC won't get appended in front of the message.
如果指定了 NPC 名称，则发送信息时会将发件人视为具有该名称的 NPC。
NPC 的显示名称不会附加在信息前面。

---------------------------------------

*rand(<number>{,<number>});
*rand(<数值>{,<数值>});

This function returns a number ...
(if you specify one) ... randomly positioned between 0 and the number you specify -1.
(if you specify two) ... randomly positioned between the two numbers you specify.
该函数返回一个数值 ...
(如果您指定了一个数值）......在 0 和您指定的数值-1 之间随机取数。
(如果您指定两个数值）......在您指定的两个数值之间随机取数。

rand(10)  would result in 0,1,2,3,4,5,6,7,8 or 9
rand(0,9) would result in 0,1,2,3,4,5,6,7,8 or 9
rand(2,5) would result in 2,3,4 or 5

rand(10)  将返回 0,1,2,3,4,5,6,7,8 或 9
rand(0,9) 将返回 0,1,2,3,4,5,6,7,8 或 9
rand(2,5) 将返回 2,3,4 或 5

---------------------------------------

*viewpoint <action>,<x>,<y>,<point number>,<color>{,<Char ID>};
*viewpoint <操作>,<坐标x>,<坐标y>,<点编号>,<颜色>{,<角色编号>};

This command will mark places on the mini map in the client connected to the
invoking character. It uses the normal X and Y coordinates from the main map.
The colors of the marks are defined using a hexadecimal number, same as the ones
used to color text in 'mes' output, but are written as hexadecimal numbers in C.
(They look like 0x<six numbers>.)
该命令将在与调用角色相连的客户端中的小地图上标记地点。它使用主地图上的正常 X 坐标和 Y 坐标。
标记的颜色用十六进制数定义，与 "mes "输出中文本的颜色相同，但在 C 语言中写成十六进制数。
(显示为 0x<6个数字>）。

Action is what you want to do with a point, 1 will set it, while 2 will clear
it. 0 will also set it, but automatically removes the point after 15 seconds.
Point number is the number of the point - you can have several. If more than
one point is drawn at the same coordinates, they will cycle, which can be used
to create flashing marks.
<操作>是您想对一个点做什么操作，1 将设置它，而 2 则清除它。
0 也会设置，但会在 15 秒后自动移除该点。
点编号是点的编号，可以有多个。如果在同一坐标上绘制了多个点，
它们将循环出现，这可用于创建闪烁标记。

	// This command will show a mark at coordinates X 30 Y 40, is mark number 1,
	// and will be red.
	//该命令将显示一个坐标为 X 30 Y 40 的标记，标记编号为 1，标记颜色为红色。

	viewpoint 1,30,40,1,0xFF0000;

This will create three points:
这将创建三个点：

	viewpoint 1,30,40,1,0xFF0000;
	viewpoint 1,35,45,2,0xFF0000;
	viewpoint 1,40,50,3,0xFF0000;

And this is how you remove them:
这就是如何移除它们：

	viewpoint 2,30,40,1,0xFF0000;
	viewpoint 2,35,45,2,0xFF0000;
	viewpoint 2,40,50,3,0xFF0000;

The client determines what it does with the points entirely, the server keeps no
memory of where the points are set whatsoever.
客户端完全自行决定如何处理这些点，服务器不会记住这些点的设置位置。

---------------------------------------

*viewpointmap "<map name>",<action>,<x>,<y>,<point number>,<color>;
*viewpointmap "<地图名称>",<操作>,<坐标x>,<坐标y>,<标示点数量>,<颜色>;

This command will mark places on the mini map in the client for all players currently
on the defined map. It uses the normal X and Y coordinates from the main map.
The colors of the marks are defined using a hexadecimal number, same as the ones
used to color text in 'mes' output, but are written as hexadecimal numbers in C.
(They look like 0x<six numbers>.)
该命令将在客户端的小地图上为当前在已定义地图上的所有玩家标记位置。它使用主地图上的正常 X 坐标和 Y 坐标。
标记的颜色使用十六进制数定义，与 "mes"输出中文本的颜色相同，但在 C 语言中写成十六进制数。
(它们看起来像 0x<六个数字>）。

Action is what you want to do with a point, 1 will set it, while 2 will clear
it. 0 will also set it, but automatically removes the point after 15 seconds.
Point number is the number of the point - you can have several. If more than
one point is drawn at the same coordinates, they will cycle, which can be used
to create flashing marks.
操作是您想对一个点做什么，1 将设置它，而 2 将清除它。0 也会设置它，但会在 15 秒后自动删除该点。
点编号是点的编号，可以有多个。如果在同一坐标上绘制了多个点，它们将循环出现，这可以用来创建闪烁标记。

	// This command will show a mark at coordinates X 30 Y 40, is mark number 1,   该命令将在坐标 X 30 Y 40 处显示一个标记，标记编号为 1，
	// and will be red for all players currently on the map Prontera.              对当前在 Prontera 地图上的所有玩家都将显示为红色。

	viewpointmap "prontera",1,30,40,1,0xFF0000;

This will create three points:
这将创建三个点：
	.@map$ = "prontera";
	viewpointmap .@map$,1,30,40,1,0xFF0000;
	viewpointmap .@map$,1,35,45,2,0xFF0000;
	viewpointmap .@map$,1,40,50,3,0xFF0000;

And this is how you remove them:
这就是如何移除它们：
	.@map$ = "prontera";
	viewpointmap .@map$,2,30,40,1,0xFF0000;
	viewpointmap .@map$,2,35,45,2,0xFF0000;
	viewpointmap .@map$,2,40,50,3,0xFF0000;

The client determines what it does with the points entirely, the server keeps no
memory of where the points are set whatsoever.
客户端完全自行决定如何处理这些点，服务器不会记住这些点的设置位置。

---------------------------------------

*cutin "<filename>",<position>;
*cutin "<文件名>",<位置>;

This command will display a picture, usually an NPC illustration, also called
cutin, for the currently attached client. The position parameter determines the
placement of the illustration and takes following values:
此命令将为当前连接的客户端显示一张图片，通常是 NPC 插图，也称为 cutin。
位置参数决定插图的位置，取值如下：

	0	bottom left corner     左下角
	1	bottom middle          下中间
	2	bottom right corner    右下角
	3	middle of screen in a movable window with an empty title bar       屏幕中间的活动窗口，标题栏为空
	4	middle of screen without the window header, but still movable      屏幕中间没有窗头，但仍可移动
	255	clear all displayed cutins  清除所有显示的插图

The picture is read from data\texture\유저인터페이스\illust, from both the GRF archive
and data folder, and is required to be a bitmap. The file extension .bmp can be
omitted. Magenta color (#ff00ff) is considered transparent. There is no limit
placed on the size of the illustrations by the client, although loading of large
pictures (about 700x700 and larger) causes the client to freeze shortly (lag).
Typically the size is about 320x480. New illustrations can be added by just
putting the new file into the location above.
图片是从 GRF 存档和数据文件夹中的 data\texture\유저인터페이스\illust 读取的，要求是bmp位图。
文件扩展名 .bmp 可以省略。洋红色（#ff00ff）被视为透明色。
客户端对插图的大小没有限制，但加载大图片（约 700x700 或更大）时会导致客户端短暂停滞（延迟）。
通常大小约为 320x480。只需将新文件放入上述位置，即可添加新插图。


The client is able to display only one cutin at the same time and each new one
will cause the old one to disappear. To delete the currently displayed
illustration without displaying a new one, an empty file name and position 255
must be used.
客户端同一时间只能显示一个插图，每个新的插图都会导致旧的插图消失。
要删除当前显示的插图而不显示新插图，必须使用空文件名和位置 255。

	// Displays the Comodo Kafra illustration in lower right corner.
	//在右下角显示 克魔岛卡普拉 插图。
	cutin "kafra_07",2;

	// Typical way to end a script, which displayed an illustration during a
	// dialog with a player.   结束脚本的典型方式，该脚本在与玩家对话时显示插图。
	mes "See you.";
	close2;
	cutin "",255;
	end;

---------------------------------------

*emotion <emotion number>{,<target>};
*emotion <表情编号>{,<目标>};

This command makes an object display an emotion sprite above their own as
if they were doing that emotion. For a full list of emotion numbers,
see 'src/map/script_constants.hpp' under 'ET_'. The not so obvious ones are 'ET_QUESTION'
(a question mark) and 'ET_SURPRISE' (the exclamation mark).
该命令会让一个对象在自己的上方显示一个表情符号，就好像他们正在使用该表情一样。
有关表情编号的完整列表，请参阅"src/map/script_constants.hpp"以"ET_"开头的常量 。
不太明显的是 "ET_QUESTION"（问号）和 "ET_SURPRISE"（感叹号）。

The optional target parameter specifies who will get the emotion on top of
their head. Use the target Game ID (GID).
可选的目标参数指定了谁将显示头顶上的表情附表。使用游戏 ID（GID）作为目标参数。

---------------------------------------

*misceffect <effect number>;
*misceffect <特效编码>;

This command, if run from an NPC object that has a sprite, will call up a
specified effect number, centered on the NPC sprite. If the running code does
not have an object ID (a 'floating' NPC) or is not running from an NPC object at
all (an item script) the effect will be centered on the character who's RID got
attached to the script, if any. For usable item scripts, this command will
create an effect centered on the player using the item.
如果在有形象的 NPC 对象中运行此命令，将以 NPC 形象为中心调用指定的特效编号。
如果运行的代码没有对象 ID（"浮动"NPC），或者根本不是从 NPC 对象运行的（物品脚本），
则特效将以脚本关联 RID 的角色为中心（如果有的话）。对于可用物品脚本，
该命令将以使用该物品的玩家为中心创建一个特效。

A full list of known effects is found in 'doc/effect_list.txt'. The list of
those that actually work may differ greatly between client versions.
完整的已知特效编号参考doc/effect_list.txt 文件。
不同版本的客户端可能会有很大的不同，其中实际有效的列表可能会有很大的不同。

---------------------------------------

*soundeffect "<effect filename>",<type>;
*soundeffectall "<effect filename>",<type>{,"<map name>"}{,<x0>,<y0>,<x1>,<y1>};
*soundeffect "<音效文件名称>",<类型>;
*soundeffectall "<音效文件名称>",<类型>{,"<地图名称>"}{,<坐标x0>,<坐标y0>,<坐标x1>,<坐标y1>};

These two commands will play a sound effect to either the invoking character
only ('soundeffect') or multiple characters ('soundeffectall'). If the running
code does not have an object ID (a 'floating' NPC) or is not running from an NPC
object at all (an item script) the sound will be centered on the character who's
RID got attached to the script, if any. If it does, it will be centered on that
object. (an NPC sprite)
这两条命令将只对调用角色（'soundeffect'）或对多个角色（'soundeffectall'）播放音效。
如果运行的代码没有对象 ID（"浮动 "NPC），或者根本不是从 NPC 对象运行的（物品脚本），
声音将以脚本关联 RID 的角色为中心（如果有的话）。如果是，它就会以该对象为中心。(一个 NPC 形象）

Effect filename is the filename in a GRF. It must have the .wav extension.
效果文件名是 GRF 中的文件名。扩展名必须是 .wav。

It's not quite certain what the 'type' actually does, it is sent to the client
directly. It probably determines which directory to play the effect from.
It's certain that giving 0 for the number will play sound files from '\data\wav\',
but where the other numbers will read from is unclear.
目前还不太清楚 "类型"的实际作用，它是直接发送给客户端的。它可能决定从哪个目录播放音效。
可以肯定的是，数字为 0 将播放来自"\data\wav\"的声音文件，但其他数字将从何处读取还不清楚。

The sound files themselves must be in the PCM format, and file names should also
have a maximum length of 23 characters including the .wav extension:
声音文件本身必须是 PCM 格式，文件名（包括 .wav 扩展名）最长不得超过 23 个字符：

soundeffect "1234567890123456789.wav", 0; // this will play the soundeffect     这将播放音效
soundeffect "12345678901234567890.wav", 0; // throw gravity error

You can add your own effects this way, naturally.
当然，您也可以通过这种方式添加自己的音效。

---------------------------------------

*playBGM "<BGM filename>";
*playBGMall "<BGM filename>"{,"<map name>"{,<x0>,<y0>,<x1>,<y1>}};
*playBGM "<BGM文件名称>";
*playBGMall "<BGM文件名称>"{,"<地图名称>"{,<坐标x0>,<坐标y0>,<坐标x1>,<坐标y1>}};

These two commands will play a Background Music to either the invoking character
only ('playBGM') or multiple characters ('playBGMall').
这两条命令将只为调用角色播放背景音乐（'playBGM'）或为多个角色播放背景音乐（'playBGMall'）。

BGM filename is the filename in /BGM/ folder. It has to be in .mp3 extension.
BGM 文件名是 /BGM/ 文件夹中的文件名。扩展名必须为 .mp3。

It's not required to specify the extension inside the script.
If coordinates are omitted, BGM will be broadcasted on the entire map. If the map name
is omitted as well the BGM will be played for the entire server.
无需在脚本中指定扩展名。如果省略坐标，BGM 将在整个地图上播放。
如果地图名称也被省略，则整个服务器都将播放 BGM。

You can add your own BGMs this way, naturally.
当然，您也可以通过这种方式添加自己的BGM。

---------------------------------------

*pvpon "<map name>";
*pvpoff "<map name>";
*pvpon "<地图名称>";
*pvpoff "<地图名称>";

These commands will turn PVP mode for the specified maps on and off. Beside
setting the flags referred to in 'setmapflag', 'pvpon' will also create a PVP
timer and ranking as will @pvpon GM command do.
这些命令将打开或关闭指定地图的 PVP 模式。
除了设置 "setmapflag"中提到的标志外，"pvpon "还将创建 PVP 计时器和排名，
正如 @pvpon GM 命令所做的那样。

---------------------------------------

*atcommand "<command>";
*atcommand "<命令>";

This command will run the given command line exactly as if it was typed in from
the keyboard by the player connected to the invoking character, and that
character belonged to an account which had GM level 99.
该命令将运行给定的GM命令，就像由调用角色的玩家从键盘上输入一样，
而且该角色属于一个 GM 等级为 99 的账户。

	// This will ask the invoker for a character name and then use the '@nuke'   它会询问调用者角色名称，
	// GM command on them, killing them mercilessly.                             然后对其使用"@nuke "GM 命令，毫不留情地杀死他们。
	input .@player$;
	atcommand "@nuke " + .@player$;

Note that for atcommands bound using 'bindatcmd', this command will execute the
original atcommand, not the script-bound atcommand.
请注意，对于使用 "bindatcmd "绑定的 atcommand，
该命令将执行原始 atcommand，而不是脚本绑定的 atcommand。

---------------------------------------

*charcommand "<command>";
*charcommand "<命令>";

This command will run the given command line exactly as if it was typed in from
the keyboard from a character that belonged to an account which had GM level 99.
该命令将运行给定的GM命令，就像从属于 GM 等级为 99 的账户的角色键盘上输入一样。

The commands can also run without an attached rid.
这些命令也可以在没有关联角色的情况下运行。

	// This would do the same as above, but now       这样做的结果与上述相同，
	// it doesn't need a player attached by default.  区别在于默认情况下不需要关联角色。
	charcommand "#option 0 0 0 Roy";

---------------------------------------

*bindatcmd "<command>","<NPC object name>::<event label>"{,<atcommand level>,<charcommand level>};
*bindatcmd "<命令>","<NPC对象名称>::<事件标签>"{,<atcommand命令等级>,<charcommand命令等级>};

This command will bind a NPC event label to an atcommand. Upon execution of the
atcommand, the user will invoke the NPC event label. Each atcommand is only allowed
one binding. If you rebind, it will override the original binding.
Note: The default level for atcommand is 0 while the default level for charcommand is 100.
此命令将把 NPC 事件标签绑定到 atcommand 上。执行 atcommand 命令后，用户将调用 NPC 事件标签。
每个 atcommand 只允许绑定一次。如果重新绑定，将覆盖原来的绑定。
注意：atcommand 的默认级别为 0，而 charcommand 的默认级别为 100。

The following variables are set upon execution:
执行时将设置以下变量：
	.@atcmd_command$       =  The name of the @command used.     所用 @ 命令的名称。
	.@atcmd_parameters$[]  =  Array containing the given parameters, starting from an index of 0.   包含给定参数的数组，从索引 0 开始。
	.@atcmd_numparameters  =  The number of parameters defined.    定义的参数数量。

Example:
例子：

	When a user types the command "@test", an angel effect will be shown.
	当用户键入"@test "命令时，将显示天使特效。

	-	script	atcmd_example	-1,{
	OnInit:
		bindatcmd "test",strnpcinfo(3) + "::OnAtcommand";
		end;
	OnAtcommand:
		specialeffect2 EF_ANGEL2;
		end;
	}

---------------------------------------

*unbindatcmd "<command>";
*unbindatcmd "<命令>";

This command will unbind a NPC event label from an atcommand.
此命令将解除 NPC 事件标签与 atcommand 的绑定。

---------------------------------------

*useatcmd "<command>";
*useatcmd "<命令>";

This command will execute a script-bound atcommand for the attached RID. If the
supplied command is not bound to any script, this command will act like 'atcommand'
and attempt to execute a source-defined command.
该命令将针对所关联的 RID 执行脚本绑定的 atcommand。
如果提供的命令没有绑定到任何脚本，该命令将像 "atcommand "一样，尝试执行源代码定义的命令。

The three .@atcmd_***** variables will NOT be set when invoking script-bound atcommands
in this way.
以这种方式调用脚本绑定的 atcommand 时，不会设置三个 .@atcmd_***** 变量。

---------------------------------------

*camerainfo <range>,<rotation>,<latitude>{,<char id>};
*camerainfo <范围>,<旋转>,<俯仰角度>{,<角色编码>};

This command will update the client's camera information with the given values where
the client can be the attached character or the player given by the char id parameter.
Note: This requires 2016-05-25aRagexeRE or newer.
该命令将根据给定值更新客户端的视角信息，其中客户端可以是关联角色，也可以是<角色编码>参数指定的玩家。
注意：这需要 2016-05-25aRagexeRE 或更新版本。

The values given will be divided by 100 and transmitted as floating-point number.
给出的数值将除以 100，并以浮点数的形式传输。

	range		The zoomfactor of the camera.                           范围		视角的远近系数。
				Default: 230000 (230.0) when fully zoomed in            			默认: 230000 (230.0) 当拉近到最大
				Maximum: 400000 (400.0) when fully zoomed out           			最大值: 400000 (400.0) 当拉远到最小
                                                                        
	rotation	The rotation of the camera.                             旋转		视角的旋转.
				Default: 0 (0.0) when no rotation is applied            			默认: 0 (0.0) 不旋转
				Maximum: 360000 (360.0°) when fully rotated             			最大值: 360000 (360.0°) 旋转一圈(360°)
                                                                        
	latitude	The angle of the camera.                                俯仰角度	视角俯仰的角度
				Default: -50000 (-50.0)                                 			默认: -50000 (-50.0)
				Maximum: -75000 (-75.0)                                 			最大值: -75000 (-75.0)

---------------------------------------

*openstylist({<char id>})
*openstylist({<角色编号>})

Opens the stylist UI for the attached player or the given character id.
打开关联玩家或给定角色编号的造型师用户界面。

This feature requires packet version 2015-11-04 or newer.
此功能需要 2015-11-04 或更新版本的数据封包。

---------------------------------------

*laphine_synthesis({<item id>})
*laphine_synthesis({<"item name">})
*laphine_synthesis({<物品编号>})
*laphine_synthesis({<"物品名称">})

Opens the laphine synthesis UI for <item ID> or <item name> for the attached player.
If run from within an item script <item ID> or <item name> is optional.
为关联玩家打开 <物品编号> 或 <物品名称> 的 laphine 合成界面。
如果在物品脚本中运行 <物品编号> 或 <物品名称>，则为可选项。

This feature requires packet version 2016-06-01 or newer.
此功能要求数据封包版本为 2016-06-01 或更新版本。

---------------------------------------

*laphine_upgrade()

Opens the laphine upgrade UI for the attached player.
打开关联玩家的laphine升级界面。

This feature requires packet version 2017-07-26 or newer.
此功能要求数据封包版本为 2017-07-26 或更新版本。

This function is intended for use in item scripts.
该功能用于物品脚本。

---------------------------------------

*openbank({<char id>})
*openbank({<角色编号>})

Opens the Bank UI for the attached player or the given character ID.
打开关联玩家或给定角色编号的银行用户界面。

This command requires packet version 2015-12-02 or newer.
此功能要求数据封包版本为 2015-12-02 或更新版本。

---------------------------------------

*enchantgradeui {<char id>};
*enchantgradeui {<角色编号>};

Opens the enchantgrade UI for the attached character or the player given by the char ID parameter.
打开关联角色或角色编号参数指定的玩家的附魔升级界面。

This command requires packet version 2020-07-24 or newer.
此功能要求数据封包版本为 2020-07-24 或更新版本。

---------------------------------------

*set_reputation_points(<type>,<points>{,<char id>})
*set_reputation_points(<类型>,<点数>{,<角色编号>})

Sets the reputation points via <points> for reputation group <type> for the attached player or the given character ID.
<type> is the client side index as stored in the Id field of the reputation.yml database files.
通过 <点数> 为声望组 <类型> 设置关联玩家或给定角色编号的声望点数。
<类型> 是存储在 reputation.yml 数据库文件 Id 字段中的客户端索引。

---------------------------------------

*get_reputation_points(<type>{,<char id>})
*get_reputation_points(<类型>{,<角色编号>})

Gets the reputation points for reputation group <type> for the attached player or the given character ID.
<type> is the client side index as stored in the Id field of the reputation.yml database files.
为关联玩家或给定角色编号获取声望组 <类型> 的声望点数。
<类型> 是存储在 reputation.yml 数据库文件 Id 字段中的客户端索引。

---------------------------------------

*add_reputation_points(<type>,<points>{,<char id>})
*add_reputation_points(<类型>,<点数>{,<角色编号>})

Adds the reputation points via <points> for reputation group <type> for the attached player or the given character ID.
<type> is the client side index as stored in the Id field of the reputation.yml database files.
通过 <点数> 为关联玩家或给定角色编号的声望组 <type> 添加声望点数。
<类型> 是存储在 reputation.yml 数据库文件 Id 字段中的客户端索引。

---------------------------------------

*item_reform({<item id>{,<char id>}})
*item_reform({<"item name">{,<char id>}})
*item_reform({<物品编号>{,<角色编号>}})
*item_reform({<"物品名称">{,<角色编号>}})

Opens the item reform UI for <item ID> or <item name> for the attached player or the given character ID.
If run from within an item script <item ID> or <item name> is optional.
为关联玩家或给定角色编号的 <物品编号> 或 <物品名称> 打开物品改造 UI。
如果在物品脚本中运行 <物品编号> 或 <物品名称>，则为可选项。

This feature requires packet version 2021-11-03 or newer.
此功能要求数据封包版本为 2021-11-03 或更新版本。

---------------------------------------

*item_enchant(<client side LUA index>{,<char ID>});
*item_enchant(<客户端 LUA 索引>{,<角色编号>});

Opens the enchant UI for the attached character or the player given by the <char ID> parameter.
If the player exceeds 70% weight the client will not open the enchant UI and will trigger an
error message instead.
打开关联角色或 <角色编号> 参数指定的玩家的附魔界面。
如果玩家体重超过 70%，客户端将不会打开附魔界面，而会触发一条错误信息。


This command requires packet version 2021-11-03 or newer.
此功能要求数据封包版本为 2021-11-03 或更新版本。

---------------------------------------

*opentips({<Tip ID>,{<char ID>}});
*opentips({<提示编号>,{<角色编号>}});

Opens the tip box UI for the attached player or the given character ID.
打开关联玩家或给定角色编号的提示框界面。

This command requires packet version 2017-11-22 or newer.
此功能要求数据封包版本为 2017-11-22 或更新版本。

---------------------------------------
\\
6,1.- Unit-related commands     单位相关命令
\\
---------------------------------------

*unitwalk <GID>,<x>,<y>{,"<event label>"};
*unitwalkto <GID>,<Target GID>{,"<event label>"};
*unitwalk <GID>,<坐标x>,<坐标y>{,"<事件标签>"};
*unitwalkto <GID>,<目标GID>{,"<事件标签>"};

This command will tell a <GID> to walk to a position, defined either as a set of
coordinates or another object. The command returns a 1 for success and 0 upon failure.
这条命令将指示 <GID> 走到一个位置，这个位置可以是一组坐标，也可以是另一个对象。
命令成功返回 1，失败返回 0。


If coordinates are passed, the <GID> will walk to the given x,y coordinates on the
unit's current map. While there is no way to move across an entire map with 1 command
use, this could be used in a loop to move long distances.
如果传递了坐标，<GID> 将走到单位当前地图上给定的 x、y 坐标处。
虽然使用一条指令无法移动整个地图，但可以循环使用，进行长距离移动。

If an object ID is passed, the initial <GID> will walk to the <Target GID> (similar to
walking to attack). This is based on the distance from <GID> to <Target ID>. This command
uses a hard walk check, so it will calculate a walk path with obstacles. Sending a bad
target ID will result in an error.
如果传递了对象 ID，初始 <GID> 将走到 <目标GID> 处（类似于走到攻击处）。
这是基于 <GID> 到 <目标ID> 的距离。该命令使用硬行走检查，因此会计算出一条有障碍物的行走路径。
发送错误的目标ID将导致错误。

An optional Event Label can be passed as well which will execute when the <GID> has reached
the given coordinates or <Target GID>.
还可以传递一个可选的事件标签，该标签将在 <GID> 到达给定坐标或 <目标GID> 时执行。

Examples:
例子：

// Makes player walk to the coordinates (150,150).
//使玩家走到坐标（150,150）处。
	unitwalk getcharid(3),150,150;

// Performs a conditional check with the command and reports success or failure to the player.
//对命令执行条件检查，并向玩家报告成功或失败。
	if (unitwalk(getcharid(3),150,150))
		dispbottom "Walking you there...";
	else
		dispbottom "That's too far away, man.";

// Makes player walk to another character named "WalkToMe".
//让玩家走到另一个名为 "WalkToMe "的角色身边。
	unitwalkto getcharid(3),getcharid(3,"WalkToMe");

---------------------------------------

*unitattack <GID>,<Target ID>{,<action type>};
*unitattack <GID>,"<Target Name>"{,<action type>};
*unitattack <GID>,<目标编号>{,<动作类型>};
*unitattack <GID>,"<目标名称>"{,<动作类型>};

This command will make a <GID> attack the specified target. It returns true upon
success and false for all failures.
这条命令将使 <GID> 攻击指定目标。成功时返回 true，失败时返回 false。

If <GID> is a player and a non-zero <action type> is given, the unit will perform a
continuous attack instead of a single attack.
如果 <GID> 是玩家，并且给出了非零的 <动作类型>，则该单位将执行连续攻击，而不是单次攻击。

Note:
Using unitattack with <GID> 0 means that it will use the currently attached unit.
For players any attack requests will fail, because talking to an NPC prevents attacking a monster.
Therefore you need to detach the player from the NPC before using this command.
注意：
在 <GID> 0 时使用 unitattack 意味着将使用当前关联的单位。
对于玩家来说，任何攻击请求都会失败，因为与 NPC 交谈会阻止攻击怪物。
因此，在使用该命令之前，您需要将玩家与 NPC 分离。

---------------------------------------

*unitkill <GID>;

This command will kill a <GID>.
该命令将杀死指定 <GID>。

---------------------------------------

*unitwarp <GID>,"<map name>",<x>,<y>;
*unitwarp <GID>,"<地图名称>",<坐标x>,<坐标y>;

This command will warp a <GID> to the specified map and coordinates.
这条命令将把 <GID> 传送到指定的地图和坐标。

If <GID> is zero, the command runs for the unit that invoked the script. This can be
used with "OnTouch" to warp monsters:
如果 <GID> 为零，命令将在调用脚本的单位运行。
该功能可与 "OnTouch "配合使用，令魔物传送：

OnTouch:
	unitwarp 0,"this",-1,-1;

---------------------------------------

*unitstopattack <GID>;

This command will make a <GID> stop attacking.
这条命令将使 <GID> 停止攻击。

---------------------------------------

*unitstopwalk <GID>{,<flag>};
*unitstopwalk <GID>{,<标识>};

This command will make a <GID> stop moving.
这条命令将使 <GID> 停止移动。

Note: If this is called from OnTouch, then the walktimer attached to the unit is
removed from OnTouch which causes this command to not stop the unit from walking.
Suggest to use 'unitblockmove' to forcefully stop the unit with OnTouch.
注意：如果从 OnTouch 调用此命令，则会从 OnTouch 移除关联单位的行走定时器，
从而导致此命令无法阻止单位行走。建议使用 "unitblockmove"通过 OnTouch 强制停止单位。

The <flag> value affects how the unit is stopped. The following flags are bitwise
values (can be combined using the pipe operator):
<标识> 值会影响单位的停止方式。
	USW_NONE = Unit will keep walking to their original destination.   单位将继续步行前往原定目的地。
	USW_FIXPOS = Issue a fixpos packet afterwards.    之后发出一个 fixpos 数据包。
	USW_MOVE_ONCE = Force the unit to move one cell if it hasn't yet.    如果单位尚未移动，则强制其移动一个单元格。
	USW_MOVE_FULL_CELL = Enable moving to the next cell when unit was already half-way there (may cause on-touch/place side-effects, such as a scripted map change).   当单位已经移动到下一个单元的一半时，启用移动到下一个单元（可能会导致触摸/位置副作用，例如脚本地图更改）。
	USW_FORCE_STOP = Force stop moving.  强制停止移动

---------------------------------------

*unittalk <GID>,"<text>"{,flag};
*unittalk <GID>,"<文本>"{,标识};

This command will make a <GID> say a message. The display name of the <GID> won't get appended in front of the message.
flag: Specify target
这条命令会让 <GID> 说出一条信息。 <GID> 的显示名称不会附加在信息前面。
标识： 指定目标
   bc_area - Message is sent to players in the vicinity of the source (default).   信息会发送给信息源附近的玩家（默认）。
   bc_self - Message is sent only to player attached.    信息只发送给所关联的玩家。

---------------------------------------

*unitskilluseid <GID>,<skill id>,<skill lvl>{,<target id>,<casttime>};
*unitskilluseid <GID>,"<skill name>",<skill lvl>{,<target id>,<casttime>};
*unitskillusepos <GID>,<skill id>,<skill lvl>,<x>,<y>{,<casttime>};
*unitskillusepos <GID>,"<skill name>",<skill lvl>,<x>,<y>{,<casttime>};
*unitskilluseid <GID>,<技能编号>,<技能等级>{,<目标编号>,<咏唱时间>};
*unitskilluseid <GID>,"<技能名称>",<技能等级>{,<目标编号>,<咏唱时间>};
*unitskillusepos <GID>,<技能编号>,<技能等级>,<坐标x>,<坐标y>{,<咏唱时间>};
*unitskillusepos <GID>,"<技能名称>",<技能等级>,<坐标x>,<坐标y>{,<咏唱时间>};

This is the replacement of the older commands, these use the same values for
GID as the other unit* commands (See 'GID').
这是旧版命令的替代命令，与其他单位*命令使用相同的 GID 值（参见 "GID"）。

Skill ID is the ID of the skill, skill level is the level of the skill.
Cast time is the amount of seconds to add or remove from the skill. Use a positive value to
add and negative value to subtract. Using 0 or no value will use the default skill cast time.
For the position, the x and y are given in the UnitSkillUsePos.
技能 ID 是技能的 ID，技能等级是技能的等级。咏唱时间是指施放或移除技能的秒数。
用正值做加法，用负值做减法。使用 0 或空值将使用默认的技能施放时间。
至于位置，x 和 y 在 UnitSkillUsePos 中给出。

---------------------------------------

*unitexists <GID>;

Checks if the given Game ID exists. Returns false if the object doesn't exist, or true if
it does.
检查给定的游戏 ID 是否存在。如果对象不存在，则返回 false；如果存在，则返回 true。

---------------------------------------

*getunittype <GID>;

Returns the type of object from the given Game ID. Returns -1 if the given GID does not
exist.
根据给定的游戏 ID 返回对象类型。如果给定的 GID 不存在，则返回-1。

Return values:
返回值：
	BL_PC   - Character object    角色对象
	BL_MOB  - Monster object      魔物对象
	BL_PET  - Pet object          宠物对象
	BL_HOM  - Homunculus object   人工生命体对象
	BL_MER  - Mercenary object    佣兵对象
	BL_NPC  - NPC object          NPC对象
	BL_ELEM - Elemental object    元素对象

---------------------------------------

*getunitname <GID>;

Gets the name of the given unit. Supported types are monster, homunculus, pet, and NPC.
Mercenary and Elemental don't support custom names.
获取给定单位的名称。支持的类型有魔物、人工生命体、宠物和 NPC。
佣兵和元素不支持自定义名称。

Returns "Unknown" if unit is not found.
如果找不到单位，则返回 "Unknown"。


---------------------------------------

*setunitname <GID>,"<new name>";
*setunitname <GID>,"<新名称>";

Changes the name of the given unit to the new name given. Supported types are monster,
homunculus, and pet. To change an NPC's name, see 'setnpcdisplay'. Mercenary and
Elemental don't support custom names.
将给定单位的名称更改为给定的新名称。支持的类型有魔物、人工生命体、宠物和 NPC。
要更改 NPC 的名称，请参阅 "setnpcdisplay"。佣兵和元素不支持自定义名称。

Changing a homunculus or pet name will be permanent.
更改人工生命体或宠物名称将是永久性的。

Returns "Unknown" if unit is not found.
如果找不到单位，则返回 "Unknown"。

---------------------------------------

*setunittitle <GID>,<title>;
*setunittitle <GID>,<称号>;

Apply a <title> to the given <GID>.
将 <称号> 应用于给定的 <GID>。

Note: This only works on non-player types. It also will only work on mobs if battle_config.show_mob_info is not enabled.
注意：这只适用于非玩家类型。此外，只有在未启用 battle_config.show_mob_info 的情况下，它才会对魔物有效。

---------------------------------------

*getunittitle <GID>;

Returns the title of the given <GID>.
返回给定 <GID> 的称号。

---------------------------------------

*getunitdata <GID>,<arrayname>;
*setunitdata <GID>,<parameter>,<new value>;
*getunitdata <GID>,<数组名称>;
*setunitdata <GID>,<参数>,<新值>;

This is used to get and set special data related to the unit.
With getunitdata, the array given will be filled with the current data. In setunitdata
the indexes in the array would be used to set that data on the unit.
用于获取和设置与单位相关的特殊数据。使用 getunitdata 时，给出的数组将填入当前数据。
在 setunitdata 中，数组中的索引将用于在单位上设置该数据。

Both getunitdata and setunitdata will return -1 if the given GID does not exist.
如果给定的 GID 不存在，getunitdata 和 setunitdata 都将返回-1。

Note: When adjusting a unit's stat (STR, AGI, etc) the unit's respective statuses are
      recalculated (HIT, FLEE, etc) automatically. Keep in mind that some stats don't
	  affect a unit's status and will have to directly be modified.
注意：调整单位属性（STR、AGI 等）时，单位的相应状态会自动重新计算（HIT、FLEE 等）。
	  请记住，有些属性不会影响单位的状态，必须直接修改。

Parameters (indexes) for monsters are:
怪物的参数（索引）为：
	UMOB_SIZE
	UMOB_LEVEL
	UMOB_HP
	UMOB_MAXHP
	UMOB_MASTERAID
	UMOB_MAPID
	UMOB_X
	UMOB_Y
	UMOB_SPEED
	UMOB_MODE
	UMOB_AI
	UMOB_SCOPTION
	UMOB_SEX
	UMOB_CLASS
	UMOB_HAIRSTYLE
	UMOB_HAIRCOLOR
	UMOB_HEADBOTTOM
	UMOB_HEADMIDDLE
	UMOB_HEADTOP
	UMOB_CLOTHCOLOR
	UMOB_SHIELD
	UMOB_WEAPON
	UMOB_LOOKDIR
	UMOB_CANMOVETICK
	UMOB_STR
	UMOB_AGI
	UMOB_VIT
	UMOB_INT
	UMOB_DEX
	UMOB_LUK
	UMOB_SLAVECPYMSTRMD
	UMOB_DMGIMMUNE
	UMOB_ATKRANGE
	UMOB_ATKMIN
	UMOB_ATKMAX
	UMOB_MATKMIN
	UMOB_MATKMAX
	UMOB_DEF
	UMOB_MDEF
	UMOB_HIT
	UMOB_FLEE
	UMOB_PDODGE
	UMOB_CRIT
	UMOB_RACE
	UMOB_ELETYPE
	UMOB_ELELEVEL
	UMOB_AMOTION
	UMOB_ADELAY
	UMOB_DMOTION
	UMOB_TARGETID
	UMOB_ROBE
	UMOB_BODY2
	UMOB_GROUP_ID
	UMOB_IGNORE_CELL_STACK_LIMIT
	UMOB_RES
	UMOB_MRES
	UMOB_DAMAGETAKEN

-----

Parameter (indexes) for homunculi are:
人工生命体的参数（索引）为：
	UHOM_SIZE
	UHOM_LEVEL
	UHOM_HP
	UHOM_MAXHP
	UHOM_SP
	UHOM_MAXSP
	UHOM_MASTERCID
	UHOM_MAPID
	UHOM_X
	UHOM_Y
	UHOM_HUNGER
	UHOM_INTIMACY
	UHOM_SPEED
	UHOM_LOOKDIR
	UHOM_CANMOVETICK
	UHOM_STR
	UHOM_AGI
	UHOM_VIT
	UHOM_INT
	UHOM_DEX
	UHOM_LUK
	UHOM_DMGIMMUNE
	UHOM_ATKRANGE
	UHOM_ATKMIN
	UHOM_ATKMAX
	UHOM_MATKMIN
	UHOM_MATKMAX
	UHOM_DEF
	UHOM_MDEF
	UHOM_HIT
	UHOM_FLEE
	UHOM_PDODGE
	UHOM_CRIT
	UHOM_RACE
	UHOM_ELETYPE
	UHOM_ELELEVEL
	UHOM_AMOTION
	UHOM_ADELAY
	UHOM_DMOTION
	UHOM_TARGETID
	UHOM_GROUP_ID

-----

Parameter (indexes) for pets are:
宠物的参数（索引）为：
	UPET_SIZE
	UPET_LEVEL
	UPET_HP
	UPET_MAXHP
	UPET_MASTERAID
	UPET_MAPID
	UPET_X
	UPET_Y
	UPET_HUNGER
	UPET_INTIMACY
	UPET_SPEED
	UPET_LOOKDIR
	UPET_CANMOVETICK
	UPET_STR
	UPET_AGI
	UPET_VIT
	UPET_INT
	UPET_DEX
	UPET_LUK
	UPET_DMGIMMUNE
	UPET_ATKRANGE
	UPET_ATKMIN
	UPET_ATKMAX
	UPET_MATKMIN
	UPET_MATKMAX
	UPET_DEF
	UPET_MDEF
	UPET_HIT
	UPET_FLEE
	UPET_PDODGE
	UPET_CRIT
	UPET_RACE
	UPET_ELETYPE
	UPET_ELELEVEL
	UPET_AMOTION
	UPET_ADELAY
	UPET_DMOTION
	UPET_GROUP_ID

-----

Parameter (indexes) for mercenaries are:
佣兵的参数（索引）为：
	UMER_SIZE
	UMER_HP
	UMER_MAXHP
	UMER_MASTERCID
	UMER_MAPID
	UMER_X
	UMER_Y
	UMER_KILLCOUNT
	UMER_LIFETIME
	UMER_SPEED
	UMER_LOOKDIR
	UMER_CANMOVETICK
	UMER_STR
	UMER_AGI
	UMER_VIT
	UMER_INT
	UMER_DEX
	UMER_LUK
	UMER_DMGIMMUNE
	UMER_ATKRANGE
	UMER_ATKMIN
	UMER_ATKMAX
	UMER_MATKMIN
	UMER_MATKMAX
	UMER_DEF
	UMER_MDEF
	UMER_HIT
	UMER_FLEE
	UMER_PDODGE
	UMER_CRIT
	UMER_RACE
	UMER_ELETYPE
	UMER_ELELEVEL
	UMER_AMOTION
	UMER_ADELAY
	UMER_DMOTION
	UMER_TARGETID
	UMER_GROUP_ID

-----

Parameter (indexes) for elementals are:
元素的参数（索引）为：
	UELE_SIZE
	UELE_HP
	UELE_MAXHP
	UELE_SP
	UELE_MAXSP
	UELE_MASTERCID
	UELE_MAPID
	UELE_X
	UELE_Y
	UELE_LIFETIME
	UELE_MODE
	UELE_SPEED
	UELE_LOOKDIR
	UELE_CANMOVETICK
	UELE_STR
	UELE_AGI
	UELE_VIT
	UELE_INT
	UELE_DEX
	UELE_LUK
	UELE_DMGIMMUNE
	UELE_ATKRANGE
	UELE_ATKMIN
	UELE_ATKMAX
	UELE_MATKMIN
	UELE_MATKMAX
	UELE_DEF
	UELE_MDEF
	UELE_HIT
	UELE_FLEE
	UELE_PDODGE
	UELE_CRIT
	UELE_RACE
	UELE_ELETYPE
	UELE_ELELEVEL
	UELE_AMOTION
	UELE_ADELAY
	UELE_DMOTION
	UELE_TARGETID
	UELE_GROUP_ID

-----

Parameter (indexes) for NPCs are:
NPC的参数（索引）为：
	UNPC_LEVEL
	UNPC_HP
	UNPC_MAXHP
	UNPC_MAPID
	UNPC_X
	UNPC_Y
	UNPC_LOOKDIR
	UNPC_STR
	UNPC_AGI
	UNPC_VIT
	UNPC_INT
	UNPC_DEX
	UNPC_LUK
	UNPC_PLUSALLSTAT
	UNPC_DMGIMMUNE
	UNPC_ATKRANGE
	UNPC_ATKMIN
	UNPC_ATKMAX
	UNPC_MATKMIN
	UNPC_MATKMAX
	UNPC_DEF
	UNPC_MDEF
	UNPC_HIT
	UNPC_FLEE
	UNPC_PDODGE
	UNPC_CRIT
	UNPC_RACE
	UNPC_ELETYPE
	UNPC_ELELEVEL
	UNPC_AMOTION
	UNPC_ADELAY
	UNPC_DMOTION
	UNPC_SEX
	UNPC_CLASS
	UNPC_HAIRSTYLE
	UNPC_HAIRCOLOR
	UNPC_HEADBOTTOM
	UNPC_HEADMIDDLE
	UNPC_HEADTOP
	UNPC_CLOTHCOLOR
	UNPC_SHIELD
	UNPC_WEAPON
	UNPC_ROBE
	UNPC_BODY2
	UNPC_DEADSIT
	UNPC_GROUP_ID

*Notes:
*注意：
		- *_SIZE: small (0); medium (1); large (2)    体型：小 (0); 中 (1); 大 (2)
	    - *_MAPID: this refers to the map_data index (from src/map/map.cpp), not the mapindex_db index (from src/common/mapindex.cpp)  地图编号：这里指的是 map_data 索引（来自 src/map/map.cpp），而不是 mapindex_db 索引（来自 src/common/mapindex.cpp）。
			-- For 'setunitdata', map name can also be passed in as a valid value instead of map ID     对于 "setunitdata"，地图名称也可以作为有效值传入，而不是地图编号
		- *_SPEED: 20 - 1000    速度：20 - 1000
		- *_MODE: see doc/mob_db_mode_list.txt   行动模式：参考doc/mob_db_mode_list.txt
		- *_LOOKDIR: north (0), northwest (1), west (2), etc    外观值朝向：北 (0), 西北 (1), 西 (2), 等等
		- *_CANMOVETICK: seconds * 1000 the unit will be unable to move   能否移动：秒 * 1000 单位将无法移动
		- *_DMGIMMUNE: unit will be immune to damage (1), or will receive damage (0)   免疫伤害：单位将免疫伤害 (1)，或受到伤害 (0)
		- *_HUNGER: 0 - 100    饥饿度：0 - 100
		- *_INTIMACY: 0 - 1000     互动： 0 - 1000 (译注：不知道这项是什么，有人知道请告诉我一下)
		- *_LIFETIME: seconds * 1000 the unit will be 'alive' for     存活时间：秒 * 1000，单位的 "存活 "时间
		- *_AMOTION: see doc/mob_db.txt    攻击动作：参考see doc/mob_db.txt
		- *_ADELAY: see doc/mob_db.txt     攻击延迟：参考see doc/mob_db.txt
		- *_DMOTION: see doc/mob_db.txt    受伤动作：参考see doc/mob_db.txt
		- *_BODY2: enable (1) the alternate display, or disable (0)   身体外观2：启用 (1)备用显示，或禁用 (0)
		- *_TARGETID: when set to 0 the unit will release the target and stop attacking    目标编号：设置为 0 时，单位将重置目标并停止攻击

		- UMOB_AI: none (0); attack (1); marine sphere (2); flora (3); zanzou (4); legion (5); faw (6)  魔物AI：无 (0)；攻击 (1)；marine sphere (2)；植物 (3)；影狼/胧 (4)；协助同类 (5)；机匠 (6)
		- UMOB_SCOPTION: see the 'Variables' section at the top of this document     UMOB_SCOPTION：请参阅本文件顶部的 "变量"部分
		- UMOB_SLAVECPYMSTRMD: make the slave copy the master's mode (1), or not (0)    随从魔物复制主人的行动模式：使随从单位复制主人的行动模式 (1)，或不复制 (0)

		- UNPC_PLUSALLSTAT: same as 'bAllStats'; increases/decreases all stats by given amount    与 "bAllStats "相同；按给定数量增加/减少所有素质点数
		- UNPC_DEADSIT: stand (0), dead (1), sit (2)        站立 (0), 死亡 (1), 坐下 (2)

Example:
例子：
30
	// Spawn some Porings and save the Game ID.       生成一些波利并保存游戏 ID。
	// - Keep in mind, when the 'monster' script command is used,    请记住，在使用 "monster "脚本命令时，
	// - all the spawned monster GID's are stored in an array        所有生成的怪物 GID 都存储在一个名为 $@mobid[] 的数组中。
	// - called $@mobid[].
	monster "prontera",149,190,"Poring",1002,10;
	.GID = $@mobid[9]; // Store and modify the 10th Poring spawned to make him stronger!

	// Save the strong Poring's mob data in the .@por_arr[] variable. (.@por_arr[1] being level, .@por_arr[13] being class, etc.)    将强大波利的魔物数据保存在 .@por_arr[] 变量中。(.@por_arr[1]是等级，.@por_arr[13]是类型，等等）。
	// With this data we can have the NPC display or manipulate it how we want. This does not have to be ran before 'setunitdata'.   有了这些数据，我们就可以让 NPC 以我们想要的方式显示或操作这些数据。此操作不必在 "setunitdata "之前运行。
	getunitdata .GID,.@por_arr;

	// Set the max HP of the Poring to 1000 (current HP will also get updated to 1000).      将波利的最大 HP 设置为 1000（当前 HP 也将更新为 1000）。
	setunitdata .GID,UMOB_MAXHP,1000;

---------------------------------------

*geteleminfo <type>{,<char_id>};
*geteleminfo <类型>{,<角色编号>};

Get info of elemental of attached player or player by char_id.
Other info can be obtained by 'getunitdata' command.
通过角色编号获取关联玩家或玩家的元素信息。
其他信息可通过 "getunitdata "命令获取。

Valid types are:
有效类型为：
   0: Elemental ID        元素的编号
   1: Elemental Game ID      元素的游戏编号

---------------------------------------
\\
6,1.- End of unit-related commands      单位相关命令结束
\\
---------------------------------------

*npcskill <skill id>,<skill lvl>,<stat point>,<NPC level>;
*npcskill "<skill name>",<skill lvl>,<stat point>,<NPC level>;
*npcskill <技能编号>,<技能等级>,<素质点数>,<NPC等级>;
*npcskill "<技能名称>",<技能等级>,<素质点数>,<NPC等级>;

This command causes the attached NPC object to cast a skill on the attached
player. The skill will have no cast time or cooldown. The player must be
within the default skill range or the command will fail silently.
该命令会使关联的NPC对关联的玩家施放一个技能。该技能没有施法时间或冷却时间。
玩家必须在默认的技能范围内，否则命令将无声失败。


The "stat point" parameter temporarily sets all NPC stats to the given value,
and "NPC level" is the temporary level of the NPC (used in some skills).
Neither value can be greater than the max level defined in config, and will
not work properly if the NPC has a mob sprite.
"素质点"参数会将所有 NPC 素质暂时设置为给定值，而 "NPC 等级 "则是 NPC 的临时等级（在某些技能中使用）。
这两个值都不能大于配置中定义的最大级别，如果 NPC 有一个魔物外观，该值将无法正常工作。

Before using skills, NPCs must have basic stats applied to them depending on the
skill being used: UNPC_ATKMIN, UNPC_ATKMAX, UNPC_MATKMIN, UNPC_MATKMAX, UNPC_STR,
UNPC_AGI, UNPC_VIT, UNPC_INT, UNPC_DEX, UNPC_LUK.
See 'setunitdata' for more information on usage.
在使用技能之前，必须根据所使用的技能为 NPC 设置基本素质点： 
unpc_atkmin、unpc_atkmax、unpc_matkmin、unpc_matkmax、unpc_str、unpc_agi、unpc_vit、unpc_int、unpc_dex、unpc_luk。
有关使用的更多信息，请参阅 "setunitdata"。

    // Casts Level 10 Heal on the attached player, calculated with
    // all stats 99 and base level 60.    在所有素质点都为 99 和基础等级为 60 的情况下，为关联玩家施放 10 级治愈术。
    npcskill "AL_HEAL",10,99,60;

---------------------------------------

*day;
*night;

These two commands will switch the entire server between day and night mode
respectively. If your server is set to cycle between day and night by
configuration, it will eventually return to that cycle.
这两条命令将分别在整个服务器切换白天和黑夜模式。

Example:
例子：

-	script	DayNight	-1,{
OnClock0600:
	day;
	end;
OnInit:
	// setting correct mode upon server start-up   在服务器启动时设置正确的模式
	if (gettime(DT_HOUR)>=6 && gettime(DT_HOUR)<18) end;
OnClock1800:
	night;
	end;
}

This script allows to emulate the day/night cycle as the server does, but also
allows triggering additional effects upon change, like announces, gifts, etc.
The day/night cycle set by configuration should be disabled when this script is used.
该脚本可以模拟服务器的昼夜循环，还可以在发生变化时触发额外的效果，如公告、礼物等。
使用该脚本时，配置文件里设置的昼夜循环应被禁用。

---------------------------------------

*defpattern <set number>,"<regular expression pattern>","<event label>";
*activatepset <set number>;
*deactivatepset <set number>;
*deletepset <set number>;
*defpattern <集合编号>,"<正则表达式>","<事件标签>";
*activatepset <集合编号>;
*deactivatepset <集合编号>;
*deletepset <集合编号>;

This set of commands is only available if the server is compiled with regular
expressions library enabled. Default compilation and most binary distributions
aren't, which is probably bad, since these, while complex to use, are quite
fascinating.
只有在编译服务器时启用了正则表达式库，才能使用这组命令。
默认编译和大多数二进制发行版都不是这样，这可能是不好的，因为这些软件虽然使用复杂，但却相当吸引人。

They will make the NPC object listen for text spoken publicly by players and
match it against regular expression patterns, then trigger labels associated
with these regular expression patterns.
它们将使 NPC 对象监听玩家公开发表的文字信息，
并将其与正则表达式模式进行匹配，然后触发与这些正则表达式模式相关的标签。

Patterns are organized into sets, which are referred to by a set number. You can
have multiple sets patterns, and multiple patterns may be active at once.
Numbers for pattern sets start at 1.
模式被组织成集合，用集合编号来表示。您可以拥有多个模式集合，并且多个范例可以同时激活。
模式组的数字从 1 开始。

'defpattern' will associate a given regular expression pattern with an event
label. This event will be triggered whenever something a player says is matched
by this regular expression pattern, if the pattern is currently active.
"defpattern"会将给定的正则表达式模式与事件标签关联起来。
如果该正则表达式模式当前处于活动状态，只要玩家所说的话与该正则表达式模式匹配，就会触发该事件。

'activatepset' will make the pattern set specified active. An active pattern
will enable triggering labels defined with 'defpattern', which will not happen
by default.
'deactivatepset' will deactivate a specified pattern set. Giving -1 as a pattern
set number in this case will deactivate all pattern sets defined.
"activatepset"将激活指定的模式集。 激活的模式可以触发用 "defpattern "定义的标签，但默认情况下不会触发。
"deactivatepset"将停用指定的模式集。在这种情况下，如果模式集编号为-1，则将停用所有已定义的模式集。


'deletepset' will delete a pattern set from memory, so you can create a new
pattern set in its place.
"deletepset"将从内存中删除一个模式集，这样您就可以在它的位置上创建一个新的模式集。

Using regular expressions is high wizardry. But with this high wizardry comes
unparalleled power of text manipulation. For an explanation of what a regular
expression pattern is, see a few web pages:
使用正则表达式是一种高级魔法。但是，有了这种高超的魔法，文字处理能力也无与伦比。
有关正则表达式的解释，请参阅一些网页：

http://www.regular-expressions.info/
http://www.weitz.de/regex-coach/

For an example of this in use, see doc/sample/npc_test_pcre.txt
有关使用示例，请参见 doc/sample/npc_test_pcre.txt

With this you could, for example, automatically punish players for asking for
Zeny in public places, or alternatively, automatically give them Zeny instead if
they want it so much.
例如，如果玩家在公共场合索要 Zeny，您可以自动对其进行惩罚；或者，如果玩家非常想要 Zeny，您也可以自动给他们 Zeny。

---------------------------------------

*pow(<number>,<power>)

Returns the result of the calculation.
返回计算结果(乘方计算)。

Example:
例子：
	.@i = pow(2,3); // .@i will be 8   .@i等于8

---------------------------------------

*sqrt(<number>)

Returns the square-root of a number.
返回一个数字的平方根。

Example:
例子：
	.@i = sqrt(25); // .@i will be 5   .@i等于5

---------------------------------------

*distance(<x0>,<y0>,<x1>,<y1>)

Returns distance between 2 points.
返回两点之间的距离。

Example:
	.@i = distance(100,200,101,202);

---------------------------------------

*min(<number or array>{,<number or array>,...})
*minimum(<number or array>{,<number or array>,...})
*max(<number or array>{,<number or array>,...})
*maximum(<number or array>{,<number or array>,...})
*min(<数字或数组>{,<数字或数组>,...})
*minimum(<数字或数组>{,<数字或数组>,...})
*max(<数字或数组>{,<数字或数组>,...})
*maximum(<数字或数组>{,<数字或数组>,...})

Returns the smallest (or biggest) from the set of given parameters.
These parameters have to be either numbers or number arrays.
返回给定参数集合中最小（或最大）的参数。这些参数必须是数字或数字数组。

Example:
例子：
	.@minimum = min( 1, -6, -2, 8, 2 ); // .@minimum will be equal to -6    .@minimum将等于 -6
	.@maximum = max( 0, 5, 10, 4 ); // .@maximum will be equal to 10   .@maximum将等于 10
	.@level = min( BaseLevel, 70 ); // .@level will be the character's base level, capped to 70    .@level 将是角色的基础等级，取值上限为70

	setarray .@testarray, 4, 5, 12, 6, 7, 3, 8, 9, 10;

	.@minimum = min( .@testarray ); // .@minimum will be equal to 3    .@minimum将等于 3
	.@maximum = max( .@testarray ); // .@maximum will be equal to 12   .@maximum将等于 12

	.@minimum = min( -6, 1, 2, 3, .@testarray ); // .@minimum will be equal to -6    .@minimum将等于 -6
	.@maximum = max( -6, 1, 2, 3, .@testarray ); // .@maximum will be equal to 12    .@maximum将等于 12

---------------------------------------

*cap_value(<number>, <min>, <max>)
*cap_value(<数字>, <最小值>, <最大值>)

Returns the number but capped between <min> and <max>.
返回数字，但上限在 <最小值> 和 <最大值> 之间。

Example:
例子：
	// capped between 0 ~ 100   取0 ~ 100之间的数
	.@value = cap_value(10, 0, 100);   // .@value will be equal to 10
	.@value = cap_value(1000, 0, 100); // .@value will be equal to 100
	.@value = cap_value(-10, 3, 100);  // .@value will be equal to 3

---------------------------------------


*round(<number>,<precision>);
*ceil(<number>,<precision>);
*floor(<number>,<precision>);
*round(<数字>,<精度>);
*ceil(<数字>,<精度>);
*floor(<数字>,<精度>);

Returns <number> rounded to multiple of <precision>.
返回四舍五入为 <精度> 倍数的 <数字>。

`round` function will round the <number> up if its division with <precision> yield a remainder
with a value equals to or more than half of <precision>. Otherwise, it rounds the <number> down.
`ceil` always round the <number> up.
`floor` always round the <number> down.
如果 <数字> 除以 <精度> 得到的余数等于或超过 <精度> 的一半，则 `round`函数将把 <数字>向上舍入。
否则，<数字>会向下舍入。`ceil` 总是向上舍入 <数字>。`floor` 总是将 <数字> 向下舍入。

---------------------------------------

*md5("<string>")
*md5("<字符串>")

Returns the md5 checksum of a number or string.
返回数字或字符串的 md5 校验值。

Example:
例子：
	mes md5(12345);
	mes md5("12345"); 	// Will both display 827ccb0eea8a706c4c34a16891f84e7b   将都会显示827ccb0eea8a706c4c34a16891f84e7b
	mes md5("qwerty"); 	// Will display d8578edf8458ce06fbc5bb76a58c5ca4        将会显示d8578edf8458ce06fbc5bb76a58c5ca4

---------------------------------------

*query_sql("your MySQL query"{, <array variable>{, <array variable>{, ...}}});
*query_logsql("your MySQL query"{, <array variable>{, <array variable>{, ...}}});
*query_sql_async("your MySQL query"{, <array variable>{, <array variable>{, ...}}});
*query_logsql_async("your MySQL query"{, <array variable>{, <array variable>{, ...}}});
*query_sql("您的 MySQL 查询"{, <数组变量>{, <数组变量>{, ...}}});
*query_logsql("您的 MySQL 查询"{, <数组变量>{, <数组变量>{, ...}}});
*query_sql_async("您的 MySQL 查询"{, <数组变量>{, <数组变量>{, ...}}});
*query_logsql_async("您的 MySQL 查询"{, <数组变量>{, <数组变量>{, ...}}});

Executes an SQL query. A 'select' query can fill array variables with up to 2 billion rows of
values, and will return the number of rows (i.e. array size) or -1 on failure.
执行 SQL 查询。'select'查询可为数组变量填充多达 20 亿行的值，失败时将返回行数（即数组大小）或-1。

Note that 'query_sql' runs on the main database while 'query_logsql' runs on the log database.
请注意，"query_sql "在主数据库中运行，而 "query_logsql "在日志数据库中运行。

The *_async commands will execute asynchronously, which means that db query time won't block
the script-thread (and mostly importantly, the whole map-server.) When calling with query string 
only, it won't make the script-thread sleep or block. When calling with array variables folloing 
the query string, it'll make script-thread sleep and awken it with fetched data when the query 
execution finished.
*_async 命令将异步执行，这意味着数据库查询时间不会阻塞脚本线程
（更重要的是，不会阻塞整个地图服务器）。当使用查询字符串后面的数组变量调用时，
脚本线程会休眠，并在查询执行完毕后用获取的数据唤醒脚本线程。

Example:
例子：
	.@nb = query_sql("select name,fame from `char` ORDER BY fame DESC LIMIT 5", .@name$, .@fame);
	mes "Hall Of Fame: TOP5";
	mes "1." + .@name$[0] + "(" + .@fame[0] + ")"; // largest fame value.   最大的名声值。
	mes "2." + .@name$[1] + "(" + .@fame[1] + ")";
	mes "3." + .@name$[2] + "(" + .@fame[2] + ")";
	mes "4." + .@name$[3] + "(" + .@fame[3] + ")";
	mes "5." + .@name$[4] + "(" + .@fame[4] + ")";

---------------------------------------

*escape_sql(<value>)

Converts the value to a string and escapes special characters so that it is safe to
use in query_sql(). Returns the escaped form of the given value.
将数值转换为字符串，并转义特殊字符，以便在 query_sql() 中安全使用。返回给定值的转义形式。

Example:
例子：
	.@name$ = "John's Laptop";
	.@esc_str$ = escape_sql(.@name$); // Escaped string: John\'s Laptop   转义的字符串：John\'s Laptop

---------------------------------------

*setiteminfo(<item id>,<type>,<value>)
*setiteminfo(<aegis item name>,<type>,<value>)
*setiteminfo(<物品编号>,<类型>,<值>)
*setiteminfo(<aegis物品名称>,<类型>,<值>)

This function will set some value of an item.
Returns the new value on success, or -1 on fail (item_id not found or invalid type).
此函数将设置物品的某些值。成功时返回新值，失败时返回-1（未找到物品编号或类型无效）。

Valid types are:
有效类型为：
	ITEMINFO_BUY             (0)   -  Buy Price      买价
	ITEMINFO_SELL            (1)   -  Sell Price     卖价
	ITEMINFO_TYPE            (2)   -  Type           类别
	ITEMINFO_MAXCHANCE       (3)   -  maxchance (max drop chance of this item, e.g. 1 = 0.01%)   maxchance（该物品的最大掉落几率，例如 1 = 0.01）
		                        if = 0, then monsters don't drop it at all (rare or a quest item)    如果 = 0，则怪物根本不会掉落（稀有物品或任务物品）
		                        if = 10000, then this item is sold in NPC shops only    如果 = 10000，则该物品只在 NPC 商店出售
	ITEMINFO_GENDER          (4)   -  Gender      性别限制
	ITEMINFO_LOCATIONS       (5)   -  Location(s) 装备位置
	ITEMINFO_WEIGHT          (6)   -  Weight      重量
	ITEMINFO_ATTACK          (7)   -  ATK         攻击力
	ITEMINFO_DEFENSE         (8)   -  DEF         防御力
	ITEMINFO_RANGE           (9)   -  Range       射程
	ITEMINFO_SLOT           (10)   -  Slot        孔数
	ITEMINFO_VIEW           (11)   -  View        外观值
	ITEMINFO_EQUIPLEVELMIN  (12)   -  equipment LV   可装备等级
	ITEMINFO_WEAPONLEVEL    (13)   -  weapon LV      武器等级
	ITEMINFO_ALIASNAME      (14)   -  AliasName      别名
	ITEMINFO_EQUIPLEVELMAX  (15)   -  equipment LV Max   最大装备等级
	ITEMINFO_MAGICATTACK    (16)   -  matk if RENEWAL is defined   魔法攻击力(复兴端)

Example:
	setiteminfo 7049,ITEMINFO_WEIGHT,9990; // Stone now weighs 999.0    石头重量将变为999.0

---------------------------------------

*setitemscript(<item id>,<"{ new item script }">{,<type>});
*setitemscript(<物品编号>,<"{ 新物品脚本 }">{,<类型>});

Set a new script bonus to the Item. Very useful for game events.
You can remove an item's itemscript by leaving the itemscript argument empty.
Returns 1 on success, or 0 on fail (item_id not found or new item script is invalid).
Type can optionally be used indicates which script to set (default is 0):
为物品设置新的作用脚本。对游戏事件非常有用。您可以将 itemcript(物品作用脚本) 参数留空，从而删除项目的 itemscript(物品作用脚本)。
成功时返回 1，失败时返回 0（未找到物品编号或新物品脚本无效）。
可以选择参数<类型>表示要设置的脚本（默认为 0）：
 0 - Script   作用脚本
 1 - OnEquip_Script   装备上时的作用脚本
 2 - OnUnequip_Script   卸除装备的作用脚本

Example:
例子：
	setitemscript 2637,"{ if (isequipped(2236) == 0)end; if (getskilllv(26)){skill 40,1;}else{skill 26,1+isequipped(2636);} }";
	setitemscript 2637,"";

---------------------------------------

*atoi("<string>")
*axtoi("<string>")
*strtol("<string>", base)
*atoi("<字符串>")
*axtoi("<字符串>")
*strtol("<字符串>", 进制数)

These commands are used to convert strings to numbers. 'atoi' will interpret
given string as a decimal number (base 10), while 'axtoi' interprets strings as
hexadecimal numbers (base 16). 'strtol' lets the user specify a base (valid range
is between 2 and 36 inclusive, or the special value0, which means auto-detection).
这些命令用于将字符串转换为数字。atoi "会将给定字符串释义为十进制数（进制数为 10），
而 "axtoi "则将字符串释义为十六进制数（进制数为 16）。
strtol "可让用户指定一个进制（有效范围为 2 至 36（含），或特殊值 0，表示自动检测）。

The 'atoi' and 'strtol' functions conform to the C functions with the same names,
and 'axtoi' is the same as strtol, with a base of 16. Results are clamped to signed
32 bit int range (INT_MIN ~ INT_MAX).
atoi "和 "strtol "函数与同名的 C 函数一致，"axtoi "与 strtol 相同，进制为 16。
结果分布在有符号的 32 位 int 范围内 (INT_MIN ~ INT_MAX)。

Examples:
例子：

	.@var = atoi("11");        // Sets .@var to 11       设置.@var为11
	.@var = axtoi("FF");       // Sets .@var to 255      设置.@var为255
	mes axtoi("11");           // Displays 17 (1 = 1, 10 = 16)     显示 17 (16进制，个位1=1，十位1=16)
	.@var = strtol("11", 10);  // Sets .@var to 11 (11 base 10)    设置.@var为11 (10进制11)
	.@var = strtol("11", 16);  // Sets .@var to 17 (11 base 16)    设置.@var为17 (16进制11)
	.@var = strtol("11", 0);   // Sets .@var to 11 (11 base 10, auto-detected)       设置.@var为11  (10进制11，自动检测)
	.@var = strtol("0x11", 0); // Sets .@var to 17 (11 base 16, auto-detected because of the "0x" prefix)   设置.@var为17  (16进制11，自动检测到前缀为0x)
	.@var = strtol("011", 0);  // Sets .@var to 9 (11 base 8, auto-detected because of the "0" prefix)      设置.@var为9  (8进制11，自动检测到前缀为0)
	.@var = strtol("11", 2);   // Sets .@var to 3 (binary 11)   设置.@var为3  (二进制11)

---------------------------------------

*compare("<string>","<substring>")
*compare("<字符串>","<子字符串>")

This command returns 1 or 0 when the substring is in the main string (1) or not (0).
This command is not case sensitive.
当子串在主字符串中（1）或不在主字符串中（0）时，该命令返回 1 或 0。
该命令不区分大小写。

Examples:
例子：
	//dothis; will be executed ('Bloody Murderer' contains 'Blood').
	//如此，将会执行('Bloody Murderer'包含'Blood')
	if (compare("Bloody Murderer","Blood"))
		dothis;

	//dothat; will not be executed ('Blood butterfly' does not contain 'Bloody').
	//如此，将不会执行 ('Blood butterfly' 未包含 'Bloody')
	if (compare("Blood Butterfly","Bloody"))
		dothat;

---------------------------------------

*strcmp("<string>","<string>")
*strcmp("<字符串>","<字符串>")

This command compares two strings are returns a value:
此命令比较两个字符串并返回一个值：
   1: string 1 > string 2             1: 字符串 1 > 字符串 2
   0: strings are equal               0: 字符串相等
  -1: string 1 < string 2            -1: 字符串 1 < 字符串 2

---------------------------------------

*getstrlen("<string>")
*getstrlen("<字符串>")

This function will return the length of the string given as an argument. It is
useful to check if anything input by the player exceeds name length limits and
other length limits and asking them to try to input something else.
此函数将返回作为参数给定的字符串的长度。
它可以检查玩家输入的内容是否超过了姓名长度限制和其他长度限制，
并要求他们尝试输入其他内容。

---------------------------------------

*charisalpha("<string>",<position>)
*charisalpha("<字符串>",<位置>)

This function will return 1 if the character number Position in the given string
is a letter, 0 if it isn't a letter but a digit or a space.
The first letter is position 0.
如果给定字符串中的字符编号位置是字母，该函数将返回 1；如果不是字母而是数字或空格，则返回 0。
第一个字母是位置 0。

---------------------------------------

*charat(<string>,<index>)
*charat(<字符串>,<索引>)

Returns char at specified index. If index is out of range, returns empty string.
The first letter of a string is index 0.
返回指定索引处的字符。如果索引超出范围，则返回空字符串。
字符串的第一个字母是索引 0。

Example:
例子：
	charat("This is a string", 10); //returns "s"   返回"s"

---------------------------------------

*setchar(<string>,<char>,<index>)
*setchar(<字符串>,<字符>,<索引>)

Returns the original string with the char at the specified index set to the
specified char. If index out of range, the original string will be returned.
Only the 1st char in the <char> parameter will be used.
将指定索引处的字符设置为指定字符后，返回原始字符串。
如果索引超出范围，将返回原始字符串。只使用 <字符> 参数中的第一个字符。

Example:
例子：
	setchar("Cat", "B", 0); //returns "Bat"   返回"Bat"

---------------------------------------

*insertchar(<string>,<char>,<index>)
*insertchar(<字符串>,<字符>,<索引>)

Returns the original string with the specified char inserted at the specified
index. If index is out of range, the char will be inserted on the end of the
string that it is closest. Only the 1st char in the <char> parameter will be used.
返回在指定索引处插入指定字符的原始字符串。如果索引超出范围，字符将被插入最靠近的字符串末尾。
只使用 <字符> 参数中的第一个字符。

Example:
例子：
	insertchar("laughter", "s", 0); //returns "slaughter"    返回"slaughter"

---------------------------------------

*delchar(<string>,<index>)
*delchar(<字符串>,<索引>)

Returns the original string with the char at the specified index removed.
If index is out of range, original string will be returned.
返回删除指定索引处字符后的原始字符串。如果索引超出范围，将返回原始字符串。

Example:
例子：
	delchar("Diet", 3); //returns "Die"  返回"Die"

---------------------------------------

*strtoupper(<string>)
*strtolower(<string>)
*strtoupper(<字符串>)
*strtolower(<字符串>)

Returns the specified string in its uppercase/lowercase form.
All non-alpha characters will be preserved.
以大写/小写形式返回指定的字符串。
所有非字母字符都将保留。

Example:
例子：
	strtoupper("The duck is blue!!"); //returns "THE DUCK IS BLUE!!"  返回"THE DUCK IS BLUE!!"

---------------------------------------

*charisupper(<string>,<index>)
*charislower(<string>,<index>)
*charisupper(<字符串>,<索引>)
*charislower(<字符串>,<索引>)

Returns 1 if character at specified index of specified string is
uppercase/lowercase. Otherwise, 0. Characters not of the alphabet will return 0.
如果指定字符串中指定索引处的字符为大写/小写，则返回 1。否则返回0。
不属于字母表的字符将返回 0。

Example:
例子：
	charisupper("rAthena", 1); //returns 1    返回1

---------------------------------------

*substr(<string>,<start_index>,<end_index>)
*substr(<字符串>,<起始索引>,<终末索引>)

Returns the sub-string of the specified string inclusively between the set
indexes. If indexes are out of range, or the start index is after the end
index, an empty string will be returned.
返回指定字符串在全套索引之间的子字符串。
如果索引超出范围，或者开始索引在结束索引之后，则将返回空字符串。

Example:
	substr("foobar", 3, 5); //returns "bar"    返回"bar"

---------------------------------------

*explode(<dest_array>,<string>,<delimiter>)
*explode(<指定数组>,<字符串>,<分隔符>)

Breaks a string up into substrings based on the specified delimiter. Substrings
will be stored within the specified string array. Only the 1st char of the
delimiter parameter will be used. If an empty string is passed as a delimiter,
the string will be placed in the array in its original form.
根据指定的分隔符将字符串拆分成子串。子串将存储在指定的字符串数组中。
只使用分隔符参数的第一个字符。如果传递空字符串作为分隔符，字符串将以其原始形式放入数组中。

Example:
例子：
	explode(.@my_array$, "Explode:Test:1965:red:PIE", ":");
	//.@my_array$ contents will be...     .@my_array$数组将被填充为：
	//.@my_array$[0]: "Explode"
	//.@my_array$[1]: "Test"
	//.@my_array$[2]: "1965"
	//.@my_array$[3]: "red"
	//.@my_array$[4]: "PIE"
---------------------------------------

*implode(<string_array>{,<glue>})
*implode(<字符串数组>{,<合并>})


Combines all substrings within the specified string array into a single string.
If the glue parameter is specified, it will be inserted inbetween each substring.
将指定字符串数组中的所有子字符串合并为一个字符串。
如果指定了合并参数，则会在每个子串之间插入合并内容。

Example:
	setarray .@my_array$[0], "This", "is", "a", "test";
	implode(.@my_array$, " "); //returns "This is a test"     返回"This is a test"

---------------------------------------

*sprintf(<format>[,param[,param[,...]]])
*sprintf(<格式>[,参数[,参数[,...]]])

C style sprintf. The resulting string is returned same as in PHP. All C format
specifiers are supported except %n. More info: sprintf @ www.cplusplus.com.
The number of params is only limited by rA's script engine.
类似C语言的sprintf。返回的字符串与 PHP 中的字符串相同。
除 %n 外，支持所有 C 格式指定符。更多信息：sprintf @ www.cplusplus.com。
参数的数量仅受 rA 脚本引擎的限制。

Example:
例子：
	.@format$ = "The %s contains %d monkeys";
	dispbottom(sprintf(.@format$, "zoo", 5));        //prints "The zoo contains 5 monkeys"  输出"The zoo contains 5 monkeys"
	dispbottom(sprintf(.@format$, "barrel", 82));    //prints "The barrel contains 82 monkeys"  输出"The barrel contains 82 monkeys"

---------------------------------------

*sscanf(<string>,<format>[,param[,param[,...]]])
*sscanf(<字符串>,<格式>[,参数[,参数[,...]]])

C style sscanf. All C format specifiers are supported.
More info: sscanf @ www.cplusplus.com. The number of params is only limited
by rA's script engine.
类似C语言的sscanf。支持所有 C 格式规范。更多信息：sscanf @ www.cplusplus.com。
参数的数量仅受 rA 脚本引擎的限制。


Example:
例子：
	sscanf("This is a test: 42 foobar", "This is a test: %d %s", .@num, .@str$);
	dispbottom(.@num + " " + .@str$); //prints "42 foobar"  输出"42 foobar"

---------------------------------------

*strpos(<haystack>,<needle>{,<offset>})

PHP style strpos. Finds a substring (needle) within a string (haystack).
The offset parameter indicates the index of the string to start searching.
Returns index of substring on successful search, else -1.
Comparison is case sensitive.
类似PHP的strpos。查找字符串（haystack）中的子串（needle）。
偏移参数表示要开始搜索的字符串的索引。搜索成功时返回子字符串的索引，否则返回 -1。
比较区分大小写。

Example:
例子：
	strpos("foobar", "bar", 0); //returns 3    返回3
	strpos("foobarfoo", "foo", 0); //returns 0 返回0
	strpos("foobarfoo", "foo", 1); //returns 6 返回6

---------------------------------------

*replacestr(<input>, <search>, <replace>{, <usecase>{, <count>}})
*replacestr(<输入值>, <查询值>, <替换值>{, <使用基数>{, <计数>}})

Replaces all instances of a search string in the input with the specified
replacement string. By default is case sensitive unless <usecase> is set
to 0. If specified it will only replace as many instances as specified
in the count parameter.
用指定的替换值字符串替换为输入值中的所有查询出的字符串。默认情况下区分大小写，
除非 <使用基数> 设置为 0。如果指定，则只会替换与计数参数中指定的数量相同的实例。

Example:
例子：
	replacestr("testing tester", "test", "dash"); //returns "dashing dasher"  返回"dashing dasher"
	replacestr("Donkey", "don", "mon", 0); //returns "monkey"   返回"monkey"
	replacestr("test test test test test", "test", "yay", 0, 3); //returns "yay yay yay test test"  返回"yay yay yay test test"

---------------------------------------

*countstr(<input>, <search>{, <usecase>})
*countstr(<输入值>, <搜索值>{, <用例>})

Counts all instances of a search string in the input. By default is case
sensitive unless <usecase> is set to 0.
计算输入值中搜索值字符串的所有实例。默认情况下区分大小写，除非 <用例> 设置为 0。

Example:
例子：
	countstr("test test test Test", "test"); //returns 3  返回3
	countstr("cake Cake", "Cake", 0); //returns 2         返回2

---------------------------------------

*preg_match(<regular expression pattern>,<string>{,<offset>})
*preg_match(<正则表达式>,<字符串>{,<偏移>})

Searches a string for a match to the regular expression provided. The
offset parameter indicates the index of the string to start searching.
Returns offsets to captured substrings, or 0 if no match is found.
搜索与提供的正则表达式匹配的字符串。偏移参数表示要开始搜索的字符串的索引。
返回搜索获得的子串的偏移量，如果没有找到匹配，则返回 0。

This command is only available if the server is compiled with the regular
expressions library enabled.
只有当服务器在编译时启用了正则表达式库，该命令才可用。

---------------------------------------

*setfont <font>;
*setfont <字体>;

This command sets the current RO client interface font to one of the
fonts stored in data\*.eot by using an ID of the font. When the ID
of the currently used font is used, default interface font is used
again.
该命令使用字体 ID 将当前 RO 客户端界面字体设置为 data\*.eot 中存储的字体之一。
当当前使用的字体 ID 被使用时，将重新使用默认界面字体。

	0 - Default
	1 - RixLoveangel
	2 - RixSquirrel
	3 - NHCgogo
	4 - RixDiary
	5 - RixMiniHeart
	6 - RixFreshman
	7 - RixKid
	8 - RixMagic
	9 - RixJJangu

---------------------------------------

*showdigit <value>{,<type>};
*showdigit <值>{,<类型>};

Displays given numeric 'value' in large digital clock font on top of
the screen. The optional parameter 'type' specifies visual aspects
of the "clock" and can be one of the following values:
在屏幕上方以大数字时钟字体显示给定的数字 "值"。
可选参数 "类型 "用于指定 "时钟"的视觉效果，可以是以下值之一：

	0 - Displays the value for 5 seconds (default).                  显示数值 5 秒（默认值）。
	1 - Incremental counter (1 tick/second).                         增量计数器（1 tick/秒）。
	2 - Decremental counter (1 tick/second). Does not stop at zero,  递减计数器（1 tick/秒）。
		but overflows.                                               不会归零，但会溢出。
	3 - Decremental counter (2 ticks/second). Two digits only, stops 递减计数器（2 次/秒）。只有两位数，止于零。
		at zero.

Except for type 3 the value is interpreted as seconds and formatted
as time in days, hours, minutes and seconds. Note, that the official
script command does not have the optional parameter.
除类型 3 外，该值被解释为秒，并以天、小时、分钟和秒为单位进行格式化。
请注意，正式脚本命令没有可选参数。

	// displays 23:59:59 for 5 seconds    显示5秒：23:59:59
	showdigit 86399;

	// counter that starts at 60 and runs for 30 seconds  计数器从 60 开始，持续 30 秒
	showdigit 60,3;

---------------------------------------

*setcell "<map name>",<x1>,<y1>,<x2>,<y2>,<type>,<flag>;
*setcell "<地图名称>",<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>,<类型>,<标志>;

Each map cell has several 'flags' that specify the properties of that cell.
These include terrain properties (walkability, shootability, presence of water),
skills (basilica, land protector, ...) and other (NPC nearby, no vending, ...).
Each of these can be 'on' or 'off'. Together they define a cell's behavior.
每个地图单元格都有几个 "标志"，用于指定该单元格的属性。
这些属性包括地形属性（可行走、可射击、有水）、技能（神圣殿堂、地领......）和其他（附近有 NPC、无法挂店......）。
每种属性都可以 "开启 "或 "关闭"。它们共同决定了单元格的属性。

This command lets you alter these flags for all map cells in the specified
(x1,y1)-(x2,y2) rectangle. The 'flag' can be 0 or 1 (0:clear flag, 1:set flag).
The 'type' defines which flag to modify. Possible options see 'src/map/script_constants.hpp'.
通过这条命令，您可以更改指定 (坐标x1,坐标y1)-(坐标x2,坐标y2) 矩形内所有地图单元格的这些标志。
"标志"可以是 0 或 1（0：清除标志，1：设置标志）。
"类型"定义了要修改的标志。可用的选项参见 "src/map/script_constants.hpp"。

Example:
例子：

	setcell "arena",0,0,300,300,cell_basilica,1;
	setcell "arena",140,140,160,160,cell_basilica,0;
	setcell "arena",135,135,165,165,cell_walkable,0;
	setcell "arena",140,140,160,160,cell_walkable,1;

This will add a makeshift ring into the center of the map. The ring will be
surrounded by a 5-cell wide 'gap' to prevent interference from outside, and
the rest of the map will be marked as 'basilica', preventing observers from
casting any offensive skills or fighting among themselves. Note that the wall
will not be shown nor known client-side, which may cause movement problems.
这将在地图中心添加一个临时圆环。圆环周围将有一个 5 格宽的 "缺口"，以防止来自外部的干扰，
地图的其他部分将标记为 "神圣殿堂"，防止围观者施放任何攻击性技能或相互间的战斗。
请注意，客户端不会显示墙壁，也不知道墙壁的位置，这可能会导致移动问题。

Another example:
另外的例子：

OnBarricadeDeploy:
	setcell "schg_cas05",114,51,125,51,cell_walkable,0;
	end;
OnBarricadeBreak:
	setcell "schg_cas05",114,51,125,51,cell_walkable,1;
	end;

This could be a part of the WoE:SE script, where attackers are not allowed
to proceed until all barricades are destroyed. This script would place and
remove a nonwalkable row of cells after the barricade mobs.
这可能是 WoE:SE (SE工会战)脚本的一部分，在所有路障被摧毁之前，攻击者不得继续前进。
该脚本将在路障魔物后放置并移除一排不可行走的单元格。

---------------------------------------

*checkcell ("<map name>",<x>,<y>,<type>);
*checkcell ("<地图名称>",<坐标x>,<坐标y>,<类型>);

This command will return 1 or 0, depending on whether the specified cell has
the 'type' flag set or not. There are various types to check, all mimicking
the server's cell_chk enumeration. The types can be found in 'src/map/script_constants.hpp'.
此命令将返回 1 或 0，取决于指定单元格是否设置了 "类型 "标志。
要检查的类型多种多样，都是模仿服务器的 cell_chk 枚举。
这些类型可在 "src/map/script_constants.hpp "中找到。

The meaning of the individual types can be confusing, so here's an overview:
各种类型的含义可能令人困惑，因此在此作一概述：
  - cell_chkwall/water/cliff
    these check directly for the 'terrain component' of the specified cell       直接检查指定单元格的 "地形成分"
  - cell_chkpass/reach/nopass/noreach
    passable = not wall & not cliff, reachable = passable wrt. no-stacking mod   可通过 = 不是墙壁也不是悬崖，可到达 = 在无堆叠模式下可通过
  - cell_chknpc/basilica/landprotector/novending/nochat
    these check for specific dynamic flags (their name indicates what they do)   它们检查特定的动态标志（其名称表明了它们的作用）

Example:
例子：
	mes "Pick a destination map.";
	input .@map$;
	mes "Alright, now give me the coordinates.";
	input .@x;
	input .@y;
	if ( !checkcell(.@map$,.@x,.@y,cell_chkpass) ) {
		mes "Can't warp you there, sorry!";
		close;
	} else {
		mes "Ok, get ready...";
		close2;
		warp .@map$, .@x, .@y;
		end;
	}

---------------------------------------

*getfreecell "<map name>",<rX>,<rY>{,<x>,<y>,<rangeX>,<rangeY>,<flag>};
*getfreecell "<地图名称>",<坐标rX>,<坐标rY>{,<坐标x>,<坐标y>,<范围X>,<范围Y>,<标志>};

Finds a free cell on the given map and stores the reference to the found cell
in <rX> and <rY>. Passing <x> and <y> with <rangeX> and <rangeY> allows for
searching within a specified area on the given map. The <flag> is a bitmask
and has the following possible values:
在给定的地图上查找空闲单元格，并将找到的单元格的引用存储在 <坐标rX> 和 <坐标rY> 中。
通过 <坐标x> 和 <坐标y> 以及 <范围X> 和 <范围Y> 可以在给定地图上的指定区域内进行搜索。
<标志> 是一个位掩码，可能有以下值：
 - 1 = Random cell on the map or from <x>,<y> range. (default)     地图上或 <坐标x>,<坐标y> 范围内的随机单元格。(默认值）
 - 2 = The target should be able to walk to the target tile.     目标应能走到目标位置。
 - 4 = There shouldn't be any players around the target tile (use the no_spawn_on_player setting).   目标位置周围不应该有任何玩家（使用 no_spawn_on_player 设置）。

Examples:
例子：
	getfreecell("prontera",.@x,.@y); // Find a random empty cell in Prontera and store it within .@x and .@y   在 普隆德拉地图 中随机查找一个空单元格，并将其存储在 .@x 和 .@y 内
	getfreecell("prontera",.@x,.@y,150,150,5,5); // Find a random empty cell on 150,150 (with a range of 5x5) in Prontera and store it within .@x and .@y   在 普隆德拉地图 中查找 150,150（范围为 5x5）上的随机空单元格，并将其存储在 .@x 和 .@y 中。

---------------------------------------

*setwall "<map name>",<x>,<y>,<size>,<dir>,<shootable>,"<name>";
*delwall "<name>";
*setwall "<地图名称>",<坐标x>,<坐标y>,<尺寸>,<方向>,<可否远程射击>,"<名称>";
*delwall "<名称>";

Creates an invisible wall, an array of "setcell" starting from x,y and doing a
line of the given size in the given direction. The difference with setcell is
this one update client part too to avoid the glitch problem. Directions are the
same as NPC sprite facing directions: 0=north, 1=northwest, 2=west, etc.
创建一堵隐形墙，这是一个从 x、y 开始的 "setcell"数组，沿给定方向划一条给定大小的线。
 与 setcell 不同的是，它也会更新客户端部分，以避免出现故障问题。
 方向与 NPC 形象面向的方向相同： 0= 正北，1= 西北，2= 西南等。

---------------------------------------

*checkwall "<name>";
*checkwall "<名称>";

This command will return true if the wall with the given name exists, false otherwise.
如果指定名称的墙存在，此命令将返回 true，否则返回 false。

---------------------------------------

*readbook <book id>,<page>;
*readbook <书籍编号>,<页码>;

This command will open a book item at the specified page.
此命令将打开书籍物品的指定页面。

---------------------------------------

*open_roulette( {char_id} )
*open_roulette( {角色编号} )

Opens the roulette window for the currently attached character or the character
with the given character id.
为当前关联的角色或具有给定角色编号的角色打开轮盘赌窗口。

---------------------------------------

*naviregisterwarp("<Name of Link>", "<dest_map>", <dest_x>, <dest_y>)
*naviregisterwarp("<链接名称>", "<dest_map>", <dest_x>, <dest_y>)

Only useful when using the map-server-generator. Registers an extra warp from this
npc to the destination map/x/y for the generated client files.
仅在使用map-server-generator时有用。为生成的客户端文件注册从该 npc 到目标地图/x/y 的额外传送。

---------------------------------------

*navihide

Only useful when using the map-server-generator. Hides this npc and all links from
this npc in the navigation generation.
仅在使用map-server-generator时有用。在导航生成中隐藏该 npc 和来自该 npc 的所有链接。

---------------------------------------

========================
|7.- Instance commands.|    副本命令
========================
---------------------------------------

*instance_create("<instance name>"{,<instance mode>{,<owner id>}});
*instance_create("<副本名称>"{,<副本模式>{,<所有者编号>}});

Creates an instance for the <owner id> of <mode>. The instance name, along with
all other instance data, is read from 'db/(pre-)re/instance_db.yml'. Upon success,
the command generates a unique instance ID, duplicates all listed maps and NPCs,
sets the alive time, and triggers the "OnInstanceInit" label in all NPCs inside
the instance.
为 <模式> 的 <所有者编号> 创建一个副本。副本名称和所有其他副本数据都从 "db/(pre-)re/instance_db.yml "中读取。
 成功后，该命令会生成一个唯一的副本编号，复制所有列出的地图和 NPC，设置存在时间，并触发副本内所有 NPC 的 "OnInstanceInit "标签。

Instance Mode options:
副本模式选项：
 IM_NONE: Attached to no one.    无任何关联
 IM_CHAR: Attached to a single character.  关联一个单独的角色
 IM_PARTY: Attached to a party (default instance mode).    关联一个组队(默认的副本模式)
 IM_GUILD: Attached to a guild.    关联一个工会
 IM_CLAN: Attached to a clan.      关联一个群组

The command returns the instance ID upon success, and these values upon failure:
命令成功时会返回实例编号，失败时会返回这些值：
 -1: Invalid type.      无效的类型
 -2: Character/Party/Guild/Clan not found.    角色/组队/工会/群组 未找到
 -3: Instance already exists.      副本已存在
 -4: No free instances (MAX_INSTANCE exceeded).    无空余的副本位置(到达了MAX_INSTANCE上限)

---------------------------------------

*instance_destroy {<instance id>};
*instance_destroy {<副本编号>};

Destroys instance with the ID <instance id>. If no ID is specified, the instance
the script is attached to is used. If that fails, the script will come to a halt.
This will also trigger the "OnInstanceDestroy" label in all NPCs inside the instance.
销毁编号为 <副本编号> 的副本。如果未指定编号，则使用脚本所关联的副本。
如果失败，脚本将停止运行。这也会触发副本内所有 NPC 的 "OnInstanceDestroy "标签。

---------------------------------------

*instance_enter("<instance name>",{<x>,<y>,<char_id>,<instance id>});
*instance_enter("<副本名称>",{<坐标x>,<坐标y>,<角色编号>,<副本编号>});

Warps the attached player to the specified <instance id>. If no ID is specified,
the IM_PARTY instance the invoking player is attached to is used.
将关联的玩家传送到指定的 <副本编号> (副本初始地图和坐标)上。
如果没有指定编号，则使用关联玩家的 IM_PARTY 副本。

The map and coordinates are located in 'db/(pre-)re/instance_db.yml'.
地图和(初始)坐标位于 "db/(pre-)re/instance_db.yml "中。

The command returns IE_OK upon success, and these values upon failure:
命令成功时返回 IE_OK，失败时返回这些值：
 IE_NOMEMBER:	Party/Guild/Clan not found (for party/guild/clan modes).  角色/组队/工会/群组 未找到(角色/组队/工会/群组模式)
 IE_NOINSTANCE:	Character/Party/Guild/Clan does not have an instance.     角色/组队/工会/群组未创建副本
 IE_OTHER:		Other errors (invalid instance name, instance doesn't match with character/party/guild/clan).   其他错误(无效的副本名称，副本不匹配角色/组队/工会/群组)

Put -1 for x and y if want to warp player with default entrance coordinates.
如果要使用默认的入口坐标对玩家进行传送，请在 坐标x 和 坐标y 的值上填 -1。

---------------------------------------

*instance_npcname("<npc name>"{,<instance id>})
*instance_npcname("<npc名称>"{,<副本编号>})

Returns the unique name of the instanced script. If no ID is specified,
the instance the script is attached to is used. If that fails, the script
will come to a halt.
返回副本脚本的npc唯一名称。如果未指定编号，则使用脚本所关联的副本。
如果失败，脚本将停止运行。

---------------------------------------

*instance_mapname("<map name>"{,<instance id>})
*instance_mapname("<地图名称>"{,<副本编号>})

Returns the unique name of the instanced map. If no instance ID is specified,
the instance the script is attached to is used. If that fails, the command
returns an empty string instead.
返回副本化地图的唯一名称。如果未指定副本编号，则使用脚本所关联的副本。
如果失败，命令将返回空字符串。

---------------------------------------

*instance_id({<instance mode>})
*instance_id({<副本模式>})

Returns the unique instance ID of the given mode. By default it returns the
attached script instance. If <instance mode> is provided then the instance
of the currently attached player is used. If that fails, the function will return 0.
返回给定模式的唯一副本编号。默认情况下，它会返回脚本关联的副本。
如果提供了 <副本模式>，则会使用当前关联玩家的副本。如果失败，函数将返回 0。

Instance Mode options:
副本模式选项：
 IM_CHAR:	Attached to character.            关联玩家
 IM_PARTY:	Attached to character's party.    关联玩家的组队
 IM_GUILD:	Attached to character's guild.    关联玩家的工会
 IM_CLAN:	Attached to character's clan.     关联玩家的群组

---------------------------------------

*instance_warpall "<map name>",<x>,<y>{,<instance id>};
*instance_warpall "<地图名称>",<坐标x>,<坐标y>{,<副本编号>};

Warps all players in the <instance id> to <map name> to the given coordinates.
If no ID is specified, the IM_PARTY instance the invoking player is attached
to is used. If that fails, the script will come to a halt.
将 <副本编号> 里关联的所有玩家传送至 <地图名称>里给定坐标。
如果未指定编号，则使用关联玩家的 IM_PARTY 副本。如果失败，脚本将停止运行。

---------------------------------------

*instance_announce <instance id>,"<text>",<flag>{,<fontColor>{,<fontType>{,<fontSize>{,<fontAlign>{,<fontY>}}}}};
*instance_announce <副本编号>,"<文本>",<标志>{,<字体颜色>{,<字体类型>{,<字体尺寸>{,<字体对齐>{,<字体Y坐标>}}}}};

Broadcasts a message to all players in the <instance id> currently residing on
an instance map. If 0 is specified for <instance id>, the instance the script
is attached to is used.
向当前在<副本编号>对应副本地图上的所有玩家播放一条信息。
如果 <副本编号> 指定为 0，则使用脚本所关联的副本。

For details on the other parameters, see 'announce'.
有关其他参数的详细信息，请参阅 'announce'。

---------------------------------------

*instance_check_party(<party id>{,<amount>{,<min>{,<max>}}})
*instance_check_party(<组队编号>{,<数量>{,<最小值>{,<最大值>}}})

This function checks if a party meets certain requirements, returning 1 if all
conditions are met and 0 otherwise. It will only check online characters.
该函数检查组队是否满足某些要求，如果满足所有条件则返回 1，否则返回 0。
它只会检查当前在线的玩家。

amount - number of online party members (default is 1).                                    数量 - 在线队员人数（默认为 1）。
min    - minimum level of all characters in the party (default is 1).                      最小值    - 队伍中所有角色的最低等级（默认为 1）。
max    - maximum level of all characters in the party (default is max level in conf).      最大值    - 队伍中所有角色的最高等级（默认为 conf 中的最高等级）。

Example:
例子：

if (instance_check_party(getcharid(1),2,2,149)) {
	mes "Your party meets the Memorial Dungeon requirements.",    //mes "您的队伍符合记忆迷宫的要求。"
	mes "All online members are between levels 1-150 and at least two are online.";  //mes "所有在线成员的等级都在 1-150 级之间，且至少有两人在线。"
	close;
} else {
	mes "Sorry, your party does not meet requirements.";   //mes "抱歉，您的队伍不符合要求。"
	close;
}

---------------------------------------

*instance_check_guild(<guild id>{,<amount>{,<min>{,<max>}}})
*instance_check_guild(<工会编号>{,<数量>{,<最小值>{,<最大值>}}})

This function checks if a guild meets certain requirements, returning 1 if all
conditions are met and 0 otherwise. It will only check online characters.
此函数检查工会是否满足某些要求，如果满足所有条件则返回 1，否则返回 0。
它只会检查当前在线的玩家。

amount - number of online guild members (default is 1).                                 数量 - 在线工会成员人数（默认为 1）。
min    - minimum level of all characters in the guild (default is 1).                   最小值    - 工会中所有角色的最低等级（默认为 1）。
max    - maximum level of all characters in the guild (default is max level in conf).   最大值    - 工会中所有角色的最高等级（默认为 conf 中的最高等级）。

Example:
例子：

if (instance_check_guild(getcharid(2),2,2,149)) {
	mes "Your guild meets the Memorial Dungeon requirements.",      //mes "您的工会符合记忆迷宫的要求。"
	mes "All online members are between levels 1-150 and at least two are online.";    //mes "所有在线成员的等级都在 1-150 级之间，且至少有两人在线。"
	close;
} else {
	mes "Sorry, your guild does not meet requirements.";   //mes "抱歉，您的工会不符合要求。"
	close;
}

---------------------------------------

*instance_check_clan(<clan id>{,<amount>{,<min>{,<max>}}})
*instance_check_clan(<群组编号>{,<数量>{,<最小值>{,<最大值>}}})

This function checks if a clan meets certain requirements, returning 1 if all
conditions are met and 0 otherwise. It will only check online characters.
此函数检查群组是否满足某些要求，如果满足所有条件则返回 1，否则返回 0。
它只会检查当前在线的玩家。

amount - number of online clan members (default is 1).                                   数量 - 在线群组成员人数（默认为 1）。
min    - minimum level of all characters in the clan (default is 1).                     最小值    - 群组中所有角色的最低等级（默认为 1）。
max    - maximum level of all characters in the clan (default is max level in conf).     最大值    - 群组中所有角色的最高等级（默认为 conf 中的最高等级）。

Example:

if (instance_check_clan(getcharid(5),2,2,149)) {
	mes "Your clan meets the Memorial Dungeon requirements.",                             //mes "您的群组符合记忆迷宫的要求。"
	mes "All online members are between levels 1-150 and at least two are online.";       //mes "所有在线成员的等级都在 1-150 级之间，且至少有两人在线。"
	close;
} else {
	mes "Sorry, your clan does not meet requirements.";   //mes "抱歉，您的群组不符合要求。"
	close;
}

---------------------------------------

*instance_info("<instance name>",<info type>{,<instance_db map index>});
*instance_info("<副本名称>",<信息类型>{,<instance_db地图索引>});

Returns the specified <info type> of the given <instance name> from the instance database.
If the <instance name> is unknown or an invalid <info type> is supplied -1 will be returned.
从副本数据库返回给定<副本名称>的指定<信息类型>。
如果<副本名称>未知或提供的<信息类型>无效，将返回-1。

Valid info types:
有效的信息类型：
 IIT_ID: Instance database ID as integer.                        副本数据库编号（整数）。
 IIT_TIME_LIMIT: Instance database total life time as integer.   副本数据库的时限（整数）。
 IIT_IDLE_TIMEOUT: Instance database timeout time as integer.    副本数据库超时时间（整数）。
 IIT_ENTER_MAP: Instance database enter map as string.           副本数据库初始进入地图（整数）。
 IIT_ENTER_X: Instance database enter X location as integer.     副本数据库初始进入位置X坐标（整数）。
 IIT_ENTER_Y: Instance database enter Y location as integer.     副本数据库初始进入位置Y坐标（整数）。
 IIT_MAPCOUNT: Instance database total maps as integer.          副本数据库使用的地图总数（整数）。
 IIT_MAP: Instance database map name from the given <instance_db map index> as string.      副本数据库使用的<instance_db地图索引>列出的地图名称（整数）。
          If the index is invalid an empty string will be returned.     如果索引无效，将返回空字符串。

Example:
例子：

.@name$ = "Endless Tower";
mes .@name$ + " will be destroyed if no one is in the instance for " + instance_info(.@name$,IIT_IDLETIMEOUT) + " seconds.";
// Endless Tower will be destroyed if no one is in the instance for 300 seconds.
// 如果 300 秒内无人进入本，无尽之塔副本将被删除。

---------------------------------------

*instance_live_info(<info type>{,<instance id>});
*instance_live_info(<信息类型>{,<副本编号>});

Returns the specified <info type> of instance attached to the npc or, if
an instance ID is specified, of that instance.
返回 npc 关联副本指定的 <信息类型>，如果指定了副本编号，则返回该副本的 <信息类型>。

Valid <info type>:
有效的<信息类型>：
ILI_NAME	- Instance Name      副本名称
			  Return the name of the instance or "" if that fails.    返回副本的名称，如果失败则返回""。
ILI_MODE	- Instance Mode      副本模式
			  Return IM_NONE, IM_CHAR, IM_PARTY, IM_GUILD, IM_CLAN or -1 if that fails.   返回 IM_NONE、IM_CHAR、IM_PARTY、IM_GUILD、IM_CLAN 如果失败，则返回-1。
ILI_OWNER	- Owner ID           所有者的编号
			  Return an ID according to the instance mode of the instance attached/specified or -1 if that fails.    根据关联/指定的副本模式返回该副本对应的所有者编号，如果返回失败，则返回-1。
			  When the instance mode is IM_NONE, ILI_OWNER will return the npc ID that created the instance,         当副本模式为 IM_NONE 时，ILI_OWNER 将返回创建副本的 npc 编号、
			  IM_CHAR	- the owner char ID       所有者的角色编号
			  IM_PARTY	- the party ID            队伍编号
			  IM_GUILD	- the guild ID            工会编号
			  IM_CLAN	- the clan ID             群组编号

Examples:
例子：
	// Return the instance name of the instance attached to the npc.  返回关联 npc 的副本名称。
	.@instance_name$ = instance_live_info(ILI_NAME);

	// Return the guild owner ID of the given instance ID.   返回给定副本编号的所有者工会编号。
	.@owner = instance_live_info(ILI_OWNER, instance_id(IM_GUILD));

---------------------------------------

*instance_list(<"map name">{,<instance mode>});
*instance_list(<"地图名称">{,<副本模式>});

Creates the array '.@instance_list' with possible instance IDs for the given <map name> and optional <mode>.
Return '.@instance_list' array size.
创建数组".@instance_list"，其中包含给定的 <地图名称> 和可选的 <模式> 的可能副本编号。
返回'.@instance_list'数组的大小。

Instance mode options: IM_NONE, IM_CHAR, IM_PARTY, IM_GUILD, or IM_CLAN
If the instance mode is not provided then it will return all the instance IDs for that map.
副本模式选项： IM_NONE、IM_CHAR、IM_PARTY、IM_GUILD 或 IM_CLAN
如果未提供副本模式，则将返回该地图的所有副本编号。

Examples:
例子：
	// This example assumes that there are several instances on the map of Prontera.   本例假定 普隆德拉 地图上有多个实例。
	.@size = instance_list("prontera");
	for ( .@i = 0; .@i < .@size; ++.@i )
		mes instance_mapname("prontera", .@instance_list[.@i]);
	//the output would be a list of all prontera copies that are active in the server.  输出将是服务器中所有处于激活状态的 普隆德拉 副本的列表。

---------------------------------------

*getvariableofinstance(<variable>,<instance id>);
*getvariableofinstance(<变量>,<副本编号>);

Returns a reference to an instance variable (' prefix) of the specific instance ID.
This can only be used to get ' variables.
返回指定副本编号里的某个副本变量（'前缀）的值。这只能用于获取 ' 变量。

Examples:
例子：
	// This will set the .@s variable to the value of 'var variable of the specific instance ID.
	//这将把 .@s 变量设置为指定副本编号 的 'var 变量的值。
	set .@s, getvariableofinstance('var, instance_id(IM_PARTY));

	// This will set the 'var variable of the specific instance ID to 1.
	// 这将把指定副本编号的 'var 变量设置为 1。
	set getvariableofinstance('var, instance_id(IM_GUILD)), 1;

---------------------------------------

*setinstancevar(<variable>,<value>,<instance id>);
*setinstancevar(<变量>,<值>,<副本编号>);

This command will set an instance variable to the value that the expression results in.
See 'set' command for more information.
该命令将把副本变量设置为表达式所产生的值。
更多信息请参阅 "set"命令。

Returns the variable reference.
返回变量引用。

Examples:
例子：
	// This will set the 'var variable of the specific instance ID to 9.    这会将特定副本编号的 'var 变量设置为 9。
	setinstancevar('var, 9, instance_id(IM_GUILD));

---------------------------------------

=========================
|8.- Quest Log commands.|         任务日志命令
=========================
---------------------------------------

*questinfo <Icon>{,<Map Mark Color>{,"<condition>"}};
*questinfo <图标>{,<地图标记颜色>{,"<条件>"}};

This command should only be used in OnInit/OnInstanceInit labels.
Show an emotion on top of a NPC, and optionally, a colored mark in the mini-map like "viewpoint".
When a user is doing some action, each NPC is checked for questinfo that has been set on the map.
If questinfo is present, it will check if the player fulfill the condition.
If he/she does or no condition has been set, the bubble will appear.
该命令只能在 OnInit/OnInstanceInit 标签中使用。在 NPC 的顶部显示表情符号，
并在小地图上显示类似 "viewpoint"的彩色标记。当用户进行某些操作时，每个 NPC 都会检查在地图上设置的任务信息。
如果存在任务信息，它会检查玩家是否满足条件。如果他/她设置了条件或没有设置条件，表情符号框就会出现。

Available <Icon>:
可用<图标>：

No Icon			: QTYPE_NONE      无图标
! Quest Icon	: QTYPE_QUEST     ！任务图标
? Quest Icon	: QTYPE_QUEST2    ？任务图标
! Job Icon		: QTYPE_JOB       ！职业图标
? Job Icon		: QTYPE_JOB2      ？职业图标
! Event Icon	: QTYPE_EVENT     ！事件图标
? Event Icon	: QTYPE_EVENT2    ？事件图标
Warg			: QTYPE_WARG (Only for packetver < 20170315)    Warg图标 (仅限封包版本 < 20170315)
Warg Face		: QTYPE_WARG2 (Only for packetver >= 20120410 and < 20170315)    Warg Face图标 (仅限封包版本 >= 20120410 and < 20170315)
Click Me		: QTYPE_CLICKME (Only for packetver >= 20170315)   点击我 图标 (仅限封包版本 >= 20170315)
Daily Quest		: QTYPE_DAILYQUEST (Only for packetver >= 20170315)   每日任务 图标 (仅限封包版本 >= 20170315)
! Event Icon	: QTYPE_EVENT3 (Only for packetver >= 20170315)       ！事件图标 (仅限封包版本 >= 20170315)
Job Quest		: QTYPE_JOBQUEST (Only for packetver >= 20170315)      职业任务 图标 (仅限封包版本 >= 20170315)
Jumping Poring	: QTYPE_JUMPING_PORING (Only for packetver >= 20170315)   跳跃的波利 图标 (仅限封包版本 >= 20170315)

<Map Mark Color>, when used, creates a mark in the user's mini map on the position of the NPC,
the available color values are:
使用<地图标记颜色>时，会在用户的小地图中的 NPC 位置上创建一个标记，可用的颜色值有：

QMARK_NONE   - No Marker (default)    无标记（默认）
QMARK_YELLOW - Yellow Marker          黄色标记
QMARK_GREEN  - Green Marker           绿色标记
QMARK_PURPLE - Purple Marker          紫色标记

<condition> can be any expression similarly to the <condition> in the 'if' command.
<条件> 可以是任何表达式，与 "if "命令中的 <条件> 类似。

List of the player's actions to trigger the questinfo condition:
触发 questinfo 条件的玩家操作列表：
-	Item added to/removed from player inventory       从玩家库存中添加/删除物品
-	Base/Job level change                             基础/职业等级变化
-	Job change                                        职业变更
-	Quest given/erased/completed                      任务给与/清除/完成
-	Quest objective updated (character killed a monster quest target)      任务目标更新（角色杀死了任务目标怪物）
-	Warp                                              传送


Example:
例子：
izlude,100,100,4	script	Test	844,{
	mes "[Test]";
	mes "Hello World.";
	close;

OnInit:
	// Display an icon if the player has completed the given hunting quest and his/her variable 'unknown_var' is above 0
	//如果玩家已完成给定的狩猎任务，且其变量 "unknown_var "大于 0，则显示一个图标
	questinfo QTYPE_QUEST, QMARK_YELLOW, "checkquest(1001,HUNTING) == 2 && unknown_var > 0";

	//.. or display an icon if the player didn't start the given quest and he/she has one red potion in inventory
	//... 或者，如果玩家没有开始给定的任务，而他/她的库存中有一瓶红药水，则显示一个图标
	questinfo QTYPE_QUEST, QMARK_YELLOW, "!isbegin_quest(1001) && countitem(501) == 1";
	end;
}

---------------------------------------

*questinfo_refresh {<char_id>};
*questinfo_refresh {<角色编号>};

This command refreshes each quest bubble that has been set on the map according
to the questinfo condition for the attached/given player.
该命令会根据任务信息条件刷新在地图上设置的每个任务图标，这些任务图标适用于关联/给定的玩家。

---------------------------------------

*setquest <ID>{,<char_id>};
*setquest <编号>{,<角色编号>};

Place quest of <ID> in the users quest log, the state of which is "active".
将状态为"激活"的任务<编号>放入用户任务日志。

If *questinfo is set, and the same ID is specified here, the icon will be cleared when the quest is set.
如果设置了 *questestinfo，并且在此处指定了相同的编号，则在设置任务时将清除图标。

---------------------------------------

*completequest <ID>{,<char_id>};
*completequest <编号>{,<角色编号>};

Change the state for the given quest <ID> to "complete" and remove from the users quest log.
将给定任务 <编号> 的状态更改为 "完成"，并从用户任务日志中删除。

---------------------------------------

*erasequest <ID>{,<char_id>};
*erasequest <编号>{,<角色编号>};

Remove the quest of the given <ID> from the user's quest log.
从用户的任务日志中删除给定 <编号> 的任务。

---------------------------------------

*changequest <ID>,<ID2>{,<char_id>};
*changequest <编号>,<编号2>{,<角色编号>};

Remove quest of the given <ID> from the user's quest log.
Add quest of the <ID2> to the the quest log, and the state is "active".
从用户的任务日志中删除给定 <编号> 的任务。
在任务日志中添加<编号2>的任务，状态为 "激活"。

---------------------------------------

*checkquest(<ID>{,PLAYTIME|HUNTING{,<char_id>}})
*checkquest(<编号>{,PLAYTIME|HUNTING{,<角色编号>}})

If no additional argument supplied, return the state of the quest:
如果没有提供其他参数，则返回任务状态：
	-1 = Quest not started (not in quest log)                    任务未开始(未出现在任务日志)
	0  = Quest has been given, but the state is "inactive"       任务已给予，但状态为"未激活"
	1  = Quest has been given, and the state is "active"         任务已给予，且状态为"已激活"
	2  = Quest completed                                         任务已完成

If parameter "PLAYTIME" is supplied:
如果提供参数 "PLAYTIME"（游戏时间）：
	-1 = Quest not started (not in quest log)         任务未开始(未出现在任务日志)
	0  = the time limit has not yet been reached      任务时限未到
	1  = the time limit has not been reached but the quest is marked as complete    任务时限未到，但任务已标记为完成
	2  = the time limit has been reached              任务时限已到

If parameter "HUNTING" is supplied:
如果提供参数 "HUNTING"（狩猎数）：
	-1 = Quest not started (not in quest log)    任务未开始(未出现在任务日志)
	0  = you haven't killed all of the target monsters and the time limit has not been reached.    尚未杀死所有目标魔物，且时限未到。
	1  = you haven't killed all of the target monsters but the time limit has been reached.        尚未杀死所有目标魔物，时限已到。
	2  = you've killed all of the target monsters      已杀死所有目标魔物

---------------------------------------

*isbegin_quest(<ID>{,<char_id>})
*isbegin_quest(<编号>{,<角色编号>})

Return the state of the quest:
返回任务状态：
	0  = Quest not started (not in quest log)    任务未开始(未出现在任务日志)
	1  = Quest has been given (state is either "inactive" or "active")     任务已给与（状态可以为 "未激活 "或 "激活"）。
	2  = Quest completed                         任务已完成

---------------------------------------

*showevent <icon>{,<mark color>{,<char_id>}}
*showevent <图标>{,<标记颜色>{,<角色编号>}}

Show an emotion on top of a NPC, and optionally,
a colored mark in the mini-map like "viewpoint".
This is used to indicate that a NPC has a quest or an event to
a certain player.
在 NPC 的顶部显示表情符号，并在小地图上显示类似 "viewpoint"的彩色标记。
用于表示某个 NPC 有任务或事件要交给某个玩家。

Available Icons:
可用图标

Remove Icon		: QTYPE_NONE      去除图标
! Quest Icon	: QTYPE_QUEST     ！任务图标
? Quest Icon	: QTYPE_QUEST2    ？任务图标
! Job Icon		: QTYPE_JOB       ！职业图标
? Job Icon		: QTYPE_JOB2      ？职业图标
! Event Icon	: QTYPE_EVENT     ！事件图标
? Event Icon	: QTYPE_EVENT2    ？事件图标
Warg			: QTYPE_WARG       Warg图标
Warg Face		: QTYPE_WARG2 (Only for packetver >= 20120410)    Warg Face图标(仅限封包版本 >= 20120410)

Mark Color:
标记颜色：
QMARK_NONE   - No Marker (default)     无标记(默认)
QMARK_YELLOW - Yellow Marker           黄色标记
QMARK_GREEN  - Green Marker            绿色标记
QMARK_PURPLE - Purple Marker           紫色标记

---------------------------------------

*open_quest_ui {<quest ID>,{<char ID>}};
*open_quest_ui {<任务编号>,{<角色编号>}};

Opens the quest UI for the attached player or the given character ID.
Use 0 as the quest ID to open the main quest UI. If the quest ID is not 0 then the quest UI is opened to the given quest. If the quest data is not populated in the client LUB then a message will be displayed saying the quest doesn't exist.
打开所关联玩家或给定角色编号的任务界面。
使用 0 作为任务编号可以打开主任务界面。如果任务编号不是 0，则会打开给定任务的任务界面。
如果任务数据未在客户端 LUB 中填充，则会显示任务不存在的信息。

This command requires packet version 2015-12-02 or newer.
此命令要求数据封包版本为 2015-12-02 或更新版本。

---------------------------------------

============================
|9.- Battleground commands.|        战场命令
============================
---------------------------------------

*waitingroom2bg_single(<battle group>,{"<map name>",<x>,<y>{,"<npc name>"}});
*waitingroom2bg_single(<战场队伍>,{"<地图名称>",<坐标x>,<坐标y>{,"<npc名称>"}});

Adds the first waiting player from the chat room of the given NPC to an existing battleground group.
The player will also be warped to the default spawn point of the battle group or to the specified coordinates
<x> and <y> on the given <map>.
Note: The map need the mapflag MF_BATTLEGROUND otherwise the player is removed from the Battleground team.
将给定 NPC 聊天室中的第一个等待玩家添加到现有的战场队伍中。
玩家也会被传送到战场队伍的默认生成点或给定 <地图> 上的指定坐标 <x> 和 <y>。
注意：地图需要地图标志 MF_BATTLEGROUND，否则玩家将从战场队伍中除名。

---------------------------------------

*waitingroom2bg("<map name>",<x>,<y>,{"<On Quit Event>","<On Death Event>"{,"<NPC Name>"}});
*waitingroom2bg("<地图>",<坐标x>,<坐标y>,{"<退出事件>","<死亡事件>"{,"<NPC名称>"}});

<map name>,<x>,<y> refer to where the "respawn" base is, where the player group will respawn when they die.
<On Quit Event> refers to an NPC label that attaches to the character and is run when they relog. (Optional)
<On Death Event> refers to an NPC label that attaches to the character and is run when they die. (Optional)
<地图名称>,<x>,<y>指的是 "重生"初始的位置，也就是玩家死亡后重生的地方。
<退出事件>是指关联在角色身上的 NPC 标签，当角色重新登录时会运行该标签。(可选)
<死亡事件>是指关联在角色身上的 NPC 标签，当角色死亡时会运行该标签。(可选)

If "-" is supplied for <map name> then the player will not automatically respawn after the 1 second delay.
This allows for better manipulation of <On Death Event>. The player will have to be warped to desired location
at the end of <On Death Event>.
如果为 <地图名称> 提供了"-"，则玩家不会在 1 秒延迟后自动重生。这样就可以更好地操作<死亡事件>。
玩家必须在<死亡事件>结束时被传送到所需位置。

Unlike the prior command, the latter will attach a GROUP in a waiting room to the battleground, and
sets the array $@arenamembers[0] where 0 holds the IDs of the first group, and 1 holds the IDs of the second.
与前一条命令不同的是，后一条命令会将等候室中的 GROUP 附加到战场，并设置数组 $@arenamembers[0]，其中 0 表示第一个组的 ID，1 表示第二个组的 ID。

If the optional NPC Name parameter is left out, the waiting room of the current NPC is used.
如果不使用可选的 NPC 名称参数，则使用当前 NPC 的等候室。

Example:
例子：
	// Battle Group will be referred to as $@KvM01BG_id1, and when they die, respawn at bat_c01,52,129.
	//战斗队伍将被称为 $@KvM01BG_id1，当他们死亡时，会在 bat_c01,52,129 处重生。
	set $@KvM01BG_id1, waitingroom2bg("bat_c01",52,129,"KvM01_BG::OnGuillaumeQuit","KvM01_BG::OnGuillaumeDie");
	end;

---------------------------------------

*bg_create("<map name>",<x>,<y>{,"<On Quit Event>","<On Death Event>"});
*bg_create("<地图名称>",<坐标x>,<坐标y>{,"<退出事件>","<死亡事件>"});

Creates an instance of battleground battle group that can be used with other battleground commands.
为战斗队伍创建一个战场副本，可与其他战场命令一起使用。

<map name>,<x>,<y> refer to where the "respawn" base is, where the player group will respawn when they die.
<On Quit Event> refers to an NPC label that attaches to the character and is run when they relog. (Optional)
<On Death Event> refers to an NPC label that attaches to the character and is run when they die. (Optional)
<地图名称>,<x>,<y>指的是 "重生"初始的位置，也就是玩家死亡后重生的地方。
<退出事件>是指关联在角色身上的 NPC 标签，当角色重新登录时会运行该标签。(可选)
<死亡事件>是指关联在角色身上的 NPC 标签，当角色死亡时会运行该标签。(可选)

If "-" is supplied for <map name> then the player will not automatically respawn after the 1 second delay.
This allows for better manipulation of <On Death Event>. The player will have to be warped to desired location
at the end of <On Death Event>.
如果为 <地图名称> 提供了"-"，则玩家不会在 1 秒延迟后自动重生。这样就可以更好地操作<死亡事件>。
玩家必须在<死亡事件>结束时被传送到所需位置。

Returns battle group ID on success. Returns 0 on failure.
成功时返回战场队伍编号。失败时返回 0。

---------------------------------------

*bg_join(<battle group>,{"<map name>",{<x>,<y>{,<char id>}});
*bg_join(<战场队伍>,{"地图名称>",{<坐标x>,<坐标y>{,<角色编号>}});

Adds an attached player or <char id> if specified to an existing battleground group. The player will also be warped
to the default spawn point of the battle group or to the specified coordinates <x> and <y> on the given <map>.
Note: The map need the mapflag MF_BATTLEGROUND otherwise the player is removed from the Battleground team.
在现有战场队伍中添加一个关联玩家或 <角色编号>（如果指定）。玩家也会被传送到战场队伍的默认重生点或给定 <地图> 上的指定坐标 <x> 和 <y>。
注意：地图需要地图标志 MF_BATTLEGROUND，否则玩家将从战场队伍中除名。

Returns true on success. Returns false on failure.
成功时返回 true。失败则返回 false。

---------------------------------------

*bg_team_setxy <Battle Group ID>,<x>,<y>;
*bg_team_setxy <战场队伍编号>,<坐标x>,<坐标y>;

Updates the respawn point of the given Battle Group to x,y on the same map. <Battle Group ID> can be retrieved
using getcharid(4).
将指定战场队伍的重生点更新为同一地图上的 坐标x、坐标y。可使用 getcharid(4) 获取 <战场队伍编号>。

Example:
例子：
	bg_team_setxy getcharid(4),56,212;
	mapannounce "bat_a01", "Group [1] has taken the work shop, and will now respawn there.",bc_map,"0xFFCE00";
	end;

---------------------------------------

*bg_reserve("<battleground_map_name>"{,<ended>});
*bg_reserve("<战场地图名称>"{,<结束>});

Reserves a Battleground map for the Battleground UI System. When a map is booked it prevents another similar
queue from being created and will allow players to join an active Battlegrounds event.
为战场用户界面系统预留一张战场地图。当一张地图被预订后，它将阻止另一个类似队列的创建，并允许玩家加入正在进行的战场活动。

If <ended> is true, then the Battleground is marked as over to prevent new players from joining. This state is meant
for the period where players can get their Badges.
如果 <结束> 为 true，则战场被标记为结束，以防止新玩家加入。这种状态是指玩家可以获得徽章的时期。

---------------------------------------

*bg_unbook("<battleground_map_name>");
*bg_unbook("<战场地图名称>");

Removes a Battleground map for the Battleground UI System. When a map is unbooked it allows a queue to be created.
为战场 UI 系统删除战场地图。当地图未被预订时，允许创建队列。

---------------------------------------

*bg_desert({<char_id>});
*bg_desert({<角色编号>});

Same as 'bg_leave' but slaps the player with a deserter status so they can't enter another queue for the time
defined in battleground_db (10 minutes by default).
与 "bg_leave "相同，但会将玩家置于脱离状态，使其在 battleground_db 中定义的时间（默认为 10 分钟）内无法进入其他队伍。


With the Battleground Queue System, it will also warp the player to their previous position when they joined or
to their save point if the map had MF_NOSAVE.
通过战场队列系统，它还会将玩家传送到其加入时的先前位置，或者如果地图有 MF_NOSAVE，则传送到其保存点。

---------------------------------------

*bg_warp <Battle Group>,"<map name>",<x>,<y>;
*bg_warp <战场队伍>,"<地图名称>",<坐标x>,<坐标y>;

Similar to the 'warp' command.
Places all members of <Battle Group> at the specified map and coordinates.
与'warp'指令类似。
将 <战场队伍> 的所有成员放置在指定的地图和坐标上。

Example:
例子：
	//place the battle group one for Tierra Gorge at starting position.
	//将第一战斗群部署到Tierra峡谷的起始位置。
	bg_warp $@TierraBG1_id1,"bat_a01",352,342;
	end;

---------------------------------------

*bg_monster <Battle Group>,"<map name>",<x>,<y>,"<name to show>",<mob id>,"<event label>";
*bg_monster(<Battle Group>,"<map name>",<x>,<y>,"<name to show>",<mob id>,"<event label>");
*bg_monster(<战场队伍>,"<地图名称>",<坐标x>,<坐标y>,"<显示名称>",<魔物编号>,"<事件标签>");

Similar to the 'monster' command.
Spawns a monster with allegiance to the given Battle Group.
Does not allow for the summoning of multiple monsters.
Monsters are similar to those in War of Emperium, in that the specified Battle Group is considered friendly.
与'monster'命令类似。
生成一只与给定战场队伍结盟的怪物。
不允许召唤多个怪物。
怪物与工会战中的魔物类似，指定的队伍被视为友军。

Example:
例子：
	// It can be used in two different ways.     有两种不同的使用方式。
	bg_monster $@TierraBG1_id2,"bat_a01",167,50,"Food Depot",1910,"Feed Depot#1::OnMyMobDead";
	end;

	// Alternatively, you can set an ID for the monster using "set".      或者，您也可以使用 "set"为怪物设置一个 ID。
	// This becomes useful when used with the command below.     当与下面的命令一起使用时，它就变得非常有用了。
	set $@Guardian_3, bg_monster($@TierraBG1_id2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	end;

---------------------------------------

*bg_monster_set_team <GID>,<Battle Group>;
*bg_monster_set_team <GID>,<战场队伍>;

This command will change the allegiance if a monster in a battle ground.
GID can be set when spawning the monster via the 'bg_monster' command.
这条命令将改变战场上怪物的结盟对象。
GID 可以在生成魔物时通过 "bg_monster"命令设置。

Example:
例子：

	end;

OnEnable:
	mapannounce "A guardian has been summoned for Battle Group 2!",bc_map,"0xFFCE00";
	set $@Guardian, bg_monster($@BG_2,"bat_a01",268,204,"Guardian",1949,"NPCNAME::OnMyMobDead");
	initnpctimer;
	end;

OnTimer1000:
	stopnpctimer;
	mapannounce "Erm, sorry about that! This monster was meant for Battle Group 1.",bc_map,"0xFFCE00";
	bg_monster_set_team $@Guardian, $@BG_1;
	end;

---------------------------------------

*bg_leave {<char_id>};
*bg_leave {<角色编号>};

Removes attached player from their Battle Group.
将关联玩家从其战场队伍中移除。

With the Battleground Queue System, it will also warp the player to their previous position when they joined or
to their save point if the map had MF_NOSAVE.
通过战场队列系统，它还会将玩家传送到其加入时的先前位置，或者如果地图有 MF_NOSAVE，则传送到其保存点。

---------------------------------------

*bg_destroy <Batte Group>;
*bg_destroy <战场队伍>;

Destroys the Battle Group created for that battle ground.
删除为该战场创建的战场队伍。

---------------------------------------

*areapercentheal "<map name>",<x1>,<y1>,<x2>,<y2>,<hp>,<sp>;
*areapercentheal "<地图名称>",<坐标x1>,<坐标y1>,<坐标x2>,<坐标y2>,<hp>,<sp>;

Restores a percentage of the maximum HP/SP of players within a defined area.
This is primarily used in battleground scripts, but is not limited to them.
为指定区域内的玩家恢复一定百分比的最大 HP/SP。
这主要用于战场脚本，但并不局限于战场脚本。

Example:
例子：
	areapercentheal "bat_a01",52,208,61,217,100,100;
	end;

---------------------------------------

*bg_get_data(<Battle Group>,<type>);
*bg_get_data(<战场队伍>,<类型>);

Retrieves data related to given Battle Group. Type can be one of the following:
检索与给定战场队伍相关的数据。类型可以是以下之一：

	0 - Amount of players currently belonging to the group.       当前属于该队伍的玩家数量。
	1 - Store GID of players in <Battle Group> in a temporary global array $@arenamembers,                        在临时全局数组 $@arenamembers 中存储<战场队伍>中玩家的 GID，
		stores and also returns the amount of players currently belonging to the group in $@arenamemberscount.    并在数组 $@arenamemberscount 中返回当前属于该队伍的玩家数量。

---------------------------------------

*bg_getareausers(<Battle Group>,"<map name>",<x0>,<y0>,<x1>,<y1>);
*bg_getareausers(<战场队伍>,"<地图名称>",<坐标x0>,<坐标y0>,<坐标x1>,<坐标y1>);

Retrieves the amount of players belonging to the given Battle Group on the given
map within the specified rectangular area.
读取指定矩形区域内指定地图上属于指定战场队伍的玩家数量。

---------------------------------------

*bg_updatescore "<map name>",<Guillaume Score>,<Croix Score>;
*bg_updatescore "<地图名称>",<Guillaume分数>,<Croix分数>;

This command will force the update of the displayed scoreboard.
It is only usable when the map is defined as a Type 2 Battleground:
此命令将强制更新显示的记分板。
它只有在地图被定义为 2 类战场时才能使用：

mapflag	<map name>	battleground	2

---------------------------------------

*bg_info("<battleground name>", <type>);
*bg_info("<战场名称>", <类型>);

Retrieves data related to given <battleground name> from the database. Requires feature.bgqueue
to be enabled. <Type> can be one of the following:
从数据库中读取与给定的 <战场名称> 相关的数据。需要启用 feature.bgqueue。<Type> 可以是以下之一：

	BG_INFO_ID: Battleground ID.    战场编号
	BG_INFO_REQUIRED_PLAYERS: Required players to start a battleground (per side).     要求玩家开辟战场（每方）。
	BG_INFO_MAX_PLAYERS: Maximum players allowed in a battleground.                    战场允许的最大玩家人数。
	BG_INFO_MIN_LEVEL: Minimum level allowed to join a battleground.                   允许加入战场的最低等级。
	BG_INFO_MAX_LEVEL: Maximum level allowed to join a battleground.                   允许加入战场的最高等级。
	BG_INFO_MAPS: Number of maps in a battleground. Stores an array of map names in @bgmaps[] and a count in @bgmapscount.    战场中地图的数量。在 @bgmaps[] 中存储地图名称数组，在 @bgmapscount 中存储计数。
	BG_INFO_DESERTER_TIME: Amount of time in seconds a player is marked deserter.      玩家被标记为脱离的时间（秒）。

---------------------------------------

====================
|10.- Pet commands.|           宠物命令
====================
---------------------------------------

*bpet;
*birthpet;

This command opens up a pet hatching window on the client connected to the
invoking character. It is used in item script for the pet incubators and will
let the player hatch an owned egg. If the character has no eggs, it will just
open up an empty incubator window.
This is still usable outside item scripts.
此命令会在与调用角色相连的客户端上打开一个宠物孵化窗口。
它用于宠物孵化器的物品脚本，可让玩家孵化自己拥有的宠物蛋。
如果角色没有蛋，就会打开一个空的孵化器窗口。

---------------------------------------

*pet <pet id>;
*catchpet <pet id>;
*pet <宠物编号>;
*catchpet <宠物编号>;

This command is used in all the item scripts for taming items. Running this
command will make the pet catching cursor appear on the client connected to the
invoking character, usable on the monsters with the specified pet ID number. It
will still work outside an item script.
If the <pet id> is PET_CATCH_UNIVERSAL the item will attempt to catch the targeted
monster as long as it is in the pet database and does not have the MD_STATUS_IMMUNE
monster mode.
If the <pet id> is PET_CATCH_UNIVERSAL_ITEM the item will attempt to catch the targeted
monster as long as it is in the pet database and the targeted monster requires the lure
item used.
See 'doc/mob_db_mode_list.txt' for more information about monster modes.
该命令用于所有抓宠物品的物品脚本。运行此命令将使宠物捕捉光标出现在与调用角色连接的客户端上，
可用于指定宠物编号的怪物。它仍然可以在物品脚本之外运行。
如果 <宠物编号> 是 PET_CATCH_UNIVERSAL，那么只要目标魔物不在宠物数据库中，并且没有 MD_STATUS_IMMUNE 魔物模式，该物品就会尝试捕捉它。
如果 <宠物编号> 是 PET_CATCH_UNIVERSAL_ITEM，只要目标魔物在宠物数据库中，并且目标魔物需要使用诱饵物品，该物品就会尝试捕捉目标魔物。
有关魔物模式的更多信息，请参阅 "doc/mob_db_mode_list.txt"。

A full list of pet IDs can be found inside 'db/(pre-)re/pet_db.yml'.
宠物编号的完整列表可在 "db/(pre-)re/pet_db.yml "中找到。

---------------------------------------

*makepet <pet id>;
*makepet <宠物编号>;

This command will create a pet egg and put it in the invoking character's
inventory. The kind of pet is specified by pet ID numbers listed in
'db/(pre-)re/pet_db.yml'. The egg is created exactly as if the character just successfully
caught a pet in the normal way.
该命令将创建一个宠物蛋，并将其放入调用角色的物品栏中。
宠物的种类由 "db/(pre-)re/pet_db.yml "中列出的宠物编号指定。
创建宠物蛋时，角色就像用普通方法成功捕获了一只宠物一样。

	// This will make you a poring:      捕获一只波利宠物
	makepet 1002;

Notice that you absolutely have to create pet eggs with this command. If you try
to give a pet egg with 'getitem', pet data will not be created by the char
server and the egg will disappear when anyone tries to hatch it.
请注意，您必须使用此命令创建宠物蛋。如果您尝试使用 "getitem "来给宠物蛋，
那么 char 服务器将不会创建宠物数据，而且当任何人尝试孵化宠物蛋时，宠物蛋都会消失。

---------------------------------------

*getpetinfo(<type>{,<char_id>})
*getpetinfo(<类型>{,<角色编号>})

This function will return pet information for the pet the invoking character
currently has active. Valid types are:
此函数将返回调用角色当前激活的宠物信息。有效类型为

 PETINFO_ID - Pet ID                                                                                          宠物编号
 PETINFO_CLASS - Pet class number as per 'db/(pre-)re/pet_db.yml' - will tell you what kind of a pet it is.   根据 "db/(pre-)re/pet_db.yml "获得的宠物类别编号 - 这将告诉你这是什么类型的宠物。
 PETINFO_NAME - Pet name. Will return "null" if there's no pet.                                               宠物名称。如果没有宠物，则返回 "null"。
 PETINFO_INTIMATE - Pet friendly level (intimacy score). 1000 is full loyalty.                                宠物友好等级（亲密程度）。1000 为完全忠诚。
 PETINFO_HUNGRY - Pet hungry level. 100 is full hunger.                                                       宠物饥饿等级。100 级为完全饥饿。
 PETINFO_RENAMED - Pet rename flag. 0 means this pet has not been named yet.                                  宠物重命名标志。0 表示该宠物尚未命名。
 PETINFO_LEVEL - Pet level                                                                                    宠物等级
 PETINFO_BLOCKID - Pet Game ID                                                                                宠物游戏编号
 PETINFO_EGGID - Pet egg item ID                                                                              宠物蛋的物品编号
 PETINFO_FOODID - Pet food item ID                                                                            宠物饲料的物品编号

PETINFO_INTIMATE can be used with the following constants for checking values:
PETINFO_INTIMATE 可以与下列常量一起使用，以检查(亲密度)数值：
 PET_INTIMATE_NONE = 0
 PET_INTIMATE_AWKWARD = 1 ~ 99
 PET_INTIMATE_SHY = 100 ~ 249
 PET_INTIMATE_NEUTRAL = 250 ~ 749
 PET_INTIMATE_CORDIAL = 750 ~ 909
 PET_INTIMATE_LOYAL = 910 ~ 1000

PETINFO_HUNGRY can be used with the following constants for checking values:
PETINFO_HUNGRY 可以与下列常量一起使用，以检查(饥饿度)数值：
 PET_HUNGRY_NONE = 0
 PET_HUNGRY_VERY_HUNGRY = 1 ~ 10
 PET_HUNGRY_HUNGRY = 11 ~ 25
 PET_HUNGRY_NEUTRAL = 26 ~ 75
 PET_HUNGRY_SATISFIED = 76 ~ 90
 PET_HUNGRY_STUFFED = 91 ~ 100

Example:
例子：
	mes "[Vet]";
	mes "Your pet + " getpetinfo(PETINFO_NAME);
	if (getpetinfo(PETINFO_INTIMATE) < PET_INTIMATE_LOYAL)
		mes "has some growing to do on you!";
	else
		mes "seems to love you very much!";
	close;

---------------------------------------

=============================
|10.1.- The Pet AI commands.|        宠物AI命令
=============================
---------------------------------------

These commands will only work if the invoking character has a pet, and are meant
to be executed from pet scripts. They will modify the pet AI decision-making for
the current pet of the invoking character, and will NOT have any independent
effect by themselves, which is why only one of them each may be in effect at any
time for a specific pet. A pet may have 'petloot', 'petskillbonus',
'petskillattack' OR 'petpetskillattack2' and 'petskillsupport'.
这些命令只有在调用角色拥有宠物的情况下才会生效，并且只能通过宠物脚本执行。
它们会修改调用角色当前宠物的AI，本身不会产生任何独立的效果，
这就是为什么在任何时候对特定宠物只能使用一种AI的原因。
宠物可以拥有'petloot'、'petskillbonus'、'petskillattack'或 'petpetskillattack2'和'petskillsupport'。

All commands with delays and durations will only make the behavior active for
the specified duration of seconds, with a delay of the specified number of
seconds between activations. Rates are a chance of the effect occurring and are
given in percent. 'bonusrate' is added to the normal rate if the pet intimacy is
at the maximum possible.
所有带有延迟和持续时间的命令只会在指定的秒数内激活行动，两次激活之间的延迟时间为指定的秒数。
比率是效果发生的几率，以百分比表示。如果宠物的亲密度达到最大值，"bonusrate "将被添加到正常比率中。

The behavior modified with the below mentioned commands will only be exhibited if
the pet is loyal and appropriate configuration options are set in
'battle_athena.conf'.
只有当宠物是忠诚的，并且在 "battle_athena.conf "中设置了适当的配置选项时，
使用下面提到的命令修改的行为才会表现出来。

Pet scripts in the database normally run whenever a pet of that type hatches
from the egg. Other commands usable in item scripts (see 'bonus') will also
happily run from pet scripts. Apparently, the pet-specific commands will also
work in NPC scripts and modify the behavior of the current pet up until the pet
is hatched again. (Which will also occur when the character is logged in again
with the pet still out of the egg.) It is not certain for how long the effect of
such command running from an NPC script will eventually persist, but apparently,
it is possible to usefully employ them in usable item scripts to create pet
buffing items.
数据库中的宠物脚本通常会在宠物蛋孵化出该类型宠物时运行。
其他可在物品脚本中使用的命令（见'bonus'）也可以在宠物脚本中运行。
显然，宠物专用命令也会在 NPC 脚本中生效，并修改当前宠物的行为，直到宠物再次孵化。
(当角色再次登录时，宠物仍在蛋外，也会出现这种情况）。
目前还不确定从 NPC 脚本中运行此类命令的效果最终会持续多久，
但显然可以在可用物品脚本中有效地使用它们来创建宠物效果加成物品。

Nobody tried this before, so you're essentially on your own here.
以前没人试过这个，所以你基本上只能靠自己。

---------------------------------------

*petskillbonus <bonus type>,<value>,<duration>,<delay>;
*petskillbonus <加成类型>,<值>,<持续事件>,<延迟>;

This command will make the pet give a bonus to the owner's stat in certain
duration in seconds and will be repeated for certain delay in seconds.

For a full bonus list, see 'doc/item_bonus.txt'
NOTE: Currently ONLY supported for bonuses that used by 'bonus' script.

---------------------------------------

*petrecovery <status type>,<delay>;

This command will make the pet cure a specified status condition. The curing
actions will occur once every Delay seconds. For a full list of status
conditions that can be cured, see the list of 'SC_' status condition constants
in 'src/map/script_constants.hpp'.
该命令会使宠物在以秒为单位的一定时间内为主人提供属性加成，并在以秒为单位的一定延迟内重复使用。
有关可附加状态的完整列表，请参阅 "src/map/script_constants.hpp "中的 "SC_"状态类型常量列表。


---------------------------------------

*petloot <max items>;
*petloot <最大物品数>;

This command will turn on pet looting, with a maximum number of items to loot
specified. Pet will store items and return them when the maximum is reached or
when pet performance is activated.
该命令将开启宠物拾取，并指定拾取物品的最大数量。
宠物会储存拾取的物品，并在达到最大值或激活宠物性能时归还。

---------------------------------------

*petskillsupport <skill id>,<skill level>,<delay>,<percent hp>,<percent sp>;
*petskillsupport "<skill name>",<skill level>,<delay>,<percent hp>,<percent sp>;
*petskillsupport <技能编号>,<技能等级>,<延迟>,<hp比率>,<sp比率>;
*petskillsupport "<技能名称>",<技能等级>,<延迟>,<hp比率>,<sp比率>;

This will make the pet use a specified support skill on the owner whenever the
HP and SP are below the given percent values, with a specified delay time
between activations. The skill numbers are as per 'db/(pre-)re/skill_db.yml'.
只要宠物的 HP 和 SP 低于给定的百分比值，宠物就会对主人使用指定的辅助技能，每次激活之间有指定的延迟时间。
技能编号与 "db/(pre-)re/skill_db.yml "一致。

It's not quite certain who's stats will be used for the skills cast, the
character's or the pets. Probably, Skotlex can answer that question.
目前还不能确定角色和宠物谁的属性会被用于施放技能。也许 Skotlex 可以回答这个问题。

---------------------------------------

*petskillattack <skill id>,<skill level>,<rate>,<bonusrate>;
*petskillattack "<skill name>",<skill level>,<rate>,<bonusrate>;
*petskillattack2 <skill id>,<damage>,<number of attacks>,<rate>,<bonusrate>;
*petskillattack2 "<skill name>",<damage>,<number of attacks>,<rate>,<bonusrate>;
*petskillattack <技能编号>,<技能等级>,<几率>,<加成几率>;
*petskillattack "<技能名称>",<技能等级>,<>,<加成几率>;
*petskillattack2 <技能编号>,<伤害>,<攻击次数>,<几率>,<加成几率>;
*petskillattack2 "<技能名称>",<伤害>,<攻击次数>,<几率>,<加成几率>;

These two commands will make the pet cast an attack skill on the enemy the pet's
owner is currently fighting. Skill IDs and levels are as per 'petskillsupport'.
'petskillattack2' will make the pet cast the skill with a fixed amount of damage
inflicted and the specified number of attacks.
这两个命令将使宠物对宠物主人正在战斗的敌人施放攻击技能。技能编号和等级与 "petskillsupport"相同。
"petskillattack2"会使宠物在施放技能时造成固定的伤害并达到指定的攻击次数。

Value of 'rate' is between 1 and 100. 100 = 100%
"几率"的值介于 1 和 100 之间。100 = 100%

---------------------------------------

*petautobonus <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*petautobonus2 <bonus script>,<rate>,<duration>{,<flag>,{<other script>}};
*petautobonus3 <bonus script>,<rate>,<duration>,<skill id>,{<other script>};
*petautobonus3 <bonus script>,<rate>,<duration>,"<skill name>",{<other script>};
*petautobonus <加成脚本>,<几率>,<持续时间>{,<标志>,{<其他脚本>}};
*petautobonus2 <加成脚本>,<几率>,<持续时间>{,<标志>,{<其他脚本>}};
*petautobonus3 <加成脚本>,<几率>,<持续时间>,<技能编号>,{<其他脚本>};
*petautobonus3 <加成脚本>,<几率>,<持续时间>,"<技能名称>",{<其他脚本>};

See 'autobonus' for more details.
更多详情，请参阅 'autobonus'。

---------------------------------------

===========================
|11.- Homunculus commands.|      人工生命体命令
===========================
---------------------------------------

*homevolution;

This command will try to evolve the current player's homunculus.
If it doesn't work, the /swt emotion is shown.
该命令将尝试进化当前玩家的人工生命体。
如果不起作用，就会显示 /swt 表情符号。

To evolve a homunculus, the invoking player must have a homunculus,
the homunculus must not be the last evolution and
the homunculus must have above 91000 intimacy with its owner.
要进化人工生命体，调用者必须拥有一个人工生命体，该人工生命体必须不是最后一次进化，
而且该人工生命体与主人的亲密程度必须超过 91000。

---------------------------------------

*morphembryo;

This command will try to put the invoking player's Homunculus in an
uncallable state, required for mutation into a Homunculus S. The player
will also receive a Strange Embryo (ID 6415) in their inventory if
successful, which is deleted upon mutation.
该命令会尝试让调用者的人工生命体处于不可召唤状态，这是变异成人工生命体 S 所必需的。
如果成功，玩家还将在库存中获得一个奇怪的胚胎（编号 6415），该胚胎会在变异后被删除。

The command will fail if the invoking player does not have an evolved
Homunculus at level 99 or above. The /swt emotion is shown upon failure.
如果调用者没有 99 级或以上的进化人工生命体，命令将失败。
失败时会显示 /swt 表情符号。

Returns 1 upon success and 0 for all failures.
成功时返回 1，失败时返回 0。

---------------------------------------

*hommutate {<ID>};
*hommutate {<编号>};

This command will try to mutate the invoking player's Homunculus into
a Homunculus S. The Strange Embryo (ID 6415) is deleted upon success.
该命令将尝试把调用者的人工生命体变异为人工生命体 S。
成功后将删除 "奇怪的胚胎"（ID 6415）。

The command will fail if the invoking player does not have an evolved
Homunculus at level 99 or above, if it is not in the embryo state
(from the 'morphembryo' command), or if the invoking player does not
possess a Strange Embryo. The /swt emotion is shown upon failure.
如果调用者没有 99 级或以上的人工生命体，如果人工生命体没有处于胚胎状态（来自 "morphembryo "命令），
或者如果调用者没有奇异胚胎，该命令将失败。失败时会显示 /swt 表情符号。

If the optional parameter <ID> is set, the invoking player's Homunculus
will change into the specified Homunculus ID. Otherwise, a random Homunculus S
will be chosen. See 'db/homunculus_db.txt' for a full list of IDs.
如果设置了可选参数 <编号>，调用玩家的人工生命体将变为指定的人工生命体编号。
否则，将随机选择一个人工生命体 S。有关编号的完整列表，请参阅 "db/homunculus_db.txt"。

Returns 1 upon success and 0 for all failures.
成功时返回 1，失败时返回 0。

---------------------------------------

*checkhomcall()

This function checks if the attached player's Homunculus is active,
and will return the following values:
此函数将检查所关联玩家的人工生命体是否处于激活状态，并返回以下值：
 -1: The player has no Homunculus.                 玩家没有人工生命体。
  0: The player's Homunculus is active.            玩家的人工生命体已激活
  1: The player's Homunculus is vaporized.         玩家的人工生命体未召唤
  2: The player's Homunculus is in morph state.    玩家的人工生命体处于变形状态。

---------------------------------------

*gethominfo(<type>{,<char_id>})
*gethominfo(<类型>{,<角色编号>})

This function will return Homunculus information for the Homunculus of the
invoking character, regardless of its vaporize state. It returns zero or
"null" if the player does not own a Homunculus.
此函数将返回调用角色的人工生命体信息，无论其处于何种状态。
如果玩家没有人工生命体，则返回 0 或 "空"。

Valid types are:
 0 - Homunculus ID        人工生命体编号
 1 - Homunculus Class     人工生命体类别
 2 - Homunculus Name      人工生命体名称
 3 - Homunculus friendly level (intimacy score). 100000 is full loyalty.     人工生命体友好等级（亲密程度评分）。100000 代表完全忠诚。
 4 - Homunculus hungry level. 100 is completely full.                        人工生命体饥饿好等级。100 已完全吃饱。
 5 - Homunculus rename flag. 0 means this homunculus has not been named yet. 人工生命体重命名标志。0 表示该人工生命体尚未被命名。
 6 - Homunculus level     人工生命体等级
 7 - Homunculus Game ID   人工生命体游戏编号

---------------------------------------

*homshuffle;

This will recalculate the homunculus stats according to its level, of the
current invoking character.
这将根据当前调用角色的等级重新计算人工生命体的属性。


---------------------------------------

*addhomintimacy <amount>{,<char_id>};
*addhomintimacy <数量>{,<角色编号>};

Increase or decrease a homunculus' intimacy value by the given <amount>. 100000 is full loyalty.
按给定的<数量>增加或减少人工生命体的亲密值。100000 表示完全忠诚。

---------------------------------------

==========================
|12.- Mercenary commands.|         佣兵命令
==========================
---------------------------------------

*mercenary_create <class>,<contract time>;
*mercenary_create <类别>,<契约时间>;

This command summons a mercenary for a given time (in milliseconds). For a
list of all available classes, see 'db/mercenary_db.txt'.
该命令会在指定时间（毫秒）内召唤一名雇佣兵。
有关所有可用类的列表，请参阅 "db/mercenary_db.txt"。

This command is typically used in item scripts of mercenary scrolls.
该命令通常用于佣兵卷轴的物品脚本中。

---------------------------------------

*mercenary_heal <hp>,<sp>;

This command works like 'heal', but affects the mercenary of the
currently attached character.
该命令的作用与'heal'类似，但作用于当前关联角色的佣兵。

---------------------------------------

*mercenary_sc_start <type>,<tick>,<val1>;
*mercenary_sc_start <类型>,<标识>,<变量1>;

This command works like 'sc_start', but affects the mercenary of the
currently attached character.
该命令的作用与 "sc_start"类似，但作用于当前关联角色的佣兵。

---------------------------------------

*mercenary_get_calls(<guild>);
*mercenary_set_calls <guild>,<value>;
*mercenary_get_calls(<工会>);
*mercenary_set_calls <工会>,<值>;

Sets or gets the mercenary calls value for given guild for currently
attached character. Guild can be one or the following constants:
设置或获取当前角色所属工会的佣兵召唤值。工会可以是一个或以下常数：

	ARCH_MERC_GUILD      弓箭手佣兵工会
	SPEAR_MERC_GUILD     枪兵佣兵工会
	SWORD_MERC_GUILD     剑士佣兵工会

---------------------------------------

*mercenary_get_faith(<guild>);
*mercenary_set_faith <guild>,<value>;
*mercenary_get_faith(<工会>);
*mercenary_set_faith <工会>,<值>;

Sets or gets the mercenary faith value for given guild for currently
attached character. Guild can be one or the following constants:
设置或获取当前角色所属公会的佣兵信仰值。公会可以是一个或以下常数：

	ARCH_MERC_GUILD      弓箭手佣兵工会
	SPEAR_MERC_GUILD     枪兵佣兵工会
	SWORD_MERC_GUILD     剑士佣兵工会

---------------------------------------

*getmercinfo(<type>{,<char id>});
*getmercinfo(<类型>{,<角色编号 id>});

Retrieves information about mercenary of the currently attached
character. If char id is given, the information of that character is
retrieved instead. Type specifies what information to retrieve and
can be one of the following:
获取当前关联角色的雇佣兵信息。如果给出角色编号，则会获取给定角色的信息。
类型指定要获取的信息，可以是以下信息之一：

	0 - Mercenary ID         佣兵编号
	1 - Mercenary Class      佣兵类别
	2 - Mercenary Name       佣兵名称
	3 - Mercenary faith value for this mercenary's guild, if any      该佣兵公会的佣兵信仰值（如有）
	4 - Mercenary calls value for this mercenary's guild, if any      该佣兵公会的佣兵召唤值（如有）
	5 - Mercenary kill count 佣兵消灭数
	6 - Mercenary remaining life time in msec   佣兵召唤剩余时间(毫秒)
	7 - Mercenary level      佣兵等级
	8 - Mercenary Game ID    佣兵游戏编号

If the character does not have a mercenary, the command returns ""
for name and 0 for all other types.
如果角色没有雇佣兵，则命令返回""（名称），返回 0（所有其他类型）。

---------------------------------------

======================
|13.- Party commands.|         组队命令
======================
---------------------------------------

*getpartyname(<party id>)
*getpartyname(<组队编号>)

This function will return the name of a party that has the specified ID number.
If there is no such party ID, "null" will be returned.
此函数将返回具有指定组队编号的组队的名称。
如果没有组队编号，则将返回"空"。

Lets say the ID of a party was saved as a global variable:
比方说，组队编号被保存为全局变量：

	// This would return the name of the party from the ID stored in a variable
	// 这将根据变量中存储的编号返回组队名称
	mes "You're in the '" + getpartyname($@var) + "' party, I know!";

---------------------------------------

*getpartymember <party id>{,<type>{,<array_variable>}};
*getpartymember <组队编号>{,<类型>{,<数组变量>}};

This command will find all members of a specified party and returns their names
(or character id or account id depending on the value of "type") into an array
of temporary global variables. There's actually quite a few commands like this
which will fill a special variable with data upon execution and not do anything
else.
该命令将查找指定组队的所有成员，并将他们的姓名（或角色编号或账号编号，取决于"类型"值）存入临时全局变量数组。
实际上有很多类似的命令，它们会在执行时将数据填入一个特殊变量，而不会做其他任何事情。

Upon executing this,
执行此操作后：

$@partymembername$[] is a global temporary string array which contains all the      $@partymembername$[] 是一个全局临时字符串数组，
                     names of these party members                                   其中包含所有组队成员的姓名（仅在类型为 0 或未指定时设置）。
                     (only set when type is 0 or not specified)

$@partymembercid[]   is a global temporary number array which contains the          $@partymembercid[] 是一个全局临时数字数组，
                     character id of these party members.                           其中包含所有组队成员的角色编号。
                     (only set when type is 1)

$@partymemberaid[]   is a global temporary number array which contains the          $@partymemberaid[] 是一个全局临时数字数组，
                     account id of these party members.                             其中包含所有组队成员的账号编号。
                     (only set when type is 2)

$@partymembercount   is the number of party members that were found.                $@partymembercount 是找到的组队人数。

The party members will (apparently) be found regardless of whether they are
online or offline. Note that the names come in no particular order.
无论组队成员是在线还是离线，都能找到他们。请注意，这些名字并无特定顺序。

Be sure to use $@partymembercount to go through this array, and not
'getarraysize', because it is not cleared between runs of 'getpartymember'. If
someone with 7 party members invokes this script, the array would have 7
elements. But if another person calls up the NPC, and he has a party of 5, the
server will not clear the array for you, overwriting the values instead. So in
addition to returning the 5 member names, the 6th and 7th elements from the last
call remain, and you will get 5+2 members, of which the last 2 don't belong to
the new guy's party. $@partymembercount will always contain the correct number,
(5) unlike 'getarraysize()' which will return 7 in this case.
请务必使用 $@partymembercount 来查看该数组，而不是使用 "getarraysize"，
因为在运行 "getpartymember "时不会清除该数组。 如果有7名组队队员调用这个脚本，
数组中就会有 7 个元素。但是，如果另一个人激活 NPC，而他有一个 5 人团队，
服务器将不会为你清除数组，而是覆盖数值。因此，除了返回 5 个成员的姓名外，
上次调用的第 6 和第 7 个元素也会保留，您将得到 5+2 个成员，其中最后 2 个不属于新组队的成员。
$@partymembercount 将始终包含正确的数字（5），而不像 "getarraysize()"在这种情况下会返回 7。

If 'array_variable' is set, the result will be stored to that variable instead
using global variable.
如果设置了 "array_variable"，结果将存储到该变量中，而不是使用全局变量。

Example 1: list party member names
例子1：列出所有组队成员的名称

	// get the party member names    获得所有组队成员的名称
	getpartymember getcharid(1),0;

	// It's a good idea to copy the global temporary $@partymember*****                 将全局临时变量 $@partymember***** 复制到你自己的范围变量中是个好主意，
	// variables to your own scope variables because if you have pauses in this         因为如果你在这个脚本中有暂停（sleep、sleep2、next、close2、input、menu、select 或 prompt），
	// another player could click this NPC, trigger 'getpartymember', and               其他玩家可能会点击这个 NPC，触发'getpartymember'，并覆盖 $@partymember***** 变量。
	// script (sleep, sleep2, next, close2, input, menu, select, or prompt),
	// overwrite the $@partymember***** variables.
	.@count = $@partymembercount;
	copyarray .@name$[0], $@partymembername$[0], $@partymembercount;

	// list the party member names     列出所有组队成员的名称
	for (.@i = 0; .@i < .@count; .@i++)
		mes (.@i +1) + ". ^0000FF" + .@name$[.@i] + "^000000";
	close;


Example 2: check party count (with a 'next' pause), before warping to event
例子2：在跳转到事件之前，（有'next'"停顿），检查队伍人数。

	.register_num = 5; // How many party members are required?   需要多少组队成员

	// get the charID and accountID of character's party members  获取角色所在队伍所有成员的角色编号和账户编号
	getpartymember getcharid(1), 1;
	getpartymember getcharid(1), 2;

	if ( $@partymembercount != .register_num ) {
		mes "Please form a party of " + .register_num + " to continue";
		close;
	}

	// loop through both and use 'isloggedin' to count online party members   同时循环使用 "isloggedin"来计算在线组队成员人数
	for ( .@i = 0; .@i < $@partymembercount; .@i++ )
		if ( isloggedin( $@partymemberaid[.@i], $@partymembercid[.@i] ) )
			.@count_online++;

	// We search accountID & charID because a single party can have multiple          我们搜索账户编号和角色编号是因为一个组队可以有多个来自同一账户的角色。
	// characters from the same account. Without searching through the charID,        如果不搜索角色便哈奥，如果一个玩家的队伍中有 2 个来自同一账户的角色，
	// if a player has 2 characters from the same account inside the party but        但只有 1 个角色在线，那么就会重复计算他们的在线角色。
	// only 1 char online, it would count their online char twice.

	if ( .@count_online != .register_num ) {
		mes "All your party members must be online to continue";
		close;
	}

	// copy the array to prevent players cheating the system     复制数组，防止玩家作弊
	copyarray .@partymembercid, $@partymembercid, .register_num;

	mes "Are you ready ?";
	next; // careful here
	select("Yes");

	// When a script hits a next, menu, sleep or input that pauses the script,      当脚本遇到next、menu、sleep或暂停脚本的输入时，
	// players can invite or /leave and make changes in their party. To prevent     玩家可以邀请或/离开并更改他们的组队。为了防止这种情况，
	// this, we call getpartymember again and compare with the original values.     我们会再次调用 getpartymember 并与原始值进行比较。

	getpartymember getcharid(1), 1;
	if ( $@partymembercount != .register_num ) {
		mes "You've made changes to your party !";
		close;
	}
	for ( .@i = 0; .@i < $@partymembercount; .@i++ ) {
		if ( .@partymembercid[.@i] != $@partymembercid[.@i] ) {
			mes "You've made changes to your party !";
			close;
		}
	}

	// Finally, it's safe to start the event!       最后，可以安全地开启事件！
	warpparty "event_map", 0,0, getcharid(1);

---------------------------------------

*getpartyleader(<party id>{,<type>})
*getpartyleader(<组队编号>{,<类型>})


This function returns some information about the given party-id's leader.
When type is omitted, the default information retrieved is the leader's name.
Possible types are:
该函数返回给定组队编号的队长一些信息。当省略类型时，默认获取的信息是队长的名称。
允许的类型有

	1: Leader account id              队长的账号编号
	2: Leader character id            队长的角色编号
	3: Leader's class                 队长的类别
	4: Leader's current map name      队长当前所在的地图名称
	5: Leader's current level as stored on the party structure (may not be       队长的当前等级，存储在组队的结构体中
	   current level if leader leveled up recently).                            （如果队长最近提升了等级，则可能不是当前等级）。

If retrieval fails (leader not found or party does not exist), this function
returns "null" instead of the character name, and -1 for the other types.
如果检索失败（未找到队长或组队不存在），该函数将返回 "空"，而不是字符名，其他类型则返回-1。

---------------------------------------

*is_party_leader({<party ID>})
*is_party_leader({<组队编号>})

This command will return true if the player attached to the script is the leader
of his/her party, or, if a party ID is specified, of that party.
如果脚本中的玩家是他/她所在组队的队长，或者如果指定了组队编号，则是该组队的队长，则此命令将返回 true。

---------------------------------------

*party_create("<party name>"{,<character id>{,<item share>,<item share type>}});
*party_create("<组队名称>"{,<角色编号>{,<物品分享>,<物品分享类型>}});

Organizes a party with the attached or specified character as leader. If
successful, the command returns 1 and sets the global temporary variable
"$@party_create_id" to the ID of the party created.
以关联角色或者指定角色为队长组建一个队伍。
如果成功，命令返回 1，并将全局临时变量"$@party_create_id "设置为组建的组队编号。

Additionally, item sharing options can be provided:
此外，还可设置物品共享选项：
 - Item Share: 0-Each Take (default), 1-Party Share                     - 物品共享: 0-各自取得 (默认), 1-组队分享
 - Item Share Type: 0-Each Take (default), 1-Even Share                 - 物品共享类型: 0-各自取得 (默认), 1-平均分享

These values are returned upon failure:
失败时将返回这些值：
 0: Unknown error.                 未知错误
-1: Player not found.              未找到玩家
-2: Player already has a party.    玩家已有加入组队
-3: Party name exists.             组队名称不存在

---------------------------------------

*party_destroy(<party id>);
*party_destroy(<组队编号>);

Disbands a party. The command returns 1 upon success and 0 upon failure.
解散一各组队。命令成功时返回 1，失败时返回 0。

---------------------------------------

*party_addmember(<party id>,<character id>);
*party_addmember(<组队编号>,<角色编号>);

Adds a player to an existing party.
为现有组队添加一名玩家。

The command returns 1 upon success, and these values upon failure:
命令成功时返回 1，失败时返回这些值：
 0: Unknown error.                 未知错误
-1: Player not found.              未找到玩家
-2: Player already has a party.    玩家已有加入组队
-3: Party not found.               未找到组队
-4: Party is full.                 组队人数已满
-5: Another character from the same account is already in the party.     同一账户中的另一个角色已经加入。

---------------------------------------

*party_delmember({<character id>,<party id>});
*party_delmember({<角色编号>,<组队编号>});

Removes a player from his/her party. If no player is specified, the command
will run for the invoking player. If that player is the only party member
remaining, the party will be disbanded.
将一名玩家从他/她的队伍中除名。如果没有指定玩家，命令将作用于调用的玩家。
如果该组队只有一名玩家，组队就会解散。

The command returns 1 upon success, and these values upon failure:
命令成功时返回 1，失败时返回这些值：
 0: Unknown error.                  未知错误
-1: Player not found.               未找到玩家
-2: Party not found.                未找到组队
-3: Player is not in the party.     玩家未在组队里

---------------------------------------

*party_changeleader(<party id>,<character id>);
*party_changeleader(<组队编号>,<角色编号>);

Transfers leadership of a party to the specified character.
将组队的队长变更为指定角色。

The command returns 1 upon success, and these values upon failure:
命令成功时返回 1，失败时返回这些值
 0: Unknown error.
-1: Party not found.                    未知错误
-2: Player not found.                   未找到玩家
-3: Player is not in the party.         玩家未在组队里
-4: Player is already party leader.     玩家已是组队的队长

---------------------------------------

*party_changeoption(<party id>,<option>,<flag>);
*party_changeoption(<组队编号>,<选型>,<标志>);

Changes a party option.
更改组队选项。

Valid options are:
有效选项有：
 0 - Exp Share (flags: 0-Each Take, 1-Even Share)      Exp分享 (标志: 0-各自取得, 1-平均分配)
 1 - Item Share (flags: 0-Each Take, 1-Party Share)    物品分享 (标志: 0-各自取得, 1-队员共享)
 2 - Item Share Type (flags: 0-Each Take, 1-Even Share)  物品分享类型 (标志: 0-各自取得, 1-平均分配)

The command returns 1 upon success, and these values upon failure:
命令成功时返回 1，失败时返回这些值
 0: Invalid option.       无效选项。
-1: Party not found.      未找到组队

---------------------------------------

*opendressroom(<flag>{,<char_id>});
*opendressroom(<标志>{,<角色编号>});

This will open the Dress Room window on the client connected to the invoking character.
这将在与调用角色相连的客户端上打开 "换装"窗口。

	mes "Close this window to open the Dress Room window.";
	close2;
	opendressroom(1);
	end;

Valid flag are:
有效的标志有：
 1 - Open the Dress Room window     打开 "换装"窗口。

---------------------------------------

*navigateto("<map>"{,<x>,<y>,<flag>,<hide_window>,<monster_id>,<char_id>});
*navigateto("<地图>"{,<坐标x>,<坐标y>,<标志>,<隐藏窗口>,<魔物编号>,<角色编号>});

Generates a navigation for attached or specified character. Requires client
2011-10-10aRagEXE or newer.
为关联或指定角色生成导航。需要 2011-10-10aRagEXE 或更新版本的客户端。

The flag specifies how the client will calculate the specific route.
该标志指定了客户端计算特定路由的方式。

Valid flags are:
有效标志为：
 NAV_NONE - No services                          无服务
 NAV_AIRSHIP_ONLY - Airship only                 仅飞空艇
 NAV_SCROLL_ONLY - Scroll only                   仅卷轴
 NAV_AIRSHIP_AND_SCROLL - Airship and Scroll     飞空艇和卷轴
 NAV_KAFRA_ONLY - Kafra only                     仅卡普拉
 NAV_KAFRA_AND_AIRSHIP - Kafra and Airship       卡普拉和飞空艇
 NAV_KAFRA_AND_SCROLL - Kafra and Scroll         卡普拉和卷轴
 NAV_ALL - All services                          所有服务

When flag is not specified, the default value is NAV_KAFRA_AND_AIRSHIP.
未指定标志时，默认值为 NAV_KAFRA_AND_AIRSHIP。

The hide_window specifies whether to display (0) or hide (1) the navigation window.
By default the window is hidden.
<隐藏窗口>指定是显示（0）还是隐藏（1）导航窗口。
默认情况下，窗口是隐藏的。

You can specify the monster_id in combination with a mapname to make the
navigation system tell you, that you have reached the desired mob.
您可以指定魔物编号和地图名称，这样导航系统就会告诉您，您已经到达了所需的魔物物所在地。

Note:
The client requires custom monster spawns be in the navigation file
for using the embedded client Navigation feature to work properly. In this
instance sending the player to the map where the monster spawns is a simpler
solution rather than sending the map and the monster_id.
注意：
客户端要求在导航文件中包含自定义怪物重生点，
以便使用嵌入式客户端导航功能正常工作。在这种情况下，
将玩家发送到魔物出现的地图比发送地图和魔物编码更简单。

---------------------------------------

*hateffect(<Hat Effect ID>,<State>);
*hateffect(<头饰特效编号>,<状态>);

This will set a Hat Effect onto the player. The state field allows you to
enable (true) or disable (false) the effect on the player.
The Hat Effect constants can be found in 'src/map/script_constants.hpp' starting
with HAT_EF_*.
这将在玩家身上设置头饰特效。头饰特效常量可在 "src/map/script_constants.hpp "中找到，
以 HAT_EF_* 开头。

Requires client 2015-05-13aRagEXE or newer.
需要2015-05-13aRagEXE或更新的客户端

---------------------------------------

*getrandomoptinfo(<type>);
*getrandomoptinfo(<类型>);

Returns value of an attribute of current random option.
返回当前随机选项的属性值。

Valid attributes are:
有效的属性有：
ROA_ID - ID of current option                  当前属性的编号
ROA_VALUE - Value field of current option      当前属性的值域
ROA_PARAM - Param field of current option      当前选项的参数值域

This script command is intended for using in random option scripts.
该脚本命令用于随机属性脚本。

---------------------------------------

*getequiprandomoption(<equipment index>,<index>,<type>{,<char id>});
*getequiprandomoption(<装备索引>,<索引>,<类型>{,<角色编号>});

Returns value of an attribute of a random option on an equipped item.
返回装备物品上随机属性的属性值。

See 'getequipid' for a full list of valid equipment slots.
请参阅 "getequipid "获取有效装备槽的完整列表。

index parameter can be 0 to MAX_ITEM_RDM_OPT-1 (default 0-4).
索引参数可以是 0 至 MAX_ITEM_RDM_OPT-1（默认值 0-4）。

For valid attribute types, see `getrandomoptinfo` command reference.
有关有效的属性类型，请参阅 `getrandomoptinfo` 命令参考。

---------------------------------------

*setrandomoption(<equipment slot>,<index>,<id>,<value>,<param>{,<char id>});
*setrandomoption(<装备槽>,<索引>,<编号>,<值>,<参数>{,<角色编号>});

Sets <index+1>th random option for equipment equipped at <equipment slot>
to <id>, <value> and <param>.
将<装备槽>装备的<索引+1>个随机选项设置为<编号>、<值>和<参数>。

See 'getequipid' for a full list of valid equipment slots.
请参阅 "getequipid "获取有效装备槽的完整列表。

index parameter can be 0 to MAX_ITEM_RDM_OPT-1 (default 0-4).
索引参数可以是 0 至 MAX_ITEM_RDM_OPT-1（默认值 0-4）。

ID - ID of random option. See db/const.txt for constants.   随机属性的编号。参考db/const.txt中的常量说明
Value - Value of random option                              随机属性值
Param - Parameter of random option                          随机属性参数

---------------------------------------

*clan_join(<clan id>{,<char id>});
*clan_join(<群组编号>{,<角色编号>});

The attached player joins the clan with the <clan id>. On a successful join,
true is returned, else false if the join failed.
If <char id> is specified, the specified player is used rather than the attached one.
所附玩家以 <群组编号> 加入群组。如果加入成功，则返回 true；如果加入失败，则返回 false。
如果指定了 <角色编号>，则会使用指定的玩家而不是关联的玩家。

---------------------------------------

*clan_leave({<char id>});
*clan_leave({<角色编号>});

The attached player will leave their clan. On a successful leave, true is returned,
else false if the leave failed.
If <char id> is specified, the specified player is used rather than the attached one.
关联玩家将离开其群组。如果离开成功，则返回 true；如果离开失败，则返回 false。
如果指定了 <角色编号>，则会使用指定的玩家而不是关联的玩家。

---------------------------------------

========================
|14.- Channel commands.|      频道命令
========================
---------------------------------------

*channel_create "<chname>","<alias>"{,"<password>"{<option>{,<delay>{,<color>{,<char_id>}}}}};
*channel_create "<频道名称>","<别名>"{,"<密码>"{<选项>{,<延迟>{,<颜色>{,<角色编号>}}}}};

Creates a public channel with <chname> as the channel name. To protect the
channel, use <password> or write "null" to create it without a password.
Channel name must start with '#' and cannot be the same as the map or ally
channel names.
创建一个公共频道，频道名称为 <chname>。要保护该频道，请使用 <密码> 或写入 "null "以创建无密码频道。
频道名称必须以 "#"开头，且不能与地图或盟友频道名称相同。

<alias> will be used to change the channel name when the channel message
is displayed.
当显示频道信息时，<别名> 将用于更改频道名称。

<option> values are:
<选型> 的值有:
	CHAN_OPT_BASE		    - Default option including CHAN_OPT_ANNOUNCE_SELF|CHAN_OPT_MSG_DELAY|CHAN_OPT_CAN_CHAT|CHAN_OPT_CAN_LEAVE      默认选项，包含:CHAN_OPT_ANNOUNCE_SELF|CHAN_OPT_MSG_DELAY|CHAN_OPT_CAN_CHAT|CHAN_OPT_CAN_LEAVE
	CHAN_OPT_ANNOUNCE_SELF  - Show info for player itself if player has joined/leaves the channel    在玩家加入/离开频道时显示玩家本身的信息
	CHAN_OPT_ANNOUNCE_JOIN  - Display message when player is joining the channel                     玩家加入频道时显示信息
	CHAN_OPT_ANNOUNCE_LEAVE - Display message when player is leaving the channel                     玩家离开频道时显示信息
	CHAN_OPT_MSG_DELAY	    - Enable chat delay for the channel                                      为频道启用聊天延迟
	CHAN_OPT_COLOR_OVERRIDE - Player's unique font color will override channel's color               玩家独特的字体颜色将覆盖频道颜色
	CHAN_OPT_CAN_CHAT	    - Player can chat in the channel                                         玩家可以在频道中聊天
	CHAN_OPT_CAN_LEAVE	    - Player can leave the channel                                           玩家可以离开频道
	CHAN_OPT_AUTOJOIN	    - Players will auto join the channel at login                            玩家登录后将自动加入频道

The <delay> is the minimum chat delay in millisecond for a single player before
the player can chat again in the same channel.
<延迟> 是单个玩家在同一频道再次聊天前的最小聊天延迟（毫秒）。


Use <color> hex code to set the color for this channel, if not defined, default
channel color will be used.
使用 <颜色> 十六进制代码为该通道设置颜色，如果未定义，将使用默认通道颜色。

If <char_id> is defined, the channel will be a private channel and the player
will be the the channel owner.
如果定义了 <角色编号>，该频道将是一个私人频道，玩家将是频道所有者。

Returns 1 on success.
成功返回1。

	/**
	 * This example will shows the message on this channel as   此示例会将此频道上的信息显示为 [rAthena] Admin : Hello world! 
	 * [rAthena] Admin : Hello world!                           而不是 #rathena Admin : Hello world！
	 * instead of
	 * #rathena Admin : Hello world!
	 **/
	channel_create("#rathena","[rAthena]");
	channel_create("#vip","[VIP]","vipmemberonly");

---------------------------------------

*channel_setopt "<chname>",<option>,<value>;
*channel_setopt "<频道名称>",<选项>,<值>;

Set option for the channel. Use 1 in <value> to set it, or 0 to unset.
The <option> values are the same as the 'channel_create' options.
设置频道的选项。在 <值> 中用 1 表示设置，用 0 表示不设置。
<选项> 值与 "channel_create "选项相同。

For CHAN_OPT_MSG_DELAY, the delay in millisecond must be sent or use 0
to remove the delay at <value>.
对于 CHAN_OPT_MSG_DELAY，必须发送以毫秒为单位的延迟，或者使用 0 来消除<值>处的延迟。

Returns 1 on success.
成功返回1。

	// Example to set delay  设置延迟的例子
	channel_setopt("#global",CHAN_OPT_MSG_DELAY,5000);

Only for public and private channel.
仅适用于公共和私人频道。

---------------------------------------

*channel_getopt "<chname>",<option>;
*channel_getopt "<频道名称>",<选项>;

Get option value for the channel. The <option> values are the same as the
'channel_create' options. Returns true or false except for CHAN_OPT_MSG_DELAY
which returns an integer.
获取通道的选项值。<选项> 值与 "channel_create "选项相同。
除了 CHAN_OPT_MSG_DELAY 返回一个整数外，其余均返回 true 或 false。


	// Example to get the delay    获取延迟的例子
	.delay = channel_getopt("#global",CHAN_OPT_MSG_DELAY);

Only for public and private channel.
仅适用于公共和私人频道。

---------------------------------------

*channel_setcolor "<chname>",<color>;
*channel_setcolor "<频道名称>",<颜色>;

To change channel color.
<color> uses hex RGB values.
更改通道颜色。
<color> 使用十六进制 RGB 值。

Returns 1 on success.
成功返回1。

---------------------------------------

*channel_setpass "<chname>","<password>";
*channel_setpass "<频道名称>","<密码>";

To set, unset, or change password of a channel.
Use "null" to remove the password.
设置、取消或更改频道密码。
使用 "null "删除密码。

Returns 1 on success.
Only for public and private channel.
成功返回1。仅适用于公共和私人频道。

---------------------------------------

*channel_setgroup "<chname>",<group_id>{,...,<group_id>};
*channel_setgroup2 "<chname>",<array_of_groups>;
*channel_setgroup "<频道名称>",<组编号>{,...,<组编号>};
*channel_setgroup2 "<频道名称>",<组列表>;

Set group restriction for a channel. Only player with matching <group_id>
are allowed to to join the channel.
为频道设置组别限制。只有匹配 <组编号> 的玩家才能加入该频道。

By using 0 in the first group channel, the group restriction will be
removed from the channel config.
如果在第一个组频道中使用 0，组限制将从频道配置中删除。

'channel_setgroup2' receives input for group list as an array.
'channel_setgroup2'以数组形式接收组列表的输入值。

Returns 0 on failure, and 1 (or n groups count) on success.
失败时返回 0，成功时返回 1（或 n 组计数）。

	// Example 1: Remove groups   例1：移除组
	channel_setgroup("#event",0);

	// Example 2: Multiple values 例2：多重值
	channel_setgroup("#vip",2,5);

	// Example 3: Using array     例3：使用数组
	setarray .@staffs[0],2,3,4,10,99;
	channel_setgroup("#staff",.@staffs);

Only for public and private channel.
仅适用于公共和私人频道。

---------------------------------------

*channel_chat "<chname>","<message>"{,<color>};
*channel_chat "<频道名称>","<信息>"{,<颜色>};

Sends message to the channel.
Returns 1 on success.
向频道发送信息。
成功时返回 1。

	// Example if channel doesn't have alias      没有别名的频道示例
	channel_chat(#rathena,"Hello World!"); // #rathena Hello World!

	// Example if channel has alias               有别名的频道示例
	channel_chat(#rathena,"Hello World!"); // [rAthena] Hello World!

---------------------------------------

*channel_ban "<chname>",<char_id>;
*channel_ban "<频道名称>",<角色编号>;

Ban player from a public or private channel.
Channel's owner or group with PC_PERM_CHANNEL_ADMIN cannot be banned.
Returns 1 on success.
封禁公共或私人频道的玩家。
不能封禁频道所有者或带有 PC_PERM_CHANNEL_ADMIN 的组。
成功时返回 1。

---------------------------------------

*channel_unban "<chname>",<char_id>;
*channel_unban "<频道名称>",<角色编号>;

Unban player from a public or private channel.
Returns 1 on success.
解除已封禁的公共或私人频道的玩家。
成功时返回 1。

---------------------------------------

*channel_kick "<chname>",<char_id>;
*channel_kick "<chname>","<char_name>";
*channel_kick "<频道名称>",<角色编号>;
*channel_kick "<频道名称>","<角色名称>";

Kick player from a public or private channel.
Channel's owner or group with PC_PERM_CHANNEL_ADMIN cannot be kicked.
Returns 1 on success.
从公共或私人频道踢出玩家。
带有 PC_PERM_CHANNEL_ADMIN 的频道所有者或组不能被踢。
成功时返回 1。

---------------------------------------

*channel_delete "<chname>";
*channel_delete "<频道名称>";

Delete an existing public or private channel. Cannot delete ally or
local map channel.
Returns 0 on success.
删除现有的公共或私人频道。不能删除盟友或本地地图频道。
成功时返回 0。

---------------------------------------

============================
|15.- Achievement commands.|      成就指令
============================
---------------------------------------

*achievementadd(<achievement id>{,<char id>})
*achievementadd(<成就编号>{,<角色编号>})

This function will add an achievement to the player's log for the attached
player or the supplied <char id>. The objective requirements are not ignored
when using this function.
Returns true on success and false on failure.
此函数将在玩家日志中为关联的玩家或所提供的 <角色编号> 添加一个成就。
使用此函数时不会忽略目标要求。
成功时返回 true，失败时返回 false。

---------------------------------------

*achievementremove(<achievement id>{,<char id>})
*achievementremove(<成就编号>{,<角色编号>})

This function will remove an achievement from the player's log for the attached
player or the supplied <char id>.
Returns true on success and false on failure.
此函数将从玩家日志中删除所关联玩家或所提供的 <角色编号> 的成就。
成功时返回 true，失败时返回 false。

---------------------------------------

*achievementinfo(<achievement id>,<type>{,<char id>})
*achievementinfo(<成就编号>,<类型>{,<角色编号>})

This function will return the specified <type> value for an achievement of the
attached player or the supplied <char id>. If the player doesn't have the
achievement active (no progress has been made): if the achievement doesn't
exist -1 will be returned, or -2 will be returned on any other error such as
an invalid <type>.
此函数将返回关联玩家成就的指定 <类型> 值或所提供的 <角色编号>。
如果玩家没有激活成就（没有取得任何进展）：如果成就不存在，将返回-1；
如果出现其他错误（如 <类型> 无效），将返回-2。

Valid types:
可用类型有：
- ACHIEVEINFO_COUNT1
- ACHIEVEINFO_COUNT2
- ACHIEVEINFO_COUNT3
- ACHIEVEINFO_COUNT4
- ACHIEVEINFO_COUNT5
- ACHIEVEINFO_COUNT6
- ACHIEVEINFO_COUNT7
- ACHIEVEINFO_COUNT8
- ACHIEVEINFO_COUNT9
- ACHIEVEINFO_COUNT10
- ACHIEVEINFO_COMPLETE
- ACHIEVEINFO_COMPLETEDATE
- ACHIEVEINFO_GOTREWARD
- ACHIEVEINFO_LEVEL (<achievement id> is useless for this)  (此类型<成就编号>无效)
- ACHIEVEINFO_SCORE (<achievement id> is useless for this)  (此类型<成就编号>无效)

---------------------------------------

*achievementcomplete(<achievement id>{,<char id>})
*achievementcomplete(<成就编号>{,<角色编号>})

This function will complete an achievement for the attached player or the supplied
<char id>. The objective requirements are ignored when using this function.
Returns true on success and false on failure.
此函数将为关联玩家或所提供的 <角色编号> 完成一项成就。
使用此函数时，目标要求将被忽略。 
成功时返回 true，失败时返回 false。

---------------------------------------

*achievementexists(<achievement id>{,<char id>});
*achievementexists(<成就编号>{,<角色编号>});

This function will return if the achievement exists on the player or the supplied
<char id> and is completed.
Returns true on success and false on failure.
如果成就存在于玩家或提供的 <角色编号> 中并已完成，该函数将返回值。
成功时返回 true，失败时返回 false。

---------------------------------------

*achievementupdate(<achievement id>,<type>,<value>{,<char id>})
*achievementupdate(<成就编号>,<类型>,<值>{,<<成就编号>{,<角色编号>}>})

This function will update an achievement's value for an achievement of the attached
player or the supplied <char id>. If the player does not have the achievement active
(no progress has been made) it will be added to the player's log first before updating
the <type> value.
Returns true on success and false on failure.
此函数将更新关联玩家或所提供的 <角色编号> 的成就值。
如果玩家没有激活成就（没有取得任何进展），则在更新 <type> 值之前，会先将成就添加到玩家的日志中。
成功时返回 true，失败时返回 false。

See 'achievementinfo' for valid <type> values.
有关有效的 <类型> 值，请参阅 "achievementinfo"。
- ACHIEVEINFO_COMPLETE, ACHIEVEINFO_COMPLETEDATE, and ACHIEVEINFO_GOTREWARD require the
  specific value returned from 'gettimetick(2)'.     ACHIEVEINFO_COMPLETE、ACHIEVEINFO_COMPLETEDATE 和 ACHIEVEINFO_GOTREWARD 要求使用 "gettimetick(2) "返回的特定值。
- Excludes ACHIEVEINFO_LEVEL and ACHIEVEINFO_SCORE.  不包括 ACHIEVEINFO_LEVEL 和 ACHIEVEINFO_SCORE。

---------------------------------------
































































翻译By 黑夜守望者 2024.1.27
----------------------------------------